<h1 align="center">
  <img src="https://img.shields.io/badge/TypeScript-3178C6?logo=TypeScript&logoColor=FFF&style=for-the-badge" 
       alt="TypeScript Badge" width="300" height="80"/>
</h1>

---

### ðŸ”¹ Basic

**1. What is TypeScript, and how is it different from JavaScript?**  
- TypeScript is a **typed superset of JavaScript** that adds **static types** and compiles to plain JavaScript.  
- Difference:  
  | Feature | JavaScript | TypeScript |
  |---------|-----------|------------|
  | Typing | Dynamic | Static optional typing |
  | Compilation | Interpreted by browser/Node | Compiled to JS |
  | Features | ES features | ES features + interfaces, enums, generics |

---

**2. What are the main advantages of using TypeScript?**  
- Detect errors at compile-time.  
- Improved IDE support (autocomplete, refactoring).  
- Supports OOP concepts like interfaces, enums, and generics.  
- Better maintainability for large-scale projects.

---

**3. What are types in TypeScript, and why are they useful?**  
- Types define the shape of variables, functions, objects, etc.  
- Useful for:  
  - Preventing runtime errors.  
  - Making code self-documenting.  
  - Allowing IDEs to provide better autocomplete.

---

**4. Explain the difference between `any`, `unknown`, `never`, and `void`.**  
- `any` â†’ disables type checking; can assign anything.  
- `unknown` â†’ safer version of `any`; you must type-check before using.  
- `never` â†’ represents values that **never occur** (e.g., functions that throw errors).  
- `void` â†’ represents **no return value** from a function.

```ts
let a: any = 10;
let b: unknown = "hello";
function error(): never { throw new Error("Error!"); }
function log(): void { console.log("Hi"); }
```

---

**5. What is the difference between `interface` and `type alias`?**  
- **Interface**: Mainly for objects and can **extend** other interfaces.  
- **Type alias**: Can define **any type**, including unions and primitives.  
- Example:

```ts
interface Person { name: string; age: number; }
type ID = string | number;
```

---

**6. What are enums in TypeScript? Provide an example.**  
- Enums define **named constants**.  
```ts
enum Color { Red, Green, Blue }
let c: Color = Color.Green;
```

---

**7. How does type inference work in TypeScript?**  
- TypeScript **automatically infers types** if not explicitly declared.  
```ts
let x = 10; // inferred as number
```

---

**8. What are generics in TypeScript? Give a simple example.**  
- Generics allow **type-safe reusable components**.  
```ts
function identity<T>(arg: T): T { return arg; }
let num = identity<number>(5);
```

---

**9. What is the difference between `readonly` and `const`?**  
- `const` â†’ variable cannot be reassigned.  
- `readonly` â†’ property of an object cannot be changed after initialization.  
```ts
const x = 10;
interface Point { readonly x: number; y: number; }
```

---

**10. How do you enable strict type-checking in TypeScript?**  
- In `tsconfig.json`:
```json
{
  "compilerOptions": { "strict": true }
}
```

---

### ðŸ”¹ Intermediate

**1. Explain structural typing vs nominal typing.**  
- **Structural typing** â†’ type compatibility based on **shape** of the object. (TS uses this)  
- **Nominal typing** â†’ types must be explicitly declared to match.

---

**2. What are utility types in TypeScript?**  
- Predefined types for transformations:  
```ts
type Partial<T> = { [P in keyof T]?: T[P] };
type Pick<T, K extends keyof T> = { [P in K]: T[P] };
type Omit<T, K extends keyof T> = { [P in Exclude<keyof T, K>]: T[P] };
type Record<K extends keyof any, T> = { [P in K]: T };
```

---

**3. Difference: `interface A extends B` vs `type A = B & {}`**  
- Interface can **extend multiple interfaces**; type alias uses **intersection (&)**.  
- Often interchangeable for objects.

---

**4. What are declaration files (`.d.ts`)?**  
- Provide **type information** for JS libraries without TS types.  
- Example: `npm install @types/lodash`

---

**5. Explain module resolution in TypeScript.**  
- How TS **finds imported modules** using `node` or `classic` strategy.

---

**6. What is the purpose of `tsconfig.json`?**  
- Configures **compiler options**, **paths**, **strictness**, etc.

---

**7. Compile-time vs runtime errors**  
- Compile-time â†’ caught by TS compiler.  
- Runtime â†’ errors in execution (JS level).

---

**8. Discriminated unions (tagged unions)**  
- Union types with a common **literal property** for safe type narrowing.  
```ts
type Shape = { kind: 'circle', radius: number } | { kind: 'square', size: number };
```

---

**9. Handling `null` and `undefined`**  
- Use `strictNullChecks` and optional chaining (`?.`).  

---

**10. Type narrowing example**  
```ts
function process(value: string | number) {
  if (typeof value === 'string') console.log(value.toUpperCase());
  else console.log(value + 1);
}
```

---

### ðŸ”¹ Advanced

**1. Conditional types**  
```ts
type TypeName<T> = T extends string ? "string" : "other";
```

---

**2. Difference: `keyof`, `typeof`, `in`**  
- `keyof` â†’ keys of a type  
- `typeof` â†’ type of a value  
- `in` â†’ iterates over keys in mapped types

---

**3. Mapped types example**  
```ts
type Readonly<T> = { readonly [P in keyof T]: T[P] };
```

---

**4. Difference: `unknown` vs `any`**  
- `unknown` â†’ safer; must narrow type  
- `any` â†’ disables type checking

---

**5. Function overloading**  
```ts
function add(a: string, b: string): string;
function add(a: number, b: number): number;
function add(a: any, b: any) { return a + b; }
```

---

**6. Intersection vs Union types**  
- Intersection (`&`) â†’ all properties combined  
- Union (`|`) â†’ one of the types

---

**7. Template literal types (TS 4.1+)**  
```ts
type Event = `on${"Click" | "Hover"}`; // "onClick" | "onHover"
```

---

**8. Generic constraint**  
```ts
function log<T extends { name: string }>(obj: T) { console.log(obj.name); }
```

---

**9. Const assertion**  
```ts
const colors = ["red", "green"] as const;
```
- Makes tuple **readonly and literal types**.

---

**10. Type guards example**  
```ts
function isString(x: any): x is string { return typeof x === "string"; }
```

---

### ðŸ”¹ Scenario-Based

**1. Function with dynamic keys but string values**  
```ts
function logData(obj: Record<string, string>) { console.log(obj); }
```

**2. Type with all optional except one**  
```ts
type Obj = { required: string } & Partial<{ optional1: number, optional2: boolean }>;
```

**3. Function returning first element of array**  
```ts
function first<T>(arr: T[]): T { return arr[0]; }
```

**4. Migrating JS to TS**  
- Start with `allowJs` in `tsconfig.json`, gradually add types.

**5. Type-safe API response handler**  
```ts
interface ApiResponse<T> { data: T; status: number; }
function handleResponse<T>(res: ApiResponse<T>): T { return res.data; }
```

**6. React component props typing**  
```ts
interface Props { name: string; age?: number; }
const Component: React.FC<Props> = ({ name, age }) => <div>{name}</div>;
```

**7. Typing `fetch` response**  
```ts
const res = await fetch(url);
const data: MyType = await res.json();
```

**8. Type-safe nested object access**  
```ts
type Nested = { a?: { b?: { c?: number } } };
const val = obj.a?.b?.c;
```

**9. Third-party JS library without types**  
```ts
declare module "library-name";
```

**10. Typing Redux reducer**  
```ts
interface State { count: number; }
type Action = { type: "INCREMENT" } | { type: "DECREMENT" };
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "INCREMENT": return { count: state.count + 1 };
    default: return state;
  }
}
