<img src="https://img.shields.io/badge/TypeScript-3178C6?logo=TypeScript&logoColor=FFF&style=for-the-badge" alt="TypeScript Badge" width="300" height="80"/>

---

### üîπ 1. Basics

- **Types**: string, number, boolean, null, undefined, any, unknown
- **Arrays**: `number[]`, `Array<string>`
- **Tuples**: `[string, number]`
- **Enums**: numeric & string enums
- **Type Aliases**: `type ID = string | number`
- **Interfaces**: contracts for objects
- **Functions**:

  - Return types
  - Optional params
  - Default params
  - Arrow functions

---

### üîπ 2. Advanced Types

- **Union Types**: `string | number`
- **Intersection Types**: `A & B`
- **Literal Types**: "up" | "down"
- **Type Narrowing**: `typeof`, `instanceof`, custom type guards
- **Type Assertions**: `value as string`
- **Nullable**: `string | null`
- **Non-null Assertion**: `value!`

---

### üîπ 3. OOP (Classes)

- **Class Members**: public, private, protected, readonly
- **Constructors**
- **Inheritance**: `extends`
- **Abstract Classes**
- **Interfaces as Contracts**

---

### üîπ 4. Generics

- **Functions**: `function identity<T>(arg: T): T`
- **Generic Constraints**: `<T extends Lengthwise>`
- **Interfaces with Generics**
- **Utility with Generics**

---

### üîπ 5. Utility Types

- **Partial<T>**
- **Readonly<T>**
- **Pick\<T, K>**
- **Omit\<T, K>**
- **Record\<K, T>**
- **Exclude\<T, U>**
- **Extract\<T, U>**

---

### üîπ 6. Modules

- **Export / Import**
- Default vs Named exports

---

### üîπ 7. Type Guards

- `typeof`
- `instanceof`
- Custom guards: `value is string`

---

### üîπ 8. Advanced Features

- **keyof**: keys of a type
- **typeof**: type of a variable
- **Mapped Types**: `[K in keyof T]`
- **Conditional Types**: `T extends U ? X : Y`
- **Infer**: extracting types from functions

---

### üîπ 9. Decorators (Experimental)

- **Class Decorators**
- **Method Decorators**
- **Property Decorators**

---

### üîπ 10. Best Practices

- Enable **strict mode** in `tsconfig.json`
- Prefer `unknown` over `any`
- Use `readonly` where possible
- Prefer `interface` for contracts, `type` for unions
- Avoid `!` non-null assertions unless necessary

---

  <img src="https://img.shields.io/badge/TypeScript-3178C6?logo=TypeScript&logoColor=FFF&style=for-the-badge" 
       alt="TypeScript Badge" width="300" height="80"/>


### üîπ Basics

#### Types

```ts
let isDone: boolean = true;
let age: number = 25;
let userName: string = 'Rev';
let notSure: any = 4; // Avoid 'any' if possible
let u: undefined = undefined;
let n: null = null;
```

#### Arrays & Tuples

```ts
let list: number[] = [1, 2, 3];
let list2: Array<string> = ['a', 'b', 'c'];

let tuple: [string, number];
tuple = ['hello', 10];
```

#### Enums

```ts
enum Direction {
  Up = 1,
  Down,
  Left,
  Right
}
let move: Direction = Direction.Up;
```

#### Type Aliases & Interfaces

```ts
type ID = string | number;

interface User {
  id: ID;
  name: string;
  age?: number; // optional
}

let user: User = { id: 1, name: 'Rev' };
```

#### Functions

```ts
function add(x: number, y: number): number {
  return x + y;
}

const multiply = (x: number, y: number): number => x * y;

function log(message: string): void {
  console.log(message);
}

function identity<T>(arg: T): T {
  return arg;
}
```

---

### üîπ Advanced Types

#### Union & Intersection

```ts
let value: string | number;

interface A {
  a: string;
}
interface B {
  b: number;
}
type C = A & B;
```

#### Type Narrowing

```ts
function printId(id: string | number) {
  if (typeof id === 'string') {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```

#### Literal Types

```ts
let direction: 'up' | 'down';
direction = 'up';
```

#### Type Assertions

```ts
let someValue: unknown = 'hello';
let strLength: number = (someValue as string).length;
```

#### Nullable & Non-Null Assertion

```ts
let x: string | null = null;
let y: string = x!; // non-null assertion
```

---

### üîπ Classes & OOP

```ts
class Person {
  private id: number;
  public name: string;
  protected age: number;

  constructor(id: number, name: string, age: number) {
    this.id = id;
    this.name = name;
    this.age = age;
  }

  greet(): string {
    return `Hello, my name is ${this.name}`;
  }
}

class Student extends Person {
  grade: number;

  constructor(id: number, name: string, age: number, grade: number) {
    super(id, name, age);
    this.grade = grade;
  }
}
```

#### Abstract Classes & Interfaces

```ts
abstract class Animal {
  abstract makeSound(): void;
  move(): void {
    console.log('Moving...');
  }
}

interface Flyable {
  fly(): void;
}
```

---

### üîπ Generics

```ts
function identity<T>(arg: T): T {
  return arg;
}

function loggingIdentity<T>(arg: T[]): T[] {
  console.log(arg.length);
  return arg;
}

interface GenericIdentityFn<T> {
  (arg: T): T;
}
```

---

### üîπ Utility Types

```ts
// ------------------ Interfaces Examples ------------------

interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

// Partial<T>: all optional
let todoPartial: Partial<Todo> = {
  title: "Learn TS"
};

// Readonly<T>: all readonly
let readonlyTodo: Readonly<Todo> = {
  title: "Learn TS",
  description: "Study utility types",
  completed: false,
};
// readonlyTodo.title = "New"; // ‚ùå Error

// Pick<T, K>: select specific keys
let picked: Pick<Todo, "title" | "completed"> = {
  title: "Task",
  completed: true,
};

// Omit<T, K>: remove specific keys
let omitted: Omit<Todo, "description"> = {
  title: "Task",
  completed: false,
};

// Record<K, T>: object with keys K and values T
type Roles = "admin" | "editor" | "viewer";
let perms: Record<Roles, boolean> = {
  admin: true,
  editor: false,
  viewer: true,
};

// Exclude<T, U>: remove matching union types
type Status = "success" | "error" | "loading";
type NotLoading = Exclude<Status, "loading">; // "success" | "error"
let status1: NotLoading = "success";
// let status2: NotLoading = "loading"; // ‚ùå Error

// Extract<T, U>: keep only matching union types
type OnlyLoading = Extract<Status, "loading" | "error">; // "loading" | "error"
let status3: OnlyLoading = "loading";
// let status4: OnlyLoading = "success"; // ‚ùå Error


// ------------------ Types Examples ------------------

type User = {
  id: number;
  name: string;
  email: string;
};

// Partial<T>
let userPartial: Partial<User> = {
  name: "Rev"
};

// Readonly<T>
let readonlyUser: Readonly<User> = {
  id: 1,
  name: "Rev",
  email: "rev@example.com"
};
// readonlyUser.id = 2; // ‚ùå Error

// Pick<T, K>
let userPicked: Pick<User, "id" | "name"> = {
  id: 99,
  name: "Boss",
};

// Omit<T, K>
let userOmitted: Omit<User, "email"> = {
  id: 7,
  name: "Ovi"
};

// Record<K, T>
type Languages = "en" | "de" | "fr";
let translations: Record<Languages, string> = {
  en: "Hello",
  de: "Hallo",
  fr: "Bonjour",
};

// Exclude<T, U>
type Fruit = "apple" | "banana" | "orange";
type Citrus = Exclude<Fruit, "banana">; // "apple" | "orange"
let fruit: Citrus = "apple";

// Extract<T, U>
type Animals = "dog" | "cat" | "fish";
type Pets = Extract<Animals, "dog" | "cat">; // "dog" | "cat"
let pet: Pets = "dog";
```

---

### üîπ Modules

```ts
// math.ts
export function add(a: number, b: number): number {
  return a + b;
}

// main.ts
import { add } from './math';
```

---

### üîπ Type Guards

```ts
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function example(value: string | number) {
  if (isString(value)) {
    console.log(value.toUpperCase());
  }
}
```

---

### üîπ Advanced Features

#### keyof & typeof

```ts
interface Person {
  name: string;
  age: number;
}

type PersonKeys = keyof Person; // "name" | "age"

const person = { name: 'Rev', age: 25 };
type PersonType = typeof person;
```

#### Mapped Types

```ts
type OptionsFlags<T> = {
  [Property in keyof T]: boolean;
};

interface Features {
  darkMode: () => void;
  newUserProfile: () => void;
}

type FeatureOptions = OptionsFlags<Features>;
```

#### Conditional Types

```ts
type IsString<T> = T extends string ? true : false;
type A = IsString<string>; // true
type B = IsString<number>; // false
```

#### Infer

```ts
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

function foo(x: number): string {
  return x.toString();
}

type FooReturn = ReturnType<typeof foo>; // string
```

---

### üîπ Decorators (Experimental)

```ts
function Logger(constructor: Function) {
  console.log('Logging...');
  console.log(constructor);
}

@Logger
class Car {
  constructor() {
    console.log('Car created');
  }
}
```

---

### Best Practices

- Prefer `unknown` over `any`.
- Use `readonly` for immutability.
- Avoid non-null assertions (`!`) unless necessary.
- Use `interface` for object contracts, `type` for unions and aliases.
- Enable `strict` mode in `tsconfig.json`.

---
