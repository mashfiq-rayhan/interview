# 12. Binary Search Trees

## üìã Chapter Overview

| Section  | Topic            | Key Idea                             |
| -------- | ---------------- | ------------------------------------ |
| **12.1** | BST basics       | Search property and structure        |
| **12.2** | Query operations | Search/min/max/successor/predecessor |
| **12.3** | Insert & delete  | Dynamic updates with BST property    |

---

## 12.1 Binary Search Tree (BST)

### Overview

A **binary search tree** is a binary tree that maintains the **BST property**: for each node, all keys in the left subtree are smaller and all keys in the right subtree are larger. This enables efficient dynamic set operations.

### Visual Example

```
       19
      /  \
    12    25
   /  \   /  \
  5   15 22  30
 / \      \
3   9      24
```

- Left of 19: all keys ‚â§ 19
- Right of 19: all keys ‚â• 19
- Left of 12: all keys ‚â§ 12
- Right of 12: all keys ‚â• 12

### Node Structure

Each node typically contains:

- `key` (value used for ordering)
- `left` pointer (left child)
- `right` pointer (right child)
- `parent` pointer (optional)
- Optional metadata: `size`, `height`, etc.

### BST Node Pseudocode

```
BST-Node:
    key
    left   // pointer to left child or NIL
    right  // pointer to right child or NIL
    p      // pointer to parent (optional)
```

### Why BSTs Are Powerful

| Operation                 | Complexity | Notes                            |
| ------------------------- | ---------- | -------------------------------- |
| **Search**                | O(h)       | Binary search-like comparison    |
| **Minimum/Maximum**       | O(h)       | Traverse to leftmost/rightmost   |
| **Successor/Predecessor** | O(h)       | Navigate via tree structure      |
| **Insert**                | O(h)       | Add as leaf maintaining property |
| **Delete**                | O(h)       | Handle 0/1/2 children cases      |

**Height Impact:**

- **Balanced tree:** h = O(log n) ‚Üí fast operations
- **Skewed tree:** h = O(n) ‚Üí slow operations (linked list behavior)

### TypeScript Implementation

```typescript
class TreeNode {
  key: number;
  left: TreeNode | null = null;
  right: TreeNode | null = null;
  parent: TreeNode | null = null;

  constructor(key: number) {
    this.key = key;
  }
}

class BinarySearchTree {
  root: TreeNode | null = null;

  insert(key: number): void {
    const newNode = new TreeNode(key);
    if (!this.root) {
      this.root = newNode;
      return;
    }
    let current: TreeNode | null = this.root;
    let parent: TreeNode | null = null;
    while (current !== null) {
      parent = current;
      current = key < current.key ? current.left : current.right;
    }
    if (key < parent!.key) parent!.left = newNode;
    else parent!.right = newNode;
    newNode.parent = parent;
  }

  inorder(node: TreeNode | null = this.root): void {
    if (!node) return;
    this.inorder(node.left);
    console.log(node.key);
    this.inorder(node.right);
  }
}

// Example Usage
const bst = new BinarySearchTree();
bst.insert(19);
bst.insert(12);
bst.insert(25);
bst.insert(5);
bst.insert(15);
bst.insert(22);
bst.insert(30);
console.log("Inorder (sorted):");
bst.inorder();
```

Output:

```
5
12
15
19
22
25
30
```

### Important Notes

- BSTs **can allow duplicates** (usually convention: go left or right).
- **Inorder traversal** produces keys in sorted order.
- Height (h) ranges from Œò(log n) (balanced) to Œò(n) (skewed).
- Balanced trees (e.g., Red-Black Trees) maintain h = O(log n).

### Key Takeaway

A BST maintains the search property: **left subtree ‚â§ node ‚â§ right subtree**, enabling dynamic set operations efficiently when reasonably balanced.

## 12.2 Querying a Binary Search Tree

### Overview

BST queries enable dynamic set operations using the tree structure. Five fundamental queries:

| Query           | Returns                      | Use Case           |
| --------------- | ---------------------------- | ------------------ |
| **Search**      | Node with given key (or NIL) | Membership testing |
| **Minimum**     | Node with smallest key       | Leftmost element   |
| **Maximum**     | Node with largest key        | Rightmost element  |
| **Successor**   | Next larger key than x       | Iterate in order   |
| **Predecessor** | Next smaller key than x      | Iterate in order   |

**Complexity:** All operations run in **O(h)** time

- Balanced BST ‚Üí h ‚âà log n ‚Üí **fast**
- Skewed BST ‚Üí h ‚âà n ‚Üí **slow** (like linked list)

---

### 1. Search (TREE-SEARCH)

Start at root, compare target key with current node:

- `equal` ‚Üí found
- `smaller` ‚Üí go left
- `larger` ‚Üí go right
- reach `NIL` ‚Üí not found

**Pseudocode (iterative ‚Äì most efficient in practice):**

```text
ITERATIVE-TREE-SEARCH(x, k)          // x = starting node (usually root)
    while x ‚â† NIL and k ‚â† x.key
        if k < x.key
            x ‚Üê x.left
        else
            x ‚Üê x.right
    return x                            // returns node or NIL
```

---

### 2. Minimum & Maximum

- **Minimum:** go left as far as possible
- **Maximum:** go right as far as possible

**Pseudocode:**

```text
TREE-MINIMUM(x)
    while x.left ‚â† NIL
        x ‚Üê x.left
    return x

TREE-MAXIMUM(x)
    while x.right ‚â† NIL
        x ‚Üê x.right
    return x
```

---

### 3. Successor (smallest key > x.key)

**Cases:**

1. If `x` has a right subtree ‚Üí successor = minimum in right subtree
2. Else ‚Üí walk up parents until finding ancestor `y` where `x` is in `y`'s left subtree

**Pseudocode (requires parent pointers):**

```text
TREE-SUCCESSOR(x)
    if x.right ‚â† NIL
        return TREE-MINIMUM(x.right)

    y ‚Üê x.p
    while y ‚â† NIL and x = y.right
        x ‚Üê y
        y ‚Üê y.p
    return y
```

- **Predecessor:** symmetric (mirror image)

---

### TypeScript Implementation

```ts
class TreeNode {
  key: number;
  left: TreeNode | null = null;
  right: TreeNode | null = null;
  parent: TreeNode | null = null;

  constructor(key: number) {
    this.key = key;
  }
}

class BinarySearchTree {
  root: TreeNode | null = null;

  insert(key: number): void {
    const node = new TreeNode(key);
    if (!this.root) {
      this.root = node;
      return;
    }

    let curr: TreeNode | null = this.root;
    let par: TreeNode | null = null;

    while (curr) {
      par = curr;
      curr = key < curr.key ? curr.left : curr.right;
    }

    node.parent = par;
    if (key < par!.key) par!.left = node;
    else par!.right = node;
  }

  search(key: number): TreeNode | null {
    let curr = this.root;
    while (curr && key !== curr.key) {
      curr = key < curr.key ? curr.left : curr.right;
    }
    return curr;
  }

  minimum(node: TreeNode | null = this.root): TreeNode | null {
    while (node && node.left) node = node.left;
    return node;
  }

  maximum(node: TreeNode | null = this.root): TreeNode | null {
    while (node && node.right) node = node.right;
    return node;
  }

  successor(node: TreeNode): TreeNode | null {
    if (node.right) return this.minimum(node.right);
    let y = node.parent;
    while (y && node === y.right) {
      node = y;
      y = y.parent;
    }
    return y;
  }

  predecessor(node: TreeNode): TreeNode | null {
    if (node.left) return this.maximum(node.left);
    let y = node.parent;
    while (y && node === y.left) {
      node = y;
      y = y.parent;
    }
    return y;
  }

  inorder(node: TreeNode | null = this.root): number[] {
    const res: number[] = [];
    if (!node) return res;
    res.push(...this.inorder(node.left));
    res.push(node.key);
    res.push(...this.inorder(node.right));
    return res;
  }
}

// ‚îÄ‚îÄ Demo ‚îÄ‚îÄ
const bst = new BinarySearchTree();
[19, 12, 25, 5, 15, 22, 30].forEach((k) => bst.insert(k));

console.log("Inorder (sorted):", bst.inorder());
console.log("Minimum:", bst.minimum()?.key); // 5
console.log("Maximum:", bst.maximum()?.key); // 30

const node15 = bst.search(15)!;
console.log("Successor of 15:", bst.successor(node15)?.key); // 19
console.log("Predecessor of 15:", bst.predecessor(node15)?.key); // 12

const node30 = bst.search(30)!;
console.log("Successor of 30:", bst.successor(node30)); // null
```

---

### Important Notes

- All operations are `O(h)` ‚Äî height-dependent
- Inorder traversal produces sorted keys
- Successor/predecessor require parent pointers (or extra traversal)
- Balanced tree ‚Üí `O(log n)` queries
- Skewed tree ‚Üí `O(n)` queries (like linked list)

**Key Takeaway:**
BST property enables efficient querying: `left subtree ‚â§ node ‚â§ right subtree` ‚Üí discard half the tree at each step.
All five queries are simple tree traversals taking `O(h)` time.

## 12.3 Insertion and Deletion

### Overview

Insertion and deletion are **core dynamic set operations** that modify the tree structure while preserving the BST property.

**Complexity:**

- **Balanced BST:** O(log n)
- **Skewed BST:** O(n)

---

### 1. Insertion (TREE-INSERT)

Walk down the tree like a search and attach the new node as a leaf.

**Pseudocode:**

```text
TREE-INSERT(T, z)                    // z = new node to insert
    y ‚Üê NIL                          // y will be parent of z
    x ‚Üê T.root
    while x ‚â† NIL
        y ‚Üê x
        if z.key < x.key
            x ‚Üê x.left
        else
            x ‚Üê x.right
    z.p ‚Üê y
    if y = NIL
        T.root ‚Üê z                   // tree was empty
    else if z.key < y.key
        y.left ‚Üê z
    else
        y.right ‚Üê z
```

---

### Deletion Cases

Deletion complexity depends on the number of children the node has:

| Case           | Description         | Action                                        |
| -------------- | ------------------- | --------------------------------------------- |
| **0 children** | Leaf node           | Remove directly                               |
| **1 child**    | One child only      | Replace node with child                       |
| **2 children** | Both children exist | Replace with successor, then delete successor |

**Key insight:** Nodes with 2 children are replaced by their **successor** (minimum in right subtree), which has at most 1 child.

**Pseudocode:**

```text
TREE-DELETE(T, z)                        // z = node to delete
    if z.left = NIL
        TRANSPLANT(T, z, z.right)
    else if z.right = NIL
        TRANSPLANT(T, z, z.left)
    else                                     // two children
        y ‚Üê TREE-MINIMUM(z.right)            // successor
        if y.p ‚â† z                           // successor not direct child
            TRANSPLANT(T, y, y.right)
            y.right ‚Üê z.right
            y.right.p ‚Üê y
        TRANSPLANT(T, z, y)
        y.left ‚Üê z.left
        y.left.p ‚Üê y
```

**Helper: TRANSPLANT**

```text
TRANSPLANT(T, u, v)
    if u.p = NIL
        T.root ‚Üê v
    else if u = u.p.left
        u.p.left ‚Üê v
    else
        u.p.right ‚Üê v
    if v ‚â† NIL
        v.p ‚Üê u.p
```

---

### TypeScript Implementation

```ts
class TreeNode {
  key: number;
  left: TreeNode | null = null;
  right: TreeNode | null = null;
  parent: TreeNode | null = null;

  constructor(key: number) {
    this.key = key;
  }
}

class BinarySearchTree {
  root: TreeNode | null = null;

  insert(key: number): void {
    const node = new TreeNode(key);
    if (!this.root) {
      this.root = node;
      return;
    }
    let curr: TreeNode | null = this.root;
    let par: TreeNode | null = null;
    while (curr) {
      par = curr;
      curr = key < curr.key ? curr.left : curr.right;
    }
    node.parent = par;
    if (key < par!.key) par!.left = node;
    else par!.right = node;
  }

  delete(key: number): boolean {
    const z = this.search(key);
    if (!z) return false;
    this.treeDelete(z);
    return true;
  }

  private treeDelete(z: TreeNode): void {
    if (!z.left) this.transplant(z, z.right);
    else if (!z.right) this.transplant(z, z.left);
    else {
      const y = this.minimum(z.right)!;
      if (y.parent !== z) {
        this.transplant(y, y.right);
        y.right = z.right!;
        y.right.parent = y;
      }
      this.transplant(z, y);
      y.left = z.left!;
      y.left.parent = y;
    }
  }

  private transplant(u: TreeNode, v: TreeNode | null): void {
    if (!u.parent) this.root = v;
    else if (u === u.parent.left) u.parent.left = v;
    else u.parent.right = v;
    if (v) v.parent = u.parent;
  }

  search(key: number): TreeNode | null {
    let curr = this.root;
    while (curr && key !== curr.key) {
      curr = key < curr.key ? curr.left : curr.right;
    }
    return curr;
  }

  minimum(node: TreeNode | null = this.root): TreeNode | null {
    while (node && node.left) node = node.left;
    return node;
  }

  inorder(node: TreeNode | null = this.root): number[] {
    if (!node) return [];
    return [...this.inorder(node.left), node.key, ...this.inorder(node.right)];
  }
}

// ‚îÄ‚îÄ Demo ‚îÄ‚îÄ
const bst = new BinarySearchTree();
[19, 12, 25, 5, 15, 22, 30, 8].forEach((k) => bst.insert(k));
console.log("Before deletion:", bst.inorder()); // [5, 8, 12, 15, 19, 22, 25, 30]
bst.delete(15);
console.log("After deleting 15:", bst.inorder()); // [5, 8, 12, 19, 22, 25, 30]
bst.delete(19);
console.log("After deleting root 19:", bst.inorder()); // [5, 8, 12, 22, 25, 30]
```

---

### Important Notes

- Insertion always adds a leaf ‚Äî simple
- Deletion is more complex with two children (successor replacement)
- All operations preserve BST property
- Time `O(h)` depends on tree height
- Requires parent pointers for efficient delete (optional but harder without)
- Balanced ‚Üí `O(log n)`, unbalanced ‚Üí `O(n)`

**Key Takeaway:**
Insertion adds a leaf in `O(h)` time; deletion handles 0, 1, 2 children with successor replacement ‚Äî core dynamic set operations on BSTs.
