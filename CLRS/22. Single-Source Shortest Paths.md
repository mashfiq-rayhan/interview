# 22. Single-Source Shortest Paths

## üìã Chapter Overview

| Section | Topic                               | Key Idea                                                              |
| ------- | ----------------------------------- | --------------------------------------------------------------------- |
| 22.1    | The Bellman-Ford Algorithm          | Relaxation-based approach handling negative edges and cycle detection |
| 22.2    | Shortest Paths in DAGs              | Topological order processing for O(V+E) complexity                    |
| 22.3    | Dijkstra's Algorithm                | Greedy approach for non-negative weights with O((V+E) log V)          |
| 22.4    | Difference Constraints              | Modeling constraint systems as shortest-path problems                 |
| 22.5    | Proofs of Shortest-Paths Properties | Formal correctness of shortest-path algorithms                        |

---

## 22.1 The Bellman-Ford Algorithm

### Purpose

The Bellman-Ford algorithm computes single-source shortest paths in a weighted directed graph, even when negative-weight edges are present (as long as there are no negative-weight cycles reachable from the source). Unlike Dijkstra‚Äôs algorithm (which requires non-negative weights), Bellman-Ford can handle negative weights and detect negative-weight cycles.

---

### Problem Definition

**Given:**

- Directed graph G = (V, E)
- Weight function w: E ‚Üí ‚Ñù (can be negative)
- Source vertex s ‚àà V

**Compute:**

- Shortest-path distances Œ¥(s, v) for all v ‚àà V
- Shortest-path predecessor œÄ[v] (to reconstruct paths)
- Detect if a negative-weight cycle is reachable from s

> If a negative cycle is reachable from s ‚Üí no shortest path exists to vertices reachable from that cycle.

---

### Core Idea ‚Äî Relaxation

Bellman-Ford is based on **edge relaxation**:

```text
RELAX(u, v, w)
if d[v] > d[u] + w(u, v):
    d[v] ‚Üê d[u] + w(u, v)
    œÄ[v] ‚Üê u
```

- Improves the distance estimate if a shorter path is found through edge (u,v).
- Relax all edges |V|‚àí1 times ‚Üí shortest path from s to any vertex has at most |V|‚àí1 edges (no cycles).
- After |V|‚àí1 iterations, distances are correct (if no negative cycle).
- One extra pass detects negative cycles: if any relaxation still improves ‚Üí negative cycle exists.

---

### Pseudocode

```text
BELLMAN-FORD(G, w, s):
    INITIALIZE-SINGLE-SOURCE(G, s)
    for i ‚Üê 1 to |V| ‚àí 1:
        for each edge (u, v) ‚àà G.E:
            RELAX(u, v, w)
    for each edge (u, v) ‚àà G.E:
        if v.d > u.d + w(u, v):
            return FALSE               // negative-weight cycle exists
    return TRUE

INITIALIZE-SINGLE-SOURCE(G, s):
    for each vertex v ‚àà G.V:
        v.d ‚Üê ‚àû
        v.œÄ ‚Üê NIL
    s.d ‚Üê 0
```

---

### TypeScript Implementation

```typescript
interface Edge {
  from: number;
  to: number;
  weight: number;
}
interface Graph {
  vertices: number[];
  edges: Edge[];
}
interface ShortestPathResult {
  distances: Map<number, number>;
  predecessors: Map<number, number | null>;
  hasNegativeCycle: boolean;
}

function bellmanFord(graph: Graph, source: number): ShortestPathResult {
  const distances = new Map<number, number>();
  const predecessors = new Map<number, number | null>();

  // Initialize
  for (const v of graph.vertices) {
    distances.set(v, Infinity);
    predecessors.set(v, null);
  }
  distances.set(source, 0);

  // Relax all edges |V|-1 times
  for (let i = 1; i < graph.vertices.length; i++) {
    for (const edge of graph.edges) {
      const u = edge.from,
        v = edge.to,
        w = edge.weight;
      if (distances.get(u)! + w < distances.get(v)!) {
        distances.set(v, distances.get(u)! + w);
        predecessors.set(v, u);
      }
    }
  }

  // Check for negative-weight cycles
  for (const edge of graph.edges) {
    const u = edge.from,
      v = edge.to,
      w = edge.weight;
    if (distances.get(u)! + w < distances.get(v)!) {
      return { distances, predecessors, hasNegativeCycle: true };
    }
  }

  return { distances, predecessors, hasNegativeCycle: false };
}
```

### Demo Example

```typescript
const graph: Graph = {
  vertices: [0, 1, 2, 3, 4],
  edges: [
    { from: 0, to: 1, weight: 6 },
    { from: 0, to: 2, weight: 7 },
    { from: 1, to: 2, weight: 5 },
    { from: 1, to: 3, weight: -4 },
    { from: 1, to: 4, weight: 8 },
    { from: 2, to: 3, weight: -2 },
    { from: 2, to: 4, weight: 9 },
    { from: 3, to: 4, weight: 7 },
  ],
};

const result = bellmanFord(graph, 0);
console.log("Shortest distances from 0:");
for (const [v, d] of result.distances)
  console.log(`To ${v}: ${d === Infinity ? "‚àû" : d}`);
console.log("\nPredecessors:");
for (const [v, p] of result.predecessors) console.log(`To ${v} from: ${p}`);
console.log("\nNegative cycle?", result.hasNegativeCycle);
```

---

### Important Notes

- Handles negative-weight edges (Dijkstra cannot)
- Detects negative-weight cycles reachable from source
- Time complexity: O(V √ó E) ‚Äî |V|‚àí1 iterations √ó |E| relaxations
- Slower than Dijkstra (O(E log V)) for non-negative weights, but more general
- Real-world use: network routing with possible negative costs, arbitrage detection in finance, etc.

> **Key Takeaway:** Bellman-Ford computes single-source shortest paths in graphs with negative-weight edges by relaxing all edges |V|‚àí1 times. It runs in O(V √ó E) and detects negative-weight cycles reachable from the source ‚Äî more general than Dijkstra's algorithm, though slower.

---

## 22.2 Single-Source Shortest Paths in Directed Acyclic Graphs

### Purpose

Efficient algorithm for computing single-source shortest paths in a DAG. Since DAGs have no cycles, vertices can be processed in **topological order**, guaranteeing all predecessors of a vertex are processed before it. This allows shortest paths to be computed in **O(V + E)**, faster than Bellman-Ford (O(VE)) or Dijkstra (O(E log V)).

---

### Key Property of DAGs

- Vertices can be ordered such that for every edge (u, v), u comes **before** v (topological sort).
- When processing vertex v, all incoming edges to v have already been relaxed.

---

### Algorithm ‚Äî DAG-Shortest-Paths

1. Compute a topological sort of the vertices.
2. Initialize distances: d[s] = 0, d[v] = ‚àû for v ‚â† s.
3. Process vertices in topological order.
4. For each vertex u, relax all outgoing edges from u.

### Pseudocode

```text
DAG-SHORTEST-PATHS(G, w, s):
    topologically sort the vertices of G
    INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex u in topological order:
        for each vertex v in G.Adj[u]:
            RELAX(u, v, w)
```

### Why It Works

- Topological order ensures d[u] is correct when u is processed.
- Relaxing edges from u updates neighbors correctly.
- No cycles ‚Üí no multiple passes or negative cycle checks needed.

---

### Time Complexity

- **Topological sort:** O(V + E)
- **Relaxation:** O(E) total (each edge relaxed once)
- **Overall:** O(V + E)

---

### TypeScript Implementation

```typescript
interface Edge {
  from: number;
  to: number;
  weight: number;
}
interface Graph {
  vertices: number[];
  adj: Map<number, number[]>; // adjacency list
  edges: Edge[]; // all edges with weights
}

function dagShortestPaths(graph: Graph, source: number) {
  const distances = new Map<number, number>();
  const predecessors = new Map<number, number | null>();
  const visited = new Set<number>();
  const topoOrder: number[] = [];

  // Step 1: Topological sort using DFS
  function dfsVisit(u: number) {
    visited.add(u);
    for (const v of graph.adj.get(u) || []) {
      if (!visited.has(v)) dfsVisit(v);
    }
    topoOrder.push(u);
  }

  for (const u of graph.vertices) if (!visited.has(u)) dfsVisit(u);
  topoOrder.reverse();

  // Step 2: Initialize distances
  for (const v of graph.vertices) {
    distances.set(v, Infinity);
    predecessors.set(v, null);
  }
  distances.set(source, 0);

  // Step 3: Relax edges in topological order
  for (const u of topoOrder) {
    if (distances.get(u) === Infinity) continue;
    for (const v of graph.adj.get(u) || []) {
      const edge = graph.edges.find((e) => e.from === u && e.to === v);
      if (!edge) continue;
      const newDist = distances.get(u)! + edge.weight;
      if (newDist < distances.get(v)!) {
        distances.set(v, newDist);
        predecessors.set(v, u);
      }
    }
  }

  return { distances, predecessors };
}
```

### Demo Example

```typescript
const dag: Graph = {
  vertices: [0, 1, 2, 3, 4],
  adj: new Map([
    [0, [1, 2]],
    [1, [3]],
    [2, [3, 4]],
    [3, [4]],
    [4, []],
  ]),
  edges: [
    { from: 0, to: 1, weight: 5 },
    { from: 0, to: 2, weight: 3 },
    { from: 1, to: 3, weight: 6 },
    { from: 2, to: 3, weight: 2 },
    { from: 2, to: 4, weight: 4 },
    { from: 3, to: 4, weight: 1 },
  ],
};

const result = dagShortestPaths(dag, 0);
console.log("Shortest distances from 0:");
for (const [v, d] of result.distances) console.log(`To ${v}: ${d}`);
console.log("\nPredecessors:");
for (const [v, p] of result.predecessors) console.log(`To ${v} from: ${p}`);
```

---

### Important Notes

- Requires topological order ‚Üí only works on DAGs (no cycles)
- Handles negative-weight edges (no negative cycles)
- Time: O(V + E) ‚Äî faster than Bellman-Ford O(VE)
- No negative cycle detection needed
- Applications: critical-path scheduling, compiler optimization, etc.

> **Key Takeaway:** In a DAG, single-source shortest paths can be computed in **O(V + E)** by processing vertices in topological order and relaxing outgoing edges. Faster and simpler than Bellman-Ford, works even with negative weights.

---

## 22.3 Dijkstra's Algorithm

### Purpose

Dijkstra‚Äôs algorithm computes single-source shortest paths from a source vertex s to all vertices in a weighted directed or undirected graph with **non-negative edge weights**. It is a **greedy algorithm** that grows the set of vertices whose shortest-path distance from s is known, always choosing the vertex with the smallest current distance estimate.

---

**Core Idea ‚Äî Greedy Choice:**

- Maintain:
  - Set S of vertices whose shortest distance from s is finalized.
  - Priority queue Q of vertices not yet in S, keyed by current distance estimate d[v].

- At each step:
  1. Extract vertex u ‚àà Q with the smallest d[u].
  2. Add u to S (d[u] is now final).
  3. Relax all edges leaving u ‚Üí update neighbors v if a shorter path is found.

> Non-negative weights ensure that once a vertex is extracted, its distance is correct.

---

### Pseudocode (Binary Min-Heap)

```text
DIJKSTRA(G, w, s):
    INITIALIZE-SINGLE-SOURCE(G, s)
    let Q be a min-priority queue keyed by v.d
    while Q ‚â† ‚àÖ:
        u ‚Üê EXTRACT-MIN(Q)
        for each vertex v in G.Adj[u]:
            RELAX(u, v, w)

RELAX(u, v, w):
    if v.d > u.d + w(u, v):
        v.d ‚Üê u.d + w(u, v)
        v.œÄ ‚Üê u
        DECREASE-KEY(Q, v, v.d)
```

---

### TypeScript Implementation

```typescript
interface Edge {
  to: number;
  weight: number;
}
interface Graph {
  vertices: number[];
  adj: Map<number, Edge[]>;
}

function dijkstra(graph: Graph, source: number) {
  const distances = new Map<number, number>();
  const predecessors = new Map<number, number | null>();
  const visited = new Set<number>();
  const pq: [number, number][] = [];
  const pqMap = new Map<number, number>();

  // Initialize
  for (const v of graph.vertices) {
    distances.set(v, Infinity);
    predecessors.set(v, null);
  }
  distances.set(source, 0);
  pq.push([0, source]);
  pqMap.set(source, 0);

  while (pq.length > 0) {
    pq.sort((a, b) => a[0] - b[0]);
    const [distU, u] = pq.shift()!;
    pqMap.delete(u);
    if (visited.has(u)) continue;
    visited.add(u);

    for (const edge of graph.adj.get(u) || []) {
      const v = edge.to,
        w = edge.weight;
      if (visited.has(v)) continue;
      const newDist = distances.get(u)! + w;
      if (newDist < distances.get(v)!) {
        distances.set(v, newDist);
        predecessors.set(v, u);
        pq.push([newDist, v]);
        pqMap.set(v, pq.length - 1);
      }
    }
  }

  return { distances, predecessors };
}
```

---

### Demo Example

```typescript
const graph: Graph = {
  vertices: [0, 1, 2, 3, 4],
  adj: new Map([
    [
      0,
      [
        { to: 1, weight: 4 },
        { to: 2, weight: 8 },
      ],
    ],
    [
      1,
      [
        { to: 2, weight: 2 },
        { to: 3, weight: 6 },
      ],
    ],
    [
      2,
      [
        { to: 3, weight: 1 },
        { to: 4, weight: 5 },
      ],
    ],
    [3, [{ to: 4, weight: 2 }]],
    [4, []],
  ]),
};

const result = dijkstra(graph, 0);
console.log("Shortest distances from 0:");
for (const [v, d] of result.distances) console.log(`To ${v}: ${d}`);
console.log("\nPredecessors:");
for (const [v, p] of result.predecessors) console.log(`To ${v} from: ${p}`);
```

---

### Important Notes

- Requires **non-negative edge weights** (otherwise use Bellman-Ford)
- **Time Complexity:** O((V + E) log V) with binary heap
  - Theoretical best: O(E + V log V) with Fibonacci heap
- Greedy choice ensures distances are non-decreasing and finalized when extracted
- Real-world applications: GPS navigation, network routing, robotics path planning

> **Key Takeaway:** Dijkstra's algorithm is a greedy method for single-source shortest paths with non-negative weights. It grows the set of finalized vertices by selecting the closest unvisited vertex and relaxing outgoing edges, achieving O((V + E) log V) with a binary heap.

---

## 22.4 Difference Constraints and Shortest Paths

### Purpose

Shows the connection between **systems of difference constraints** (linear inequalities of the form x_j - x_i ‚â§ c_k) and shortest-path problems in graphs. Many real-world problems (scheduling, resource allocation) can be modeled this way.

---

### Key Insight

A system of difference constraints has a solution **if and only if** the corresponding constraint graph has **no negative-weight cycle**.

---

### Constraint Graph Construction

**For m inequalities x_j - x_i ‚â§ c_k:**

- Create a vertex v_i for each variable x_i (|V| = n)
- For each inequality, add a directed edge i ‚Üí j with weight c_k

> **Theorem:** System has a solution ‚áî no negative-weight cycle in G.

**If no negative cycle exists:**

1. Add a **dummy source vertex s**
2. Connect s ‚Üí v_i with edges of weight 0 for all i
3. Run **Bellman-Ford** from s
4. Shortest-path distances Œ¥(s, v_i) give feasible solution: x_i = Œ¥(s, v_i)

---

### Why It Works

**For edge i ‚Üí j with weight c_k:**

```text
Œ¥(s, v_j) ‚â§ Œ¥(s, v_i) + w(i,j) = Œ¥(s, v_i) + c_k
‚Üí x_j ‚â§ x_i + c_k
‚Üí x_j - x_i ‚â§ c_k
```

- Shortest-path distances automatically satisfy all difference constraints.

---

### Solving Difference Constraints with Bellman-Ford

**Steps:**

1. Create constraint graph G with vertices v_1 ‚Ä¶ v_n
2. Add edges i ‚Üí j for each constraint x_j - x_i ‚â§ c_k
3. Add dummy source s ‚Üí v_i with weight 0
4. Run Bellman-Ford from s
5. If negative cycle detected ‚Üí no solution, else x_i = Œ¥(s, v_i)

**Time Complexity:** O(n m) where m = number of constraints

---

### TypeScript Implementation

```typescript
interface Constraint {
  i: number;
  j: number;
  c: number;
}

function solveDifferenceConstraints(n: number, constraints: Constraint[]) {
  const V = n + 1; // dummy source
  const source = n;
  const adj: { to: number; weight: number }[][] = Array(V)
    .fill(0)
    .map(() => []);

  // Dummy edges from source
  for (let i = 0; i < n; i++) adj[source].push({ to: i, weight: 0 });

  // Constraint edges
  for (const c of constraints) adj[c.i].push({ to: c.j, weight: c.c });

  const dist = new Array(V).fill(Infinity);
  dist[source] = 0;

  // Relax |V|-1 times
  for (let iter = 0; iter < V - 1; iter++) {
    for (let u = 0; u < V; u++) {
      if (dist[u] === Infinity) continue;
      for (const edge of adj[u]) {
        const v = edge.to,
          w = edge.weight;
        if (dist[u] + w < dist[v]) dist[v] = dist[u] + w;
      }
    }
  }

  // Check negative cycle
  let hasNegativeCycle = false;
  for (let u = 0; u < V; u++) {
    if (dist[u] === Infinity) continue;
    for (const edge of adj[u]) {
      const v = edge.to,
        w = edge.weight;
      if (dist[u] + w < dist[v]) {
        hasNegativeCycle = true;
        break;
      }
    }
    if (hasNegativeCycle) break;
  }

  if (hasNegativeCycle) return { solution: null, hasSolution: false };
  return { solution: dist.slice(0, n), hasSolution: true };
}
```

---

### Example

```typescript
const constraints = [
  { i: 1, j: 2, c: 3 },
  { i: 1, j: 3, c: 5 },
  { i: 3, j: 1, c: -2 },
  { i: 2, j: 4, c: 1 },
  { i: 3, j: 4, c: 2 },
];
const n = 4;
const result = solveDifferenceConstraints(n, constraints);

if (result.hasSolution) {
  console.log("Solution exists:");
  result.solution!.forEach((val, i) => console.log(`x${i + 1} = ${val}`));
} else console.log("No solution (negative cycle exists)");
```

---

### Important Notes

- Difference constraints occur in scheduling, resource allocation, etc.
- Reduction to shortest paths lets us use Bellman-Ford efficiently
- Negative cycle ‚Üí no feasible solution
- Time: O(n m) with Bellman-Ford
- Can be faster with specialized algorithms for sparse graphs

> **Key Takeaway:** Systems of difference constraints can be solved by constructing a constraint graph and finding shortest paths from a dummy source. Negative cycle detection indicates no solution; otherwise, shortest-path distances provide feasible variable values.

---

## 22.5 Proofs of Shortest-Paths Properties

### Overview

This section presents formal proofs of key properties that justify correctness of algorithms like **Bellman-Ford, Dijkstra, and DAG-shortest-paths**. Properties rely on **upper-bound property, no-path property, convergence property, path-relaxation property,** and the **triangle inequality**.

---

### Upper-Bound Property

**Theorem:** For any vertex v, the current estimate d[v] ‚â• Œ¥(s, v)

**Proof (Induction on relaxations):**

- **Base:** After initialization, d[v] = ‚àû for v ‚â† s, d[s] = 0 ‚Üí holds
- **Inductive:** Assume d[v] ‚â• Œ¥(s,v) before relaxing (u,v)
  - If d[v] ‚â§ d[u]+w(u,v) ‚Üí no change ‚Üí holds
  - If d[v] > d[u]+w(u,v) ‚Üí d[v] ‚Üê d[u]+w(u,v)
    - By induction: d[u] ‚â• Œ¥(s,u)
    - Triangle inequality: d[u]+w(u,v) ‚â• Œ¥(s,v)
    - ‚Üí Upper-bound property holds after every relaxation

---

### No-Path Property

**Corollary:** If no path from s to v, then d[v] = ‚àû after every relaxation

**Proof:** Œ¥(s,v) = ‚àû, upper-bound property ‚Üí d[v] ‚â• ‚àû ‚Üí d[v] = ‚àû

---

### Convergence Property

**Theorem:** For shortest path s ‚Üí ... ‚Üí u ‚Üí v, if all edges on s‚Üíu have been relaxed, relaxing (u,v) sets d[v] = Œ¥(s,v)

**Proof:**

- Before relaxing: d[u] = Œ¥(s,u)
- Relaxing (u,v): d[v] ‚â§ d[u]+w(u,v) = Œ¥(s,v)
- Upper-bound: d[v] ‚â• Œ¥(s,v)
- ‚Üí d[v] = Œ¥(s,v), remains final

---

### Path-Relaxation Property

**Theorem:** Relaxing edges along a shortest path (v‚ÇÄ=s ‚Üí v‚ÇÅ ‚Üí ... ‚Üí v‚Çñ=v) in order ensures d[v‚Çñ] = Œ¥(s,v‚Çñ)

**Proof (Induction on path edges):**

- **Base:** 0 edges ‚Üí d[s] = Œ¥(s,s)
- **Inductive:** assume d[v_{k-1}] = Œ¥(s,v\_{k-1})
  - Relax (v*{k-1},v_k): d[v_k] ‚â§ d[v*{k-1}]+w = Œ¥(s,v_k)
  - Upper-bound: d[v_k] ‚â• Œ¥(s,v_k) ‚Üí d[v_k] = Œ¥(s,v_k)

---

### Correctness of Bellman-Ford

**Theorem:** After |V|-1 iterations of relaxing all edges, d[v] = Œ¥(s,v) for all reachable v (if no negative cycle)

**Proof:**

- Any shortest path ‚â§ |V|-1 edges
- Path-relaxation property ensures all shortest paths relaxed ‚Üí d[v] correct

**Negative Cycle Detection:** One extra pass ‚Üí if any distance improves ‚Üí negative cycle exists

---

### TypeScript Implementation

```typescript
interface Edge {
  from: number;
  to: number;
  weight: number;
}
interface Graph {
  vertices: number[];
  edges: Edge[];
}

function bellmanFord(graph: Graph, source: number) {
  const distances = new Map<number, number>();
  const predecessors = new Map<number, number | null>();

  // Initialization (upper-bound property)
  for (const v of graph.vertices) {
    distances.set(v, Infinity);
    predecessors.set(v, null);
  }
  distances.set(source, 0);

  // |V|-1 passes of edge relaxation (path-relaxation property)
  for (let i = 0; i < graph.vertices.length - 1; i++) {
    for (const edge of graph.edges) {
      const u = edge.from,
        v = edge.to,
        w = edge.weight;
      if (
        distances.get(u)! !== Infinity &&
        distances.get(u)! + w < distances.get(v)!
      ) {
        distances.set(v, distances.get(u)! + w);
        predecessors.set(v, u);
      }
    }
  }

  // Check negative cycle (extra pass)
  let hasNegativeCycle = false;
  for (const edge of graph.edges) {
    const u = edge.from,
      v = edge.to,
      w = edge.weight;
    if (
      distances.get(u)! !== Infinity &&
      distances.get(u)! + w < distances.get(v)!
    ) {
      hasNegativeCycle = true;
      break;
    }
  }

  return { distances, predecessors, hasNegativeCycle };
}
```

---

### Important Notes

- Upper-bound property underlies all other properties
- Convergence: shortest-path edges once relaxed are final
- Path-relaxation: explains why |V|-1 passes suffice
- Negative cycle detection: any improvement after |V|-1 passes ‚Üí cycle exists

> **Key Takeaway:** Bellman-Ford correctness rests on: (1) Upper-bound property: d[v] ‚â• Œ¥(s,v); (2) No-path property: unreachable vertices stay ‚àû; (3) Convergence property: relaxing an edge finalizes its distance; (4) Path-relaxation property: relaxing edges along shortest path ‚Üí correct distance. Together: |V|-1 passes relax all edges on shortest paths ‚Üí compute correct shortest paths (if no negative cycle).
