# 25. Matchings in Bipartite Graphs

---

## ðŸ“‹ Chapter Overview

| Section | Topic                                  | Key Idea                              |
| ------- | -------------------------------------- | ------------------------------------- |
| 25.1    | Maximum Bipartite Matching (Revisited) | Reduce matching to max flow           |
| 25.2    | The Stable-Marriage Problem            | Galeâ€“Shapley deferred acceptance      |
| 25.3    | The Hungarian Algorithm                | Min-cost perfect matching in $O(n^3)$ |

---

## 25.1 Maximum Bipartite Matching (Revisited)

### Overview

This section revisits maximum bipartite matching using flow networks from Chapter 24. It is a clean application of augmenting paths and the max-flow min-cut theorem.

### Core Idea

Given a bipartite graph $G = (L \cup R, E)$ with parts $L$ and $R$:

- Add a source $s$ connected to every vertex in $L$ with capacity 1
- Add a sink $t$ connected from every vertex in $R$ with capacity 1
- For every original edge $u \in L \to v \in R$, add edge $u \to v$ with capacity 1

Compute the maximum flow in this network. Then:

- **Flow value** $|f|$ equals the size of the maximum matching
- Edges $(u, v)$ with $f(u, v) = 1$ form a maximum matching

### Why It Works

- Each unit of flow corresponds to one matched edge
- Capacity 1 from $s \to L$ and $R \to t$ enforces at most one match per vertex
- Integer capacities imply integer flows (integrality theorem)

---

### Pseudocode

**Construct Flow Network**

```text
BUILD-BIPARTITE-MATCHING-FLOW-NETWORK(G = (L âˆª R, E), s, t)
    create flow network N with vertices {s, t} âˆª L âˆª R
    for each u âˆˆ L:
        add edge s â†’ u with capacity 1
    for each v âˆˆ R:
        add edge v â†’ t with capacity 1
    for each edge (u, v) âˆˆ E (u âˆˆ L, v âˆˆ R):
        add edge u â†’ v with capacity 1
    return N
```

**Find Maximum Matching**

```text
MAXIMUM-BIPARTITE-MATCHING(G = (L âˆª R, E))
    N â† BUILD-BIPARTITE-MATCHING-FLOW-NETWORK(G, s, t)
    compute maximum flow f in N using any max-flow algorithm
    M â† empty set
    for each original edge (u, v) âˆˆ E:
        if f(u, v) = 1:
            add (u, v) to M
    return M (and optionally |f| as matching size)
```

---

### TypeScript Implementation (Edmondsâ€“Karp Style)

```typescript
class BipartiteMatcher {
  private leftSize: number;
  private rightSize: number;
  private source: number;
  private sink: number;
  private capacity: number[][];
  private flow: number[][];

  constructor(left: number, right: number) {
    this.leftSize = left;
    this.rightSize = right;
    this.source = left + right;
    this.sink = left + right + 1;

    const total = left + right + 2;
    this.capacity = Array(total)
      .fill(0)
      .map(() => Array(total).fill(0));
    this.flow = Array(total)
      .fill(0)
      .map(() => Array(total).fill(0));

    for (let u = 0; u < left; u++) {
      this.capacity[this.source][u] = 1;
    }

    for (let v = left; v < left + right; v++) {
      this.capacity[v][this.sink] = 1;
    }
  }

  addEdge(leftIdx: number, rightIdx: number): void {
    const v = this.leftSize + rightIdx;
    this.capacity[leftIdx][v] = 1;
  }

  private bfs(parent: number[]): boolean {
    const visited = new Array(this.capacity.length).fill(false);
    const queue: number[] = [];

    queue.push(this.source);
    visited[this.source] = true;
    parent[this.source] = -1;

    while (queue.length > 0) {
      const u = queue.shift()!;

      for (let v = 0; v < this.capacity.length; v++) {
        const residual =
          this.capacity[u][v] - this.flow[u][v] + this.flow[v][u];
        if (!visited[v] && residual > 0) {
          queue.push(v);
          parent[v] = u;
          visited[v] = true;
          if (v === this.sink) return true;
        }
      }
    }
    return false;
  }

  computeMaxMatching(): { size: number; matching: [number, number][] } {
    const parent = new Array(this.capacity.length).fill(-1);
    let maxFlow = 0;

    while (this.bfs(parent)) {
      let pathFlow = Infinity;
      for (let v = this.sink; v !== this.source; v = parent[v]) {
        const u = parent[v];
        const forward = this.capacity[u][v] - this.flow[u][v];
        const backward = this.flow[v][u];
        pathFlow = Math.min(pathFlow, forward + backward);
      }

      for (let v = this.sink; v !== this.source; v = parent[v]) {
        const u = parent[v];
        if (this.capacity[u][v] > 0) {
          this.flow[u][v] += pathFlow;
          this.flow[v][u] -= pathFlow;
        } else {
          this.flow[v][u] += pathFlow;
          this.flow[u][v] -= pathFlow;
        }
      }

      maxFlow += pathFlow;
    }

    const matching: [number, number][] = [];
    for (let u = 0; u < this.leftSize; u++) {
      for (let v = this.leftSize; v < this.leftSize + this.rightSize; v++) {
        if (this.flow[u][v] === 1) {
          matching.push([u, v - this.leftSize]);
        }
      }
    }

    return { size: maxFlow, matching };
  }
}
```

### Demo Example

```typescript
// Left: 0=A, 1=B, 2=C    Right: 0=X, 1=Y, 2=Z, 3=W
const matcher = new BipartiteMatcher(3, 4);

matcher.addEdge(0, 0); // A-X
matcher.addEdge(0, 1); // A-Y
matcher.addEdge(1, 1); // B-Y
matcher.addEdge(1, 2); // B-Z
matcher.addEdge(2, 2); // C-Z
matcher.addEdge(2, 3); // C-W

const result = matcher.computeMaxMatching();

console.log("Maximum matching size:", result.size); // 3
console.log("Matching pairs (left â†’ right):", result.matching);
```

### Important Notes

- All capacities are 1, which makes the structure simple
- The flow value equals the maximum matching size
- Running time depends on the chosen max-flow algorithm
  - Edmondsâ€“Karp: $O(VE^2)$
  - Dinic: faster in practice
- This gives **cardinality** matching (unweighted)

> **Key Takeaway:** Maximum bipartite matching is elegantly solved by reducing to max flow. The flow value equals the matching size, and unit-flow edges yield the matching itself.

---

## 25.2 The Stable-Marriage Problem

### Overview

The stable-marriage problem pairs two equal-sized sets such that no pair prefers each other over their assigned partners. The Galeâ€“Shapley algorithm finds a stable matching efficiently.

### Problem Definition

- Two sets of size $n$: men $\{m_1, \dots, m_n\}$ and women $\{w_1, \dots, w_n\}$
- Each person has a strict preference ordering
- A matching is **stable** if it has no **blocking pair**

### Galeâ€“Shapley (Deferred Acceptance)

There are two variants:

- **Man-proposing:** yields man-optimal stable matching
- **Woman-proposing:** yields woman-optimal stable matching

---

### Pseudocode (Man-Proposing)

```text
STABLE-MARRIAGE(Men, Women, menPref, womenPref)
    matching â† empty dictionary
    freeMen â† list of all men
    for each man m: proposalIndex[m] â† 0

    while freeMen is not empty
        m â† take any free man from freeMen
        w â† menPref[m][proposalIndex[m]]
        proposalIndex[m] â† proposalIndex[m] + 1

        if w is not matched
            match m and w
            remove m from freeMen
        else
            m' â† current partner of w
            if w prefers m over m'
                disengage m' and w
                match m and w
                add m' to freeMen
            // else: w rejects m

    return matching
```

---

### TypeScript Implementation

```typescript
function galeShapley(menPrefs: number[][], womenPrefs: number[][]): number[] {
  const n = menPrefs.length;
  const partnerW: number[] = new Array(n).fill(-1);
  const partnerM: number[] = new Array(n).fill(-1);
  const nextProposal: number[] = new Array(n).fill(0);

  const womenRank: number[][] = womenPrefs.map((pref) => {
    const rank = new Array(n).fill(0);
    pref.forEach((man, i) => {
      rank[man] = i;
    });
    return rank;
  });

  let freeMenCount = n;

  while (freeMenCount > 0) {
    let m = -1;
    for (let i = 0; i < n; i++) {
      if (partnerM[i] === -1) {
        m = i;
        break;
      }
    }
    if (m === -1) break;

    const w = menPrefs[m][nextProposal[m]];
    nextProposal[m]++;

    if (partnerW[w] === -1) {
      partnerW[w] = m;
      partnerM[m] = w;
      freeMenCount--;
    } else {
      const current = partnerW[w];
      if (womenRank[w][m] < womenRank[w][current]) {
        partnerW[w] = m;
        partnerM[m] = w;
        partnerM[current] = -1;
      }
    }
  }

  return partnerM; // partnerM[m] = woman matched to man m
}
```

### Demo Example

```typescript
// 0=A, 1=B, 2=C   men
// 0=X, 1=Y, 2=Z   women

const menPrefs = [
  [1, 0, 2], // A prefers Y > X > Z
  [0, 2, 1], // B prefers X > Z > Y
  [0, 1, 2], // C prefers X > Y > Z
];

const womenPrefs = [
  [1, 0, 2], // X prefers B > A > C
  [0, 2, 1], // Y prefers A > C > B
  [2, 0, 1], // Z prefers C > A > B
];

const matching = galeShapley(menPrefs, womenPrefs);

console.log("Man-optimal stable matching (man â†’ woman):");
matching.forEach((woman, man) => {
  console.log(`${man} â†’ ${woman}`);
});
```

### Important Notes

- Always terminates and produces a stable matching
- Runs in $O(n^2)$ time
- Man-proposing is man-optimal; woman-proposing is woman-optimal
- Strategy-proof for the proposing side (not for the receiving side)
- Widely used in practice (NRMP, school choice, etc.)

> **Key Takeaway:** Galeâ€“Shapley finds a stable matching in $O(n^2)$ time. The proposing side gets its best possible stable partners, making the algorithm both elegant and practical.

---

## 25.3 The Hungarian Algorithm for the Assignment Problem

### Overview

The assignment problem asks for a minimum-cost perfect matching in a complete bipartite graph. The Hungarian algorithm solves it in $O(n^3)$ time using a primalâ€“dual approach.

### Core Idea

Maintain:

- **Dual potentials** for rows and columns
- A **partial matching** in the equality graph (edges with zero reduced cost)

Reduced cost:
$$\bar{c}(i, j) = c(i, j) - u_i - v_j$$

The algorithm alternates between finding augmenting paths in the equality subgraph and updating dual variables to create new zero-cost edges.

---

### Pseudocode (High-Level)

```text
HUNGARIAN-ALGORITHM(cost matrix C[1..n][1..n])
    initialize dual variables:
        u[1..n] â† 0
        v[1..n] â† 0
        matching â† empty

    while matching is not perfect
        build equality subgraph Gâ‚€:
            include edge (i, j) if c(i, j) - u[i] - v[j] = 0

        try to find maximum matching M in Gâ‚€ using augmenting paths

        if |M| = n:
            return M
        else:
            let S = set of rows reachable from free rows
            let T = set of columns reachable

            let Î´ = min { c(i, j) - u[i] - v[j] | i âˆˆ S, j âˆ‰ T }

            update duals:
                for i âˆˆ S: u[i] â† u[i] + Î´
                for j âˆˆ T: v[j] â† v[j] - Î´
```

---

### TypeScript Implementation (Simplified)

```typescript
function hungarianAlgorithm(cost: number[][]): {
  assignment: number[];
  totalCost: number;
} {
  const n = cost.length;

  const rowReduced = cost.map((row) => {
    const min = Math.min(...row);
    return row.map((val) => val - min);
  });

  const matrix = rowReduced.map((row, i) => {
    const colMins = Array(n).fill(Infinity);
    for (let j = 0; j < n; j++) {
      colMins[j] = Math.min(colMins[j], rowReduced[i][j]);
    }
    return row.map((val, j) => val - colMins[j]);
  });

  const u = new Array(n).fill(0);
  const v = new Array(n).fill(0);
  const assignment: number[] = new Array(n).fill(-1);

  for (let root = 0; root < n; root++) {
    const visitedRow = new Array(n).fill(false);
    const visitedCol = new Array(n).fill(false);
    const parentCol = new Array(n).fill(-1);

    let found = false;
    const queue: number[] = [root];
    visitedRow[root] = true;

    while (queue.length > 0 && !found) {
      const r = queue.shift()!;

      for (let c = 0; c < n; c++) {
        if (!visitedCol[c] && matrix[r][c] - u[r] - v[c] === 0) {
          if (assignment[c] === -1) {
            found = true;
            parentCol[c] = r;
            break;
          } else {
            const nextRow = assignment[c];
            if (!visitedRow[nextRow]) {
              visitedRow[nextRow] = true;
              parentCol[c] = r;
              queue.push(nextRow);
            }
          }
          visitedCol[c] = true;
        }
      }
    }

    if (!found) {
      let delta = Infinity;
      for (let r = 0; r < n; r++) {
        if (visitedRow[r]) {
          for (let c = 0; c < n; c++) {
            if (!visitedCol[c]) {
              delta = Math.min(delta, matrix[r][c] - u[r] - v[c]);
            }
          }
        }
      }

      for (let r = 0; r < n; r++) if (visitedRow[r]) u[r] += delta;
      for (let c = 0; c < n; c++) if (visitedCol[c]) v[c] -= delta;

      root--;
      continue;
    }

    let col = -1;
    for (let c = 0; c < n; c++) {
      if (parentCol[c] !== -1 && assignment[c] === -1) {
        col = c;
        break;
      }
    }

    while (col !== -1) {
      const row = parentCol[col];
      assignment[col] = row;
      const prevCol = assignment.indexOf(row);
      col = prevCol !== -1 ? prevCol : -1;
    }
  }

  let totalCost = 0;
  for (let j = 0; j < n; j++) {
    const i = assignment[j];
    totalCost += cost[i][j];
  }

  return { assignment, totalCost };
}
```

### Demo Example

```typescript
const costMatrix = [
  [9, 2, 7, 8],
  [6, 4, 3, 7],
  [5, 8, 1, 8],
  [7, 6, 9, 4],
];

const result = hungarianAlgorithm(costMatrix);

console.log("Assignment (column â†’ row):", result.assignment);
console.log("Total minimum cost:", result.totalCost);
```

### Important Notes

- Solves minimum-cost perfect matching
- Runs in $O(n^3)$ time in standard implementations
- Works with real-valued costs
- Requires a square matrix (pad with dummy rows/cols if needed)
- For maximum-weight assignment, negate costs and run again

> **Key Takeaway:** The Hungarian algorithm is a primalâ€“dual method that finds a minimum-cost perfect matching in $O(n^3)$ time by iteratively expanding the equality subgraph and updating dual variables.

---

## Chapter 25 Summary

- **Bipartite matching (25.1):** reduce to max flow and read matching from unit flows
- **Stable marriage (25.2):** Galeâ€“Shapley guarantees stability in $O(n^2)$
- **Assignment problem (25.3):** Hungarian algorithm finds a min-cost perfect matching in $O(n^3)$25.1 Maximum bipartite matching (revisited)
  (Introduction to Algorithms, 4th Edition â€“ CLRS)
  This section revisits the maximum bipartite matching problem â€” now viewed through the lens of flow networks â€” and shows how the maximum-flow algorithms developed in Chapter 24 directly solve it.
  It serves as a clean, important application example that ties together flow networks, augmenting paths, and the max-flow min-cut theorem.
  Core Idea
  Given a bipartite graph G = (L âˆª R, E) with parts L (left) and R (right):

Construct a flow network as follows:
Add a source s connected to every vertex in L with capacity 1
Add a sink t connected from every vertex in R with capacity 1
For every original edge u âˆˆ L â†’ v âˆˆ R, add an edge u â†’ v with capacity 1

Compute the maximum flow in this network
Theorem: The value of the maximum flow equals the size of the maximum cardinality matching in the original bipartite graph
Moreover, the edges u â†’ v where flow f(u,v) = 1 exactly form a maximum matching

Why it works

Each unit of flow from s to t corresponds to one matched edge
Capacity 1 from s â†’ u ensures each left vertex is used in at most one matching edge
Capacity 1 from v â†’ t ensures each right vertex is used in at most one matching edge
Because all capacities are integers, the maximum flow is integer-valued â†’ the flow directly gives a valid matching (integrality theorem)

This construction is one of the most classic and beautiful reductions in algorithm design.
Pseudocode
Construct flow network for bipartite matching
textBUILD-BIPARTITE-MATCHING-FLOW-NETWORK(G = (L âˆª R, E), s, t)
create flow network N with vertices {s, t} âˆª L âˆª R
for each u âˆˆ L:
add edge s â†’ u with capacity 1
for each v âˆˆ R:
add edge v â†’ t with capacity 1
for each original edge (u,v) âˆˆ E (u âˆˆ L, v âˆˆ R):
add edge u â†’ v with capacity 1
return N
Find maximum bipartite matching
textMAXIMUM-BIPARTITE-MATCHING(G = (L âˆª R, E))
N â† BUILD-BIPARTITE-MATCHING-FLOW-NETWORK(G, s, t)
compute maximum flow f in N using any max-flow algorithm
M â† empty set
for each original edge (u,v) âˆˆ E:
if f(u,v) = 1:
add (u,v) to M
return M (and optionally |f| as matching size)
TypeScript code â€“ Maximum Bipartite Matching via Max Flow (Edmonds-Karp style)
TypeScriptclass BipartiteMatcher {
private leftSize: number;
private rightSize: number;
private source: number;
private sink: number;
private capacity: number[][];
private flow: number[][];

    constructor(left: number, right: number) {
        this.leftSize = left;
        this.rightSize = right;
        this.source = left + right;
        this.sink = left + right + 1;

        const total = left + right + 2;
        this.capacity = Array(total).fill(0).map(() => Array(total).fill(0));
        this.flow = Array(total).fill(0).map(() => Array(total).fill(0));

        // s â†’ left vertices
        for (let u = 0; u < left; u++) {
            this.capacity[this.source][u] = 1;
        }

        // right vertices â†’ t
        for (let v = left; v < left + right; v++) {
            this.capacity[v][this.sink] = 1;
        }
    }

    addEdge(leftIdx: number, rightIdx: number): void {
        const v = this.leftSize + rightIdx;
        this.capacity[leftIdx][v] = 1;
    }

    private bfs(parent: number[]): boolean {
        const visited = new Array(this.capacity.length).fill(false);
        const queue: number[] = [];

        queue.push(this.source);
        visited[this.source] = true;
        parent[this.source] = -1;

        while (queue.length > 0) {
            const u = queue.shift()!;

            for (let v = 0; v < this.capacity.length; v++) {
                const residual = this.capacity[u][v] - this.flow[u][v] + this.flow[v][u];
                if (!visited[v] && residual > 0) {
                    queue.push(v);
                    parent[v] = u;
                    visited[v] = true;
                    if (v === this.sink) return true;
                }
            }
        }
        return false;
    }

    computeMaxMatching(): { size: number; matching: [number, number][] } {
        const parent = new Array(this.capacity.length).fill(-1);
        let maxFlow = 0;

        while (this.bfs(parent)) {
            let pathFlow = Infinity;
            for (let v = this.sink; v !== this.source; v = parent[v]) {
                const u = parent[v];
                const forward = this.capacity[u][v] - this.flow[u][v];
                const backward = this.flow[v][u];
                pathFlow = Math.min(pathFlow, forward + backward);
            }

            for (let v = this.sink; v !== this.source; v = parent[v]) {
                const u = parent[v];
                if (this.capacity[u][v] > 0) {
                    this.flow[u][v] += pathFlow;
                    this.flow[v][u] -= pathFlow;
                } else {
                    this.flow[v][u] += pathFlow;
                    this.flow[u][v] -= pathFlow;
                }
            }

            maxFlow += pathFlow;
        }

        // Extract matching
        const matching: [number, number][] = [];
        for (let u = 0; u < this.leftSize; u++) {
            for (let v = this.leftSize; v < this.leftSize + this.rightSize; v++) {
                if (this.flow[u][v] === 1) {
                    matching.push([u, v - this.leftSize]);
                }
            }
        }

        return { size: maxFlow, matching };
    }

}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// Left: 0=A, 1=B, 2=C Right: 0=X, 1=Y, 2=Z, 3=W
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const matcher = new BipartiteMatcher(3, 4);

matcher.addEdge(0, 0); // A-X
matcher.addEdge(0, 1); // A-Y
matcher.addEdge(1, 1); // B-Y
matcher.addEdge(1, 2); // B-Z
matcher.addEdge(2, 2); // C-Z
matcher.addEdge(2, 3); // C-W

const result = matcher.computeMaxMatching();

console.log("Maximum matching size:", result.size); // 3
console.log("Matching pairs (left â†’ right):", result.matching);
// Possible output: [[0,0], [1,1], [2,2]] or any other maximum matching of size 3
Important Notes

All capacities in the constructed flow network are 1 â†’ very structured and simple
The max-flow value = size of maximum cardinality matching
The edges with flow = 1 form a valid maximum matching
Running time depends on the max-flow algorithm:
â€“ Edmonds-Karp â†’ O(V EÂ²)
â€“ Dinicâ€™s algorithm â†’ much faster in practice for this structure
This is a cardinality matching (maximizes number of edges)
For weighted bipartite matching (assignment problem / Hungarian algorithm) â†’ use minimum-cost maximum flow
This reduction only works for bipartite graphs â€” general graphs require Edmondsâ€™ blossom algorithm (far more complex)

Key Takeaway
Maximum bipartite matching is elegantly solved by reducing it to a maximum-flow problem. We build a flow network by connecting a source to all left vertices (capacity 1), all right vertices to a sink (capacity 1), and keeping original edges with capacity 1. The maximum flow value equals the size of the maximum matching, and the edges carrying flow 1 give the actual matching. This reduction is clean, widely used, and illustrates the power of flow networks for combinatorial optimization problems.

25.2 The stable-marriage problem
(Introduction to Algorithms, 4th Edition â€“ CLRS)
The stable-marriage problem is a classic problem in combinatorial optimization and matching theory.
It models the problem of pairing two sets of equal size (e.g., men and women, residents and hospitals, students and schools) such that the resulting matching is stable â€” no pair prefers each other over their assigned partners.
Problem Definition
We have two sets of equal size n:

n men = {mâ‚, mâ‚‚, ..., mâ‚™}
n women = {wâ‚, wâ‚‚, ..., wâ‚™}

Each man has a strict preference ordering over all women (a total order).
Each woman has a strict preference ordering over all men (a total order).
A matching is a bijection between men and women (everyone is paired exactly once).
A matching M is unstable if there exists a blocking pair (m, w) such that:

m prefers w to the woman he is matched to in M
w prefers m to the man she is matched to in M

A matching is stable if it contains no blocking pairs.
Goal: Find a stable matching (one always exists).
Gale-Shapley algorithm (deferred acceptance)
The standard way to find a stable matching is the Gale-Shapley algorithm (also called deferred-acceptance algorithm).
There are two versions:

man-proposing (men propose, women accept/reject) â†’ produces man-optimal stable matching
woman-proposing â†’ produces woman-optimal stable matching

The algorithm is very simple and elegant.
Man-proposing Gale-Shapley
textGALE-SHAPLEY(MEN-PROPOSING)
for each man m
set m's current proposal list to empty (or all women in order)
set m's status to free

    while there exists a free man m who still has a woman to propose to
        let w be the highest-ranked woman in m's list who he has not yet proposed to
        if w is free
            match m and w (engage them)
        else (w is already engaged to some m')
            if w prefers m to m'
                disengage m' and w
                engage m and w
                set m' to free
            else
                w rejects m (m remains free)
    return the final matching

Key properties:

Always terminates
Always produces a stable matching
Runs in O(nÂ²) time
The man-proposing version is man-optimal (every man gets the best possible partner among all stable matchings)
The woman-proposing version is woman-optimal

Pseudocode
Gale-Shapley (man-proposing version)
textSTABLE-MARRIAGE(Men, Women, menPref, womenPref)
// menPref[m] = ranked list of women for man m
// womenPref[w] = ranked list of men for woman w

    matching â† empty dictionary (partner arrays)
    freeMen â† queue or list of all men

    for each man m: proposalIndex[m] â† 0   // next woman to propose to

    while freeMen is not empty
        m â† take any free man from freeMen
        w â† menPref[m][proposalIndex[m]]
        proposalIndex[m] â† proposalIndex[m] + 1

        if w is not matched
            match m and w
            remove m from freeMen
        else
            m' â† current partner of w
            if w prefers m over m' (i.e. rank of m < rank of m' in womenPref[w])
                disengage m' and w
                match m and w
                add m' to freeMen
            // else: w rejects m (m stays free and will propose to next woman)

    return matching

TypeScript code â€“ Gale-Shapley (man-proposing)
TypeScriptfunction galeShapley(
menPrefs: number[][], // menPrefs[m] = array of women in order of preference
womenPrefs: number[][] // womenPrefs[w] = array of men in order of preference
): number[] {
const n = menPrefs.length;

    // partnerW[w] = man currently matched to woman w (-1 = free)
    const partnerW: number[] = new Array(n).fill(-1);

    // partnerM[m] = woman currently matched to man m (-1 = free)
    const partnerM: number[] = new Array(n).fill(-1);

    // nextProposal[m] = index of next woman man m should propose to
    const nextProposal: number[] = new Array(n).fill(0);

    // free men queue (we can use array + index or just loop)
    let freeMenCount = n;

    // Woman-rank lookup: womenRank[w][m] = rank of man m for woman w (lower = better)
    const womenRank: number[][] = womenPrefs.map(pref => {
        const rank = new Array(n).fill(0);
        pref.forEach((man, i) => { rank[man] = i; });
        return rank;
    });

    while (freeMenCount > 0) {
        // Find a free man
        let m = -1;
        for (let i = 0; i < n; i++) {
            if (partnerM[i] === -1) {
                m = i;
                break;
            }
        }
        if (m === -1) break; // should not happen

        // Get next woman to propose to
        const w = menPrefs[m][nextProposal[m]];
        nextProposal[m]++;

        if (partnerW[w] === -1) {
            // w is free â†’ engage
            partnerW[w] = m;
            partnerM[m] = w;
            freeMenCount--;
        } else {
            const current = partnerW[w];
            // Compare ranks: lower rank number = higher preference
            if (womenRank[w][m] < womenRank[w][current]) {
                // w prefers new proposer m over current
                partnerW[w] = m;
                partnerM[m] = w;
                partnerM[current] = -1;
                // current man becomes free again
            }
            // else: reject m (he will try next woman in next iteration)
        }
    }

    return partnerM; // partnerM[m] = woman matched to man m

}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// 0=A, 1=B, 2=C men
// 0=X, 1=Y, 2=Z women

const menPrefs = [
[1, 0, 2], // A prefers Y > X > Z
[0, 2, 1], // B prefers X > Z > Y
[0, 1, 2] // C prefers X > Y > Z
];

const womenPrefs = [
[1, 0, 2], // X prefers B > A > C
[0, 2, 1], // Y prefers A > C > B
[2, 0, 1] // Z prefers C > A > B
];

const matching = galeShapley(menPrefs, womenPrefs);

console.log("Man-optimal stable matching (man â†’ woman):");
matching.forEach((woman, man) => {
console.log(`${man} â†’ ${woman}`);
});
// Example possible output:
// 0 â†’ 1 (A â†’ Y)
// 1 â†’ 0 (B â†’ X)
// 2 â†’ 2 (C â†’ Z)
Important Notes

Gale-Shapley always produces a stable matching
The man-proposing version is man-optimal: every man gets the best possible partner among all stable matchings
The woman-proposing version is woman-optimal
There can be many stable matchings â€” Gale-Shapley finds one extreme (optimal for one side)
Algorithm runs in O(nÂ²) time (each man proposes to each woman at most once)
Very practical â€” used in real-world applications:
â€“ National Resident Matching Program (NRMP) for medical residencies
â€“ School choice mechanisms
â€“ Organ donation matching (with extensions)
The algorithm is strategy-proof for the proposing side (no benefit to lying) but not for the receiving side

Key Takeaway
The stable-marriage problem asks for a pairing between two equal-sized groups (men and women) based on preference lists such that no blocking pair exists. The Gale-Shapley deferred-acceptance algorithm efficiently finds a stable matching in O(nÂ²) time. The man-proposing version produces the man-optimal stable matching, while the woman-proposing version produces the woman-optimal one. This algorithm is one of the most famous and widely applied matching algorithms in practice.

25.3 The Hungarian algorithm for the assignment problem
(Introduction to Algorithms, 4th Edition â€“ CLRS)
The assignment problem (also known as the minimum-cost bipartite perfect matching problem) asks:
Given a complete bipartite graph with n workers and n jobs, and a cost c(i,j) for assigning worker i to job j, find a perfect matching (assignment) that minimizes the total cost.
This is a weighted version of the bipartite matching problem seen in 25.1.
Core Idea
The Hungarian algorithm solves the assignment problem in O(nÂ³) time.
It is a primal-dual algorithm that maintains:

a feasible dual solution (prices / potentials for rows and columns)
a feasible primal solution (partial matching)
and iteratively improves them until a perfect matching is found

The key insight is to use dual variables (row potentials u_i and column potentials v_j) to adjust the effective costs:
reduced cost:
cÌ„(i,j) = c(i,j) âˆ’ u_i âˆ’ v_j
The algorithm repeatedly finds augmenting paths in the equality subgraph (edges where reduced cost = 0) and updates dual variables to make progress.
Important properties

Always produces an optimal assignment
Runs in O(nÂ³) time (using careful implementation)
Handles real-valued (non-integer) costs
Can be seen as a specialized min-cost flow algorithm on a very structured graph

Pseudocode (high-level Hungarian algorithm â€“ Kuhnâ€“Munkres style)
textHUNGARIAN-ALGORITHM(cost matrix C[1..n][1..n])
initialize dual variables:
u[1..n] â† 0 // row potentials
v[1..n] â† 0 // column potentials
matching â† empty

    while matching is not a perfect matching
        build equality subgraph Gâ‚€:
            include edge (i,j) if c(i,j) - u[i] - v[j] = 0

        try to find a maximum matching M in Gâ‚€ using augmenting paths

        if |M| = n:
            return M (perfect matching found)
        else:
            let S = set of rows reachable from free rows in the alternating tree
            let T = set of columns reachable

            let Î´ = min { c(i,j) - u[i] - v[j] | i âˆˆ S, j âˆ‰ T }

            update duals:
                for i âˆˆ S:               u[i] â† u[i] + Î´
                for j âˆˆ T:               v[j] â† v[j] - Î´

            // now the equality subgraph has changed â€” repeat

(Note: the full implementation involves BFS/DFS to find augmenting paths and maintain alternating trees â€” similar to Hopcroftâ€“Karp or Kuhnâ€™s version.)
TypeScript code â€“ Hungarian algorithm (simplified version for min-cost assignment)
TypeScriptfunction hungarianAlgorithm(cost: number[][]): { assignment: number[]; totalCost: number } {
const n = cost.length;

    // Step 1: Subtract row minima
    const rowReduced = cost.map(row => {
        const min = Math.min(...row);
        return row.map(val => val - min);
    });

    // Step 2: Subtract column minima
    const matrix = rowReduced.map((row, i) => {
        const colMins = Array(n).fill(Infinity);
        for (let j = 0; j < n; j++) {
            colMins[j] = Math.min(colMins[j], rowReduced[i][j]);
        }
        return row.map((val, j) => val - colMins[j]);
    });

    // u = row potentials, v = column potentials
    const u = new Array(n).fill(0);
    const v = new Array(n).fill(0);

    // assignment[j] = row assigned to column j (-1 = unassigned)
    const assignment: number[] = new Array(n).fill(-1);

    // Try to find augmenting paths until perfect matching
    for (let root = 0; root < n; root++) {
        const visitedRow = new Array(n).fill(false);
        const visitedCol = new Array(n).fill(false);
        const parentCol = new Array(n).fill(-1);

        let found = false;

        // BFS to find augmenting path
        const queue: number[] = [root];
        visitedRow[root] = true;

        while (queue.length > 0 && !found) {
            const r = queue.shift()!;

            for (let c = 0; c < n; c++) {
                if (!visitedCol[c] && matrix[r][c] - u[r] - v[c] === 0) {
                    if (assignment[c] === -1) {
                        // Found augmenting path
                        found = true;
                        parentCol[c] = r;
                        break;
                    } else {
                        const nextRow = assignment[c];
                        if (!visitedRow[nextRow]) {
                            visitedRow[nextRow] = true;
                            parentCol[c] = r;
                            queue.push(nextRow);
                        }
                    }
                    visitedCol[c] = true;
                }
            }
        }

        if (!found) {
            // No augmenting path â†’ update duals (simplified version)
            let delta = Infinity;
            for (let r = 0; r < n; r++) {
                if (visitedRow[r]) {
                    for (let c = 0; c < n; c++) {
                        if (!visitedCol[c]) {
                            delta = Math.min(delta, matrix[r][c] - u[r] - v[c]);
                        }
                    }
                }
            }

            for (let r = 0; r < n; r++) {
                if (visitedRow[r]) u[r] += delta;
            }
            for (let c = 0; c < n; c++) {
                if (visitedCol[c]) v[c] -= delta;
            }

            root--; // retry this root
            continue;
        }

        // Augment along the path
        let col = -1;
        for (let c = 0; c < n; c++) {
            if (parentCol[c] !== -1 && assignment[c] === -1) {
                col = c;
                break;
            }
        }

        while (col !== -1) {
            const row = parentCol[col];
            assignment[col] = row;
            const prevCol = assignment.indexOf(row);
            col = prevCol !== -1 ? prevCol : -1;
        }
    }

    // Compute total cost
    let totalCost = 0;
    for (let j = 0; j < n; j++) {
        const i = assignment[j];
        totalCost += cost[i][j];
    }

    return { assignment, totalCost };

}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const costMatrix = [
[9, 2, 7, 8],
[6, 4, 3, 7],
[5, 8, 1, 8],
[7, 6, 9, 4]
];

const result = hungarianAlgorithm(costMatrix);

console.log("Assignment (column â†’ row):", result.assignment);
console.log("Total minimum cost:", result.totalCost);

// Example possible output:
// Assignment (column â†’ row): [1, 0, 2, 3]
// Total minimum cost: 13
Important Notes

The Hungarian algorithm solves the minimum-cost assignment problem (perfect weighted bipartite matching)
Time complexity is O(nÂ³) in standard implementations
It is a primal-dual method that maintains feasible primal (partial matching) and dual (potentials) solutions
The algorithm finds the optimal assignment (minimum total cost)
Works with real-valued costs (not just integers)
The matrix must be square (equal number of rows and columns); if not, add dummy rows/columns with high cost
For maximum-weight assignment, negate all costs and run the same algorithm
Modern faster alternatives exist (e.g., Jonkerâ€“Volgenant, min-cost flow with better implementations), but Hungarian is historically important and conceptually clean

Key Takeaway
The assignment problem asks for the minimum-cost perfect matching in a complete bipartite graph (assigning n workers to n jobs). The Hungarian algorithm solves it in O(nÂ³) time using a primal-dual approach: it maintains dual variables (row and column potentials), builds equality subgraphs where reduced cost = 0, finds augmenting paths, and updates potentials until a perfect matching is obtained. The final assignment is optimal with respect to the original costs.
