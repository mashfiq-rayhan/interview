# 24. Maximum Flow

## üìã Chapter Overview

| Section | Topic                      | Key Idea                                                        |
| ------- | -------------------------- | --------------------------------------------------------------- |
| 24.1    | Flow Networks              | Formal model for flows, residual graphs, and feasibility checks |
| 24.2    | The Ford-Fulkerson Method  | Repeatedly augment along residual paths                         |
| 24.3    | Maximum Bipartite Matching | Reduction from matching to max flow                             |

---

## 24.1 Flow Networks

### Overview

This section introduces the flow network model ‚Äî the foundational structure for maximum flow, minimum cuts, and reductions like bipartite matching. A flow network models the movement of a commodity from a source to a sink under capacity constraints.

### Core Definitions

- **Directed graph** $G = (V, E)$
- **Source** $s$ and **sink** $t$
- **Capacity function** $c: V \times V \to \mathbb{R}_{\ge 0} \cup \{0\}$
  - $c(u, v)$ is the capacity of edge $u \to v$
  - $c(u, v) = 0$ if no edge exists
- **Flow function** $f: V \times V \to \mathbb{R}$ satisfies:
  - **Capacity constraint:** $0 \le f(u, v) \le c(u, v)$
  - **Flow conservation:** for all $u \in V \setminus \{s, t\}$,
    $$\sum_v f(v, u) = \sum_v f(u, v)$$
  - **Skew symmetry:** $f(u, v) = -f(v, u)$

The **value of the flow** is the net amount leaving the source:
$$|f| = \sum_v f(s, v) - \sum_v f(v, s)$$

### Important Concepts

- **Residual capacity** $c_f(u, v)$:
  - Forward residual: $c(u, v) - f(u, v)$
  - Backward residual: $f(u, v)$
- **Residual graph** $G_f$ contains edge $(u, v)$ iff $c_f(u, v) > 0$

The residual graph is the key idea used by augmenting-path algorithms in later sections.

---

### Pseudocode

**Initialize Flow Network**

```text
INITIALIZE-FLOW-NETWORK(V, s, t, capacities)
    create directed graph G with vertices V
    for each (u, v) with given capacity c(u, v):
        add directed edge u ‚Üí v with capacity c(u, v)
        flow(u, v) ‚Üê 0
        flow(v, u) ‚Üê 0
    return G, flow
```

**Validate Flow**

```text
IS-VALID-FLOW(G, flow, s, t)
    // 1. Capacity constraints
    for every edge (u, v) in G:
        if flow(u, v) < 0 or flow(u, v) > capacity(u, v):
            return false

    // 2. Flow conservation
    for each u ‚àà V \ {s, t}:
        inflow  ‚Üê sum flow(v, u) over all v
        outflow ‚Üê sum flow(u, v) over all v
        if inflow ‚â† outflow:
            return false

    return true
```

**Compute Flow Value**

```text
FLOW-VALUE(flow, s)
    value ‚Üê 0
    for each neighbor v of s:
        value ‚Üê value + flow(s, v)
    return value
```

---

### TypeScript Implementation

```typescript
class FlowNetwork {
  private vertices: Set<string>;
  private adj: Map<string, Set<string>>; // outgoing neighbors
  private capacity: Map<string, Map<string, number>>; // c(u,v)
  private flow: Map<string, Map<string, number>>; // f(u,v)
  private source: string;
  private sink: string;

  constructor(
    vertices: string[],
    edges: [string, string, number][], // [u, v, capacity]
    source: string,
    sink: string,
  ) {
    this.vertices = new Set(vertices);
    this.adj = new Map();
    this.capacity = new Map();
    this.flow = new Map();
    this.source = source;
    this.sink = sink;

    for (const v of vertices) {
      this.adj.set(v, new Set());
      this.capacity.set(v, new Map());
      this.flow.set(v, new Map());
    }

    for (const [u, v, cap] of edges) {
      if (!this.vertices.has(u) || !this.vertices.has(v)) {
        throw new Error(`Invalid vertex: ${u} or ${v}`);
      }
      this.adj.get(u)!.add(v);
      this.capacity.get(u)!.set(v, cap);
      this.flow.get(u)!.set(v, 0);
    }
  }

  isValidFlow(): boolean {
    // Capacity constraints
    for (const u of this.vertices) {
      for (const [v, f] of this.flow.get(u)!.entries()) {
        const cap = this.capacity.get(u)?.get(v) ?? 0;
        if (f < 0 || f > cap) {
          return false;
        }
      }
    }

    // Flow conservation
    for (const u of this.vertices) {
      if (u === this.source || u === this.sink) continue;

      let inflow = 0;
      let outflow = 0;

      for (const v of this.vertices) {
        inflow += this.flow.get(v)?.get(u) ?? 0;
      }

      for (const v of this.adj.get(u) ?? new Set()) {
        outflow += this.flow.get(u)?.get(v) ?? 0;
      }

      if (inflow !== outflow) {
        return false;
      }
    }

    return true;
  }

  getFlowValue(): number {
    let value = 0;
    for (const v of this.adj.get(this.source) ?? new Set()) {
      value += this.flow.get(this.source)?.get(v) ?? 0;
    }
    return value;
  }

  setFlow(u: string, v: string, amount: number): void {
    const cap = this.capacity.get(u)?.get(v);
    if (cap === undefined) throw new Error(`No edge ${u}‚Üí${v}`);
    if (amount < 0 || amount > cap) throw new Error("Invalid flow amount");
    this.flow.get(u)!.set(v, amount);
  }

  residualCapacity(u: string, v: string): number {
    if (this.capacity.get(u)?.has(v)) {
      return (
        (this.capacity.get(u)!.get(v) ?? 0) - (this.flow.get(u)?.get(v) ?? 0)
      );
    }
    return this.flow.get(u)?.get(v) ?? 0; // backward residual
  }
}
```

### Demo Example

```typescript
const vertices = ["s", "A", "B", "t"];
const edges: [string, string, number][] = [
  ["s", "A", 16],
  ["s", "B", 13],
  ["A", "B", 10],
  ["A", "t", 12],
  ["B", "t", 20],
];

const network = new FlowNetwork(vertices, edges, "s", "t");

// Set sample flow
network.setFlow("s", "A", 12);
network.setFlow("s", "B", 11);
network.setFlow("A", "t", 12);
network.setFlow("B", "t", 11);

console.log("Valid flow?", network.isValidFlow()); // true
console.log("Flow value:", network.getFlowValue()); // 23
console.log("Residual s‚ÜíA:", network.residualCapacity("s", "A")); // 4
console.log("Residual A‚Üís:", network.residualCapacity("A", "s")); // 12
```

### Important Notes

- Capacities are non-negative ($c(u, v) \ge 0$)
- No self-loops are allowed in the standard model
- Flow values can be real numbers (not restricted to integers)
- Flow conservation ensures no commodity is created or lost at intermediate nodes
- Skew symmetry allows modeling cancellation naturally
- Residual graphs and residual capacities enable augmenting-path methods
- Antiparallel edges can be transformed away using standard reductions
- Multiple sources/sinks can be handled via super-source and super-sink

> **Key Takeaway:** A flow network consists of a directed graph with source $s$, sink $t$, non-negative edge capacities, and a flow function that respects capacity constraints and flow conservation. The residual network (with forward and backward residual capacities) is the foundation for every augmenting-path-based maximum-flow algorithm.

---

## 24.2 The Ford-Fulkerson Method

### Overview

The Ford-Fulkerson method is a classic approach to solving maximum flow. It is a **method**, not a single algorithm ‚Äî its efficiency depends on how augmenting paths are chosen.

### Core Idea

- Start with zero flow
- While an augmenting path exists in the residual graph $G_f$:
  - Compute the path residual capacity $c_f(p)$ (minimum residual capacity on the path)
  - Augment the flow by $c_f(p)$ along the path
- When no augmenting path exists, the flow is maximum

### Important Theorems

- **Augmenting Path Theorem:** A flow is maximum iff there is no augmenting path from $s$ to $t$ in $G_f$
- **Max-Flow Min-Cut Theorem:** The value of the maximum flow equals the capacity of the minimum $s$-$t$ cut

---

### Pseudocode

```text
FORD-FULKERSON(G, s, t)
    initialize flow f(u, v) ‚Üê 0 for every edge (u, v)
    while there exists an augmenting path p from s to t in residual graph G_f
        c_f(p) ‚Üê min{ c_f(u, v) | (u, v) is an edge on p }
        augment flow along path p by amount c_f(p):
            for each edge (u, v) on p:
                if (u, v) is forward edge in original graph:
                    f(u, v) ‚Üê f(u, v) + c_f(p)
                    f(v, u) ‚Üê f(v, u) - c_f(p)
                else: // (v, u) is backward edge
                    f(v, u) ‚Üê f(v, u) + c_f(p)
                    f(u, v) ‚Üê f(u, v) - c_f(p)
    return f
```

---

### TypeScript Implementation (Edmonds-Karp via BFS)

```typescript
class FordFulkerson {
  private n: number;
  private capacity: number[][]; // capacity[u][v]
  private flow: number[][]; // flow[u][v]
  private source: number;
  private sink: number;

  constructor(
    n: number,
    edges: [number, number, number][],
    source: number,
    sink: number,
  ) {
    this.n = n;
    this.capacity = Array(n)
      .fill(0)
      .map(() => Array(n).fill(0));
    this.flow = Array(n)
      .fill(0)
      .map(() => Array(n).fill(0));
    this.source = source;
    this.sink = sink;

    for (const [u, v, cap] of edges) {
      this.capacity[u][v] = cap;
    }
  }

  private bfs(parent: number[]): boolean {
    const visited = new Array(this.n).fill(false);
    const queue: number[] = [];

    queue.push(this.source);
    visited[this.source] = true;
    parent[this.source] = -1;

    while (queue.length > 0) {
      const u = queue.shift()!;

      for (let v = 0; v < this.n; v++) {
        const residualCapacity =
          this.capacity[u][v] - this.flow[u][v] + this.flow[v][u];
        if (!visited[v] && residualCapacity > 0) {
          queue.push(v);
          parent[v] = u;
          visited[v] = true;
          if (v === this.sink) return true;
        }
      }
    }
    return false;
  }

  maxFlow(): number {
    const parent = new Array(this.n).fill(-1);
    let maxFlow = 0;

    while (this.bfs(parent)) {
      let pathFlow = Infinity;
      for (let v = this.sink; v !== this.source; v = parent[v]) {
        const u = parent[v];
        const forward = this.capacity[u][v] - this.flow[u][v];
        const backward = this.flow[v][u];
        pathFlow = Math.min(pathFlow, forward + backward);
      }

      for (let v = this.sink; v !== this.source; v = parent[v]) {
        const u = parent[v];
        if (this.capacity[u][v] > 0) {
          this.flow[u][v] += pathFlow;
          this.flow[v][u] -= pathFlow;
        } else {
          this.flow[v][u] += pathFlow;
          this.flow[u][v] -= pathFlow;
        }
      }

      maxFlow += pathFlow;
    }

    return maxFlow;
  }

  getFlow(u: number, v: number): number {
    return this.flow[u][v];
  }
}
```

### Demo Example

```typescript
const edges: [number, number, number][] = [
  [0, 1, 16],
  [0, 2, 13],
  [1, 2, 10],
  [1, 3, 12],
  [2, 1, 4],
  [2, 3, 14],
  [3, 2, 9],
  [3, 4, 20],
  [2, 4, 4],
];

const ff = new FordFulkerson(5, edges, 0, 4);
const maxFlowValue = ff.maxFlow();

console.log("Maximum flow:", maxFlowValue); // ‚Üí 23
console.log("Flow s‚Üív1 (0‚Üí1):", ff.getFlow(0, 1)); // example value
console.log("Flow s‚Üív2 (0‚Üí2):", ff.getFlow(0, 2));
```

### Important Notes

- Path selection is unspecified in the generic method
- Poor choices can lead to exponentially many augmentations
- Using BFS (Edmonds-Karp) gives $O(VE^2)$ time
- Works correctly with real-valued (non-integer) capacities
- Max-Flow Min-Cut provides optimality certificate

> **Key Takeaway:** Ford-Fulkerson computes maximum flow by repeatedly finding augmenting paths in the residual network and increasing flow along them. When no augmenting path remains, the flow is maximum and equals the minimum cut capacity. Efficiency depends on path selection.

---

## 24.3 Maximum Bipartite Matching

### Overview

This section shows a key application of maximum flow: solving **maximum bipartite matching** efficiently.

### Core Idea ‚Äî Reduction to Maximum Flow

Given a bipartite graph $G = (L \cup R, E)$:

- Add a source $s$ and sink $t$
- Add edges $s \to u$ for each $u \in L$ (capacity 1)
- Add edges $v \to t$ for each $v \in R$ (capacity 1)
- For each $u \in L, v \in R$ with edge $(u, v)$, add $u \to v$ with capacity 1

The value of the maximum flow equals the size of the maximum matching.

### Why This Works

- Each unit of flow corresponds to one matched pair
- Capacity 1 ensures each vertex is matched at most once
- Integrality of max flow gives integral matching when capacities are integers

---

### Pseudocode

**Construct Flow Network**

```text
BIPARTITE-MATCHING-TO-FLOW-NETWORK(G = (L ‚à™ R, E), s, t)
    create flow network N
    add vertices: s, t, all of L, all of R
    for each u ‚àà L:
        add edge s ‚Üí u with capacity 1
    for each v ‚àà R:
        add edge v ‚Üí t with capacity 1
    for each edge (u, v) ‚àà E where u ‚àà L, v ‚àà R:
        add edge u ‚Üí v with capacity 1
    return N
```

**Solve Matching**

```text
MAXIMUM-BIPARTITE-MATCHING(G = (L ‚à™ R, E))
    create flow network N = BIPARTITE-MATCHING-TO-FLOW-NETWORK(G, s, t)
    compute maximum flow f in N (using Ford-Fulkerson / Edmonds-Karp / Dinic / ...)
    initialize matching M ‚Üê empty set
    for each edge (u, v) in original graph E:
        if f(u, v) = 1:
            add edge (u, v) to matching M
    return M
```

---

### TypeScript Implementation

```typescript
class BipartiteMatching {
  private n: number; // total vertices excluding s and t
  private source: number;
  private sink: number;
  private capacity: number[][];
  private flow: number[][] | null = null;

  constructor(leftSize: number, rightSize: number) {
    this.n = leftSize + rightSize;
    this.source = this.n;
    this.sink = this.n + 1;
    this.capacity = Array(this.n + 2)
      .fill(0)
      .map(() => Array(this.n + 2).fill(0));

    for (let u = 0; u < leftSize; u++) {
      this.capacity[this.source][u] = 1;
    }

    for (let v = leftSize; v < this.n; v++) {
      this.capacity[v][this.sink] = 1;
    }
  }

  addEdge(left: number, right: number): void {
    this.capacity[left][right] = 1;
  }

  private bfs(parent: number[]): boolean {
    const visited = new Array(this.n + 2).fill(false);
    const queue: number[] = [];

    queue.push(this.source);
    visited[this.source] = true;
    parent[this.source] = -1;

    while (queue.length > 0) {
      const u = queue.shift()!;

      for (let v = 0; v < this.n + 2; v++) {
        const residual =
          this.capacity[u][v] -
          (this.flow?.[u][v] ?? 0) +
          (this.flow?.[v][u] ?? 0);
        if (!visited[v] && residual > 0) {
          queue.push(v);
          parent[v] = u;
          visited[v] = true;
          if (v === this.sink) return true;
        }
      }
    }
    return false;
  }

  maxMatching(): number {
    this.flow = Array(this.n + 2)
      .fill(0)
      .map(() => Array(this.n + 2).fill(0));
    const parent = new Array(this.n + 2).fill(-1);
    let maxFlow = 0;

    while (this.bfs(parent)) {
      let pathFlow = Infinity;
      for (let v = this.sink; v !== this.source; v = parent[v]) {
        const u = parent[v];
        const forward = this.capacity[u][v] - (this.flow![u][v] ?? 0);
        const backward = this.flow![v][u] ?? 0;
        pathFlow = Math.min(pathFlow, forward + backward);
      }

      for (let v = this.sink; v !== this.source; v = parent[v]) {
        const u = parent[v];
        if (this.capacity[u][v] > 0) {
          this.flow![u][v] = (this.flow![u][v] ?? 0) + pathFlow;
          this.flow![v][u] = (this.flow![v][u] ?? 0) - pathFlow;
        } else {
          this.flow![v][u] = (this.flow![v][u] ?? 0) + pathFlow;
          this.flow![u][v] = (this.flow![u][v] ?? 0) - pathFlow;
        }
      }

      maxFlow += pathFlow;
    }

    return maxFlow;
  }

  getMatching(leftSize: number): [number, number][] {
    const matching: [number, number][] = [];
    if (!this.flow) return matching;

    for (let u = 0; u < leftSize; u++) {
      for (let v = leftSize; v < this.n; v++) {
        if (this.flow[u][v] === 1) {
          matching.push([u, v]);
        }
      }
    }
    return matching;
  }
}
```

### Demo Example

```typescript
const bm = new BipartiteMatching(3, 4); // left: 0,1,2   right: 3,4,5,6

// Edges (left ‚Üí right)
bm.addEdge(0, 3); // A ‚Üí X
bm.addEdge(0, 4); // A ‚Üí Y
bm.addEdge(1, 4); // B ‚Üí Y
bm.addEdge(1, 5); // B ‚Üí Z
bm.addEdge(2, 5); // C ‚Üí Z
bm.addEdge(2, 6); // C ‚Üí W

const maxMatchSize = bm.maxMatching();
console.log("Maximum matching size:", maxMatchSize); // 3

const matching = bm.getMatching(3);
console.log("Matching pairs (left,right):", matching);
```

### Important Notes

- The reduction is polynomial-time; runtime mirrors the chosen max-flow algorithm
- The flow network has $O(V)$ vertices and $O(E + V)$ edges
- Edmonds-Karp gives $O(VE^2)$ time; Dinic and push-relabel are faster in practice
- This gives maximum cardinality matching (not weighted)
- Weighted bipartite matching uses min-cost max-flow
- Non-bipartite matching is significantly harder (e.g., Blossom algorithm)

> **Key Takeaway:** Maximum bipartite matching can be solved by reducing it to max flow: connect $s$ to all left vertices and all right vertices to $t$, keep original edges with capacity 1, then compute a maximum flow. The flow value equals the matching size, and unit-flow edges define the matching.

---

## Chapter 24 Summary

- **Flow networks (24.1):** define feasible flows and residual graphs
- **Ford-Fulkerson (24.2):** maximize flow via augmenting paths
- **Bipartite matching (24.3):** reduce matching to max flow for efficient solutions
