# 34. NP-Completeness

## ğŸ“‹ Chapter Overview

- 34.1 Polynomial time and why it defines â€œefficientâ€ computation
- Basic complexity classes (P, NP) and polynomial-time verification
- NP-complete problems and polynomial-time reductions (covered in later sections)

---

## 34.1 Polynomial Time

This section formally defines what it means for an algorithm to run in polynomial time, and explains why this class of algorithms is considered the boundary of â€œefficient computationâ€ in theoretical computer science.

### Core Idea

An algorithm is said to run in polynomial time if its running time on input of size n is O(náµ) for some constant k â‰¥ 1.
In other words, the running time is bounded by a polynomial function of the input size.
**Examples**

- O(n), O(n log n), O(nÂ²), O(nÂ³), O(nÂ¹â°â°) â†’ all polynomial
- O(2â¿), O(n!), O(nâ¿) â†’ not polynomial (exponential or super-polynomial)

### Formal Definition

Let n be the input size (usually the number of bits needed to represent the input).
An algorithm runs in polynomial time if there exist constants c > 0 and k â‰¥ 1 such that, for all inputs of size n â‰¥ nâ‚€,
running time â‰¤ c Â· náµ
The set of all decision problems solvable in polynomial time by a deterministic Turing machine is called the complexity class P.
P is widely believed to represent the class of problems that are computationally tractable (efficiently solvable).

### Important Concepts Introduced

Decision problems vs optimization problems
Most of complexity theory (including NP-completeness) is stated in terms of decision problems (yes/no answers)
Example: â€œIs there a Hamiltonian cycle?â€ (decision) vs â€œFind a Hamiltonian cycleâ€ (optimization)

Polynomial-time reducibility
A problem A is polynomial-time reducible to problem B (A â‰¤â‚š B) if there is a polynomial-time algorithm that transforms any instance of A into an instance of B such that the answer to A is yes â‡” the answer to B is yes.

Polynomial-time verifiable
A problem is in NP if, given a proposed solution (certificate), we can verify its correctness in polynomial time.

The central open question
Is P = NP?
Almost all computer scientists believe P â‰  NP, but it remains unproven â€” one of the most important open problems in mathematics and computer science.

Examples of Polynomial-Time Algorithms

Sorting (O(n log n))
Shortest paths (Dijkstra, Bellmanâ€“Ford)
Maximum flow (Fordâ€“Fulkerson with good implementation)
Linear programming (interior-point methods, ellipsoid method)
Matching in bipartite graphs
Many graph problems (connectivity, MST, etc.)

Examples of Problems (believed to be) Outside P

Traveling Salesman Problem (decision version)
0-1 Knapsack (decision version)
Graph coloring
Hamiltonian cycle
Subset sum
SAT (Boolean satisfiability)

These are NP-complete problems (covered later in the chapter).

### Pseudocode

There is no algorithm in this section â€” it is definitional.
However, here is the conceptual test for polynomial time:

```text
IS-POLYNOMIAL-TIME(T(n))          // T(n) = running time function
    return true if there exist constants c > 0, k â‰¥ 1 such that
        T(n) â‰¤ c Â· n^k for all n â‰¥ some nâ‚€
    else
        return false
```

### TypeScript code â€“ Checking if a function appears polynomial (heuristic)

```ts
/**
 * Very rough heuristic: check if running times look polynomial
 * (for educational purposes only â€” not a formal proof)
 */
function appearsPolynomial(times: { n: number; time: number }[]): boolean {
  if (times.length < 5) return false;

  // Sort by n
  times.sort((a, b) => a.n - b.n);

  // Try to fit log(time) â‰ˆ k log(n) + c
  const logs: { logN: number; logT: number }[] = times.map((t) => ({
    logN: Math.log(t.n),
    logT: Math.log(t.time),
  }));

  // Simple linear regression on log-log plot
  let sumX = 0,
    sumY = 0,
    sumXY = 0,
    sumXX = 0;
  const len = logs.length;

  for (const p of logs) {
    sumX += p.logN;
    sumY += p.logT;
    sumXY += p.logN * p.logT;
    sumXX += p.logN * p.logN;
  }

  const slope = (len * sumXY - sumX * sumY) / (len * sumXX - sumX * sumX);
  const intercept = (sumY - slope * sumX) / len;

  // If slope is roughly between 1 and 10 â†’ looks polynomial
  console.log(`Estimated degree (slope): ${slope.toFixed(2)}`);

  return slope >= 0.5 && slope <= 10;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Simulated running times for an O(nÂ²) algorithm
const polyTimes = [
  { n: 10, time: 100 },
  { n: 20, time: 400 },
  { n: 50, time: 2500 },
  { n: 100, time: 10000 },
  { n: 200, time: 40000 },
];

console.log("Polynomial behavior?", appearsPolynomial(polyTimes)); // true, slope â‰ˆ 2

// Simulated exponential O(2^n)
const expTimes = [
  { n: 10, time: 1024 },
  { n: 15, time: 32768 },
  { n: 20, time: 1048576 },
  { n: 25, time: 33554432 },
];

console.log("Polynomial behavior?", appearsPolynomial(expTimes)); // false, slope huge
```

### Important Notes

- Polynomial time is the widely accepted definition of efficient computation.
- Problems in P are considered tractable.
- Problems believed not in P (like NP-complete problems) are considered intractable in the worst case.
- The P vs NP question is one of the seven Clay Millennium Prize Problems â€” unsolved since 1971.
- Many real-world problems are in P (sorting, shortest paths, linear programming, max-flow, etc.).
- The distinction between polynomial and super-polynomial time becomes extremely important when n is large (e.g., cryptographic key sizes).

### Key Takeaway

An algorithm runs in polynomial time if its running time is O(náµ) for some constant k, where n is the input size. The complexity class P consists of all decision problems solvable in polynomial time by a deterministic Turing machine. P is generally considered to represent the set of efficiently solvable problems. The question of whether P = NP (i.e., whether every problem whose solution can be verified in polynomial time can also be solved in polynomial time) remains one of the most important open questions in computer science. Almost all known efficient algorithms (sorting, graph algorithms, linear programming, etc.) run in polynomial time, while many hard problems (SAT, TSP, etc.) are believed to require super-polynomial time.

## 34.2 Polynomial-Time Verification
> This section defines the complexity class NP (Nondeterministic Polynomial time) and explains the concept of polynomial-time verification â€” the key property that distinguishes NP from other classes.

### Core Idea

A problem is in NP if:

It is a decision problem (has yes/no answers), and
For every yes-instance, there exists a certificate (proof, witness) of polynomial size such that we can verify the certificate in polynomial time.

In other words:

If the answer is yes, there is a short proof that can be checked quickly.
We do not require that we can find the proof quickly â€” only that we can verify a given proof quickly.

This is very different from P, where we require that we can solve the problem (find the answer) in polynomial time.

### Formal Definition

A decision problem Î  is in NP if there exists:

A polynomial-time verifier V (a deterministic polynomial-time algorithm)
A certificate size bound p(n) (polynomial)

such that:

If x is a yes-instance of Î  â†’ there exists a certificate c with |c| â‰¤ p(|x|) such that V(x, c) = yes
If x is a no-instance â†’ for all certificates c, V(x, c) = no

### Important Examples

Problems in NP (all have short, efficiently verifiable proofs):

- **Satisfiability (SAT)**  
   Certificate: an assignment of truth values to variables.  
   Verification: plug in the values and evaluate each clause.
- **Hamiltonian Cycle**  
   Certificate: the sequence of vertices forming the cycle.  
   Verification: check it is a cycle and visits every vertex exactly once.
- **Vertex Cover**  
   Certificate: the set of vertices claimed to be a cover.  
   Verification: check that every edge has at least one endpoint in the set.
- **0-1 Knapsack (decision version)**  
   Certificate: the subset of items chosen.  
   Verification: check total weight â‰¤ capacity and total value â‰¥ target.
- **Graph Isomorphism**  
   Certificate: the mapping between vertices.  
   Verification: check that edges are preserved.

### Contrast with P

Every problem in P is also in NP â€” because:

- If we can solve the problem in polynomial time, we can use the solution itself as a trivial certificate and verify it in polynomial time (or just ignore the certificate and solve directly).

But the converse (NP âŠ† P?) is unknown â€” this is the P vs NP question.

### Pseudocode

```text
VERIFY(x, c)
// Generic verifier template for a problem in NP
if length(c) > p(length(x))          // certificate too long
    return no

run polynomial-time checking procedure on (x, c)

if check passes
    return yes
else
    return no
```

```text
IS-IN-NP(problem)
// Conceptual â€” not computable
return true if there exists polynomial p and polynomial-time V such that
    for every yes-instance x there exists c with |c| â‰¤ p(|x|) and V(x,c) = yes,
    and for every no-instance x, V(x,c) = no for all c
```

### TypeScript â€“ Example Verifier for 3-SAT (Classic NP Problem)

```ts
interface Clause {
  literals: number[]; // positive = variable, negative = negation
}

/**
 * Verifier for 3-SAT (decision problem in NP)
 * @param formula - list of clauses (each clause has exactly 3 literals)
 * @param assignment - proposed truth assignment (0-based index â†’ true/false)
 * @returns true if assignment satisfies the formula (certificate valid)
 */
function verify3SAT(formula: Clause[], assignment: boolean[]): boolean {
  // assignment[i] = true/false for variable i (0-based)

  for (const clause of formula) {
    let satisfied = false;

    for (const lit of clause.literals) {
      const varIndex = Math.abs(lit) - 1; // variables numbered 1,2,...
      const value = assignment[varIndex];

      // If literal positive â†’ true when var true
      // If literal negative â†’ true when var false
      const litTrue = lit > 0 ? value : !value;

      if (litTrue) {
        satisfied = true;
        break;
      }
    }

    if (!satisfied) {
      return false; // clause not satisfied â†’ certificate invalid
    }
  }

  return true; // all clauses satisfied
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const formula: Clause[] = [
  { literals: [1, -2, 3] }, // xâ‚ âˆ¨ Â¬xâ‚‚ âˆ¨ xâ‚ƒ
  { literals: [-1, 2, -3] }, // Â¬xâ‚ âˆ¨ xâ‚‚ âˆ¨ Â¬xâ‚ƒ
  { literals: [1, 2, 3] }, // xâ‚ âˆ¨ xâ‚‚ âˆ¨ xâ‚ƒ
];

const goodAssignment = [true, false, true]; // xâ‚=true, xâ‚‚=false, xâ‚ƒ=true

console.log(
  "Good assignment satisfies formula?",
  verify3SAT(formula, goodAssignment),
); // true

const badAssignment = [false, false, false];
console.log(
  "Bad assignment satisfies formula?",
  verify3SAT(formula, badAssignment),
); // false
```

### Important Notes

- NP contains all problems where yes answers have short proofs that can be checked quickly.
- Every problem in P is also in NP â€” we can ignore the certificate and just solve the problem directly.
- NP also contains many hard problems (SAT, TSP, Hamiltonian cycle, etc.).
- The question P = NP? asks whether every problem that has short verifiable proofs can also be solved in polynomial time.
- Most experts believe P â‰  NP, but it is unproven.
- NP-complete problems (next sections) are the hardest problems in NP â€” if any one of them is in P, then P = NP.

### ğŸ“ Key Takeaway

A decision problem is in NP if every yes-instance has a certificate (proof/witness) of polynomial size that can be verified in polynomial time. This definition captures problems where solutions are easy to check but potentially hard to find. All problems in P are in NP (we can just solve them and ignore the certificate), but many important hard problems (SAT, vertex cover, Hamiltonian cycle, etc.) are also in NP. The central open question of computer science â€” P vs NP â€” asks whether every problem whose solution can be efficiently verified can also be efficiently solved. This section establishes the formal foundation for understanding NP-completeness and NP-complete problems in the following sections.

## 34.3 NP-Completeness and Reducibility

This section introduces the concept of NP-completeness â€” one of the most important ideas in theoretical computer science â€” and explains how polynomial-time reducibility is used to prove that problems are NP-complete.

### Core Ideas

**NP-completeness**
A decision problem Î  is NP-complete if it satisfies two conditions:

- Î  is in NP (solutions can be verified in polynomial time).
- Every problem in NP can be reduced to Î  in polynomial time (Î  is NP-hard).

**Polynomial-time reducibility (â‰¤â‚š)**

- Problem A is polynomial-time reducible to problem B (written A â‰¤â‚š B) if there exists a polynomial-time algorithm f such that:
  - x is a yes-instance of A â‡” f(x) is a yes-instance of B.
  - If we can solve B in polynomial time, then we can also solve A in polynomial time.

**Transitivity of reducibility**

- If A â‰¤â‚š B and B â‰¤â‚š C, then A â‰¤â‚š C.

**The first NP-complete problem**

- Cook (1971) and Levin (1973) proved that SAT (Boolean satisfiability) is NP-complete.  
  â†’ SAT is the â€œhardestâ€ problem in NP (in the sense of reducibility).

**Implication**

- If any NP-complete problem can be solved in polynomial time, then all problems in NP can be solved in polynomial time â†’ P = NP.
- Since almost everyone believes P â‰  NP, NP-complete problems are considered intractable in the worst case.

**How to prove a problem is NP-complete**

1. Show that the problem is in NP  
   (give a polynomial-size certificate and a polynomial-time verifier).
2. Show that some known NP-complete problem (usually SAT) reduces to it in polynomial time  
   (construct a polynomial-time reduction that maps yes-instances to yes-instances and no to no).

Once we have one NP-complete problem, we can prove others by reduction from it.

**Examples of NP-complete problems (mentioned or implied)**

- 3-SAT
- Vertex cover
- Independent set
- Clique
- Hamiltonian cycle
- Traveling salesman problem (decision version)
- Subset sum
- Graph coloring
- Knapsack (decision version)

All of these are proven NP-complete by reduction from SAT or from each other.

### Pseudocode

```text
REDUCTION-FROM-SAT-TO-PROBLEM-X(instance of SAT)
// Conceptual â€” specific reductions vary greatly
Take SAT formula Ï† with v variables and c clauses

Construct instance I of problem X in polynomial time

such that:

    Ï† is satisfiable   â‡”   I is a yes-instance of X

return I
```

```text
IS-NP-COMPLETE(problem)
// Conceptual â€” not an algorithm
return true if:
    1. problem is in NP (has poly-time verifier)
    2. SAT â‰¤â‚š problem (or any other NP-complete problem â‰¤â‚š problem)
```

### TypeScript code â€“ Verifier for 3-SAT (illustrates â€œin NPâ€ part)

```ts
interface Literal {
  var: number;
  negated: boolean;
}
interface Clause {
  literals: Literal[];
}

/**
 * Verifier for 3-SAT: checks if given assignment satisfies the formula
 * This shows 3-SAT is in NP â€” certificate = truth assignment
 */
function verify3SAT(
  clauses: Clause[],
  assignment: boolean[], // assignment[0] = xâ‚, assignment[1] = xâ‚‚, ...
): boolean {
  for (const clause of clauses) {
    let satisfied = false;

    for (const lit of clause.literals) {
      const varIndex = lit.var - 1; // variables numbered 1,2,...
      let value = assignment[varIndex];

      if (lit.negated) value = !value;

      if (value) {
        satisfied = true;
        break;
      }
    }

    if (!satisfied) {
      return false;
    }
  }

  return true;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Formula: (xâ‚ âˆ¨ Â¬xâ‚‚ âˆ¨ xâ‚ƒ) âˆ§ (Â¬xâ‚ âˆ¨ xâ‚‚ âˆ¨ Â¬xâ‚ƒ) âˆ§ (xâ‚ âˆ¨ xâ‚‚ âˆ¨ xâ‚ƒ)
const clauses: Clause[] = [
  {
    literals: [
      { var: 1, negated: false },
      { var: 2, negated: true },
      { var: 3, negated: false },
    ],
  },
  {
    literals: [
      { var: 1, negated: true },
      { var: 2, negated: false },
      { var: 3, negated: true },
    ],
  },
  {
    literals: [
      { var: 1, negated: false },
      { var: 2, negated: false },
      { var: 3, negated: false },
    ],
  },
];

const goodAssignment = [true, false, true]; // xâ‚=true, xâ‚‚=false, xâ‚ƒ=true
console.log(
  "Good assignment satisfies 3-SAT?",
  verify3SAT(clauses, goodAssignment),
); // true

const badAssignment = [false, false, false];
console.log(
  "Bad assignment satisfies 3-SAT?",
  verify3SAT(clauses, badAssignment),
); // false
```

### Important Notes

- Being in NP means yes answers are easy to verify, not that they are easy to find.
- NP-complete problems are the hardest problems in NP â€” any one of them being in P would imply P = NP.
- All known NP-complete problems are intractable in the worst case under the assumption that P â‰  NP.
- Reductions must be polynomial-time computable and preserve yes/no answers.
- Thousands of problems have been proven NP-complete since Cookâ€™s theorem (1971).
- In practice, NP-complete problems are solved using heuristics, approximation algorithms, branch-and-bound, SAT solvers, etc.

### ğŸ“ Key Takeaway

A problem is NP-complete if it is in NP (solutions can be verified in polynomial time) and every problem in NP can be reduced to it in polynomial time. The first problem shown to be NP-complete was SAT (Cookâ€“Levin theorem). Once we have one NP-complete problem, we prove others are NP-complete by constructing polynomial-time reductions from it (or from any other NP-complete problem). NP-completeness tells us that a problem is at least as hard as every other problem in NP. Under the widely believed assumption that P â‰  NP, NP-complete problems are intractable in the worst case â€” this is one of the deepest and most important results in theoretical computer science.

## 34.4 NP-Completeness Proofs
> This section explains how to prove that a problem is NP-complete by showing two things:

- The problem is in NP (a yes-instance has a polynomial-size certificate verifiable in polynomial time).
- The problem is NP-hard (some known NP-complete problem reduces to it in polynomial time).

The majority of the section is devoted to three classic NP-completeness proofs using reductions:

- 3-SAT is NP-complete (reduced from SAT).
- Clique is NP-complete (reduced from 3-SAT).
- Vertex cover is NP-complete (reduced from Clique).

These three proofs form a chain that shows how NP-completeness spreads: once we have one NP-complete problem (SAT), we can prove others by carefully constructed polynomial-time reductions.

### 1. 3-SAT is NP-complete

3-SAT: Given a 3-CNF formula (conjunction of clauses, each clause has exactly 3 literals), is it satisfiable?

**In NP:**

- Certificate = truth assignment to all variables.
- Verifier = evaluate each clause (O(number of clauses) time).

**Reduction from SAT (Cookâ€“Levin style, simplified in CLRS):**

Any CNF-SAT formula can be transformed into an equivalent 3-CNF formula in polynomial time by introducing new variables and breaking long clauses into 3-literal clauses.

Example transformation for clause with > 3 literals:

$(aâ‚ âˆ¨ aâ‚‚ âˆ¨ â€¦ âˆ¨ aâ‚–)$ becomes

$(aâ‚ âˆ¨ aâ‚‚ âˆ¨ zâ‚) âˆ§ (Â¬zâ‚ âˆ¨ aâ‚ƒ âˆ¨ zâ‚‚) âˆ§ â€¦ âˆ§ (Â¬zâ‚–â‚‹â‚ƒ âˆ¨ aâ‚–â‚‹â‚ âˆ¨ aâ‚–)$

where zâ‚, zâ‚‚, â€¦ are new variables.

This reduction is polynomial and preserves satisfiability â†’ SAT â‰¤â‚š 3-SAT â†’ 3-SAT is NP-hard â†’ 3-SAT is NP-complete.

### 2. Clique is NP-complete

Clique: Given undirected graph G = (V, E) and integer k, does G contain a clique (complete subgraph) of size k?

**In NP:**

- Certificate = set of k vertices.
- Verifier = check every pair in the set is connected (O(kÂ²) time).

**Reduction from 3-SAT:**

Construct graph G from 3-CNF formula Ï†:

- For each clause, create 3 vertices (one per literal in the clause).
- Connect two vertices with an edge if:
  - They come from different clauses, and
  - They do not represent a variable and its negation.

Then:

- Ï† is satisfiable â‡” G has a k-clique, where k = number of clauses.

Why it works:

- A satisfying assignment picks exactly one true literal per clause â†’ corresponding vertices form a clique (they are from different clauses and not contradictory).
- A k-clique corresponds to picking one literal per clause that are consistent â†’ gives a satisfying assignment.

The construction is polynomial â†’ 3-SAT â‰¤â‚š Clique â†’ Clique is NP-complete.

### 3. Vertex cover is NP-complete

Vertex cover: Given undirected graph G = (V, E) and integer k, does G have a vertex cover of size â‰¤ k?
(A vertex cover is a set C âŠ† V such that every edge has at least one endpoint in C.)

**In NP:**

- Certificate = set C of â‰¤ k vertices.
- Verifier = check every edge has at least one endpoint in C (O(|E|) time).

**Reduction from Clique:**

Given graph G and integer k (does G have a k-clique?), construct complement graph á¸ :

- Same vertices as G.
- Edge between u and v in á¸  iff there is no edge in G.

Then:

- G has a clique of size k â‡” á¸  has a vertex cover of size |V| âˆ’ k.

Why:

- A clique in G is an independent set in á¸  (no edges between them in á¸ ).
- The complement of an independent set is a vertex cover.
- Size of vertex cover = |V| âˆ’ size of independent set.

So: G has k-clique â‡” á¸  has (|V| âˆ’ k)-vertex cover.
Construction is polynomial â†’ Clique â‰¤â‚š Vertex cover â†’ Vertex cover is NP-complete.

### Pseudocode (generic reduction pattern)

```text
REDUCE-3SAT-TO-CLIQUE(3CNF formula Ï† with c clauses)
    Create graph G with 3 vertices per clause (one per literal)
    Add edge between two vertices if:
        - They belong to different clauses, and
        - They do not represent a variable and its negation
    return G and k = c
```

### TypeScript code â€“ Simple 3-SAT verifier (illustrates NP part)

```ts
interface Literal {
  var: number;
  negated: boolean;
}
interface Clause {
  literals: Literal[];
}

/**
 * Verifier for 3-SAT â€” shows that 3-SAT is in NP
 * Certificate = truth assignment (array index 0 = xâ‚, etc.)
 */
function verify3SAT(
  clauses: Clause[],
  assignment: boolean[], // assignment[varIndex] = true/false for variable varIndex+1
): boolean {
  for (const clause of clauses) {
    let satisfied = false;

    for (const lit of clause.literals) {
      const varIndex = lit.var - 1;
      let value = assignment[varIndex];

      if (lit.negated) value = !value;

      if (value) {
        satisfied = true;
        break;
      }
    }

    if (!satisfied) return false;
  }

  return true;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example: (xâ‚ âˆ¨ Â¬xâ‚‚ âˆ¨ xâ‚ƒ) âˆ§ (Â¬xâ‚ âˆ¨ xâ‚‚ âˆ¨ Â¬xâ‚ƒ) âˆ§ (xâ‚ âˆ¨ xâ‚‚ âˆ¨ xâ‚ƒ)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const clauses: Clause[] = [
  {
    literals: [
      { var: 1, negated: false },
      { var: 2, negated: true },
      { var: 3, negated: false },
    ],
  },
  {
    literals: [
      { var: 1, negated: true },
      { var: 2, negated: false },
      { var: 3, negated: true },
    ],
  },
  {
    literals: [
      { var: 1, negated: false },
      { var: 2, negated: false },
      { var: 3, negated: false },
    ],
  },
];

console.log("Good assignment:", verify3SAT(clauses, [true, false, true])); // true
console.log("Bad assignment:", verify3SAT(clauses, [false, false, false])); // false
```

### Important Notes

- NP-complete problems are the hardest problems in NP â€” they are all polynomial-time interreducible.
- A polynomial-time algorithm for any NP-complete problem would imply P = NP.
- All known reductions are deterministic polynomial-time.
- Thousands of problems have been shown NP-complete via reductions from SAT, 3-SAT, Clique, Vertex cover, etc.
- In practice, NP-complete problems are solved using:
  â€“ SAT solvers (very efficient in practice)
  â€“ Branch-and-bound, dynamic programming, approximation algorithms
  â€“ Heuristics and metaheuristics.

### ğŸ“ Key Takeaway

A problem is NP-complete if it is in NP and every problem in NP can be reduced to it in polynomial time. The first problem proven NP-complete was SAT (Cookâ€“Levin theorem). We prove other problems are NP-complete by constructing polynomial-time reductions from a known NP-complete problem (usually SAT or 3-SAT). Classic chain: SAT â†’ 3-SAT â†’ Clique â†’ Vertex cover. NP-completeness tells us that these problems are equally hard (up to polynomial factors). Under the assumption that P â‰  NP, all NP-complete problems are intractable in the worst case â€” this is one of the most profound results in computer science.

## 34.5 NP-Complete Problems
> This section lists and briefly describes some of the most important and historically significant NP-complete problems.
> It also explains why these problems matter and how their NP-completeness was established (usually via reductions from 3-SAT, Clique, Vertex Cover, etc.).
> The problems are grouped by domain to make the list easier to understand.

### Core Takeaway First

All problems listed here are NP-complete.
That means:

- They are in NP (yes-instances have short, efficiently verifiable certificates).
- They are NP-hard (every problem in NP reduces to them in polynomial time).

Therefore, if any of these problems can be solved in polynomial time, then P = NP.
Since we believe P â‰  NP, these problems are considered intractable in the worst case.

### Major NP-complete Problems (with short descriptions)

**Logic / Satisfiability problems**

- **SAT (Boolean satisfiability)**  
  Given a Boolean formula in conjunctive normal form (CNF), is there an assignment of true/false values that makes it true?  
  â†’ The first problem ever proven NP-complete (Cook 1971, Levin 1973).
- **3-SAT**  
  SAT where each clause has exactly 3 literals.  
  â†’ Reduced from SAT by breaking long clauses.
- **3-COLORING**  
  Can the vertices of a graph be colored with 3 colors such that no adjacent vertices have the same color?

**Graph problems**

- **CLIQUE** â€“ Does graph G contain a clique (complete subgraph) of size â‰¥ k?
- **VERTEX COVER** â€“ Is there a set of â‰¤ k vertices that touches every edge?
- **INDEPENDENT SET** â€“ Is there a set of â‰¥ k vertices with no edges between them?
- **HAM-CYCLE (Hamiltonian Cycle)** â€“ Does graph G contain a cycle that visits every vertex exactly once?
- **HAM-PATH (Hamiltonian Path)** â€“ Does G contain a path that visits every vertex exactly once?
- **DIRECTED HAM-CYCLE** â€“ Same as HAM-CYCLE but on directed graphs.

**Set / Partition problems**

- **SUBSET-SUM** â€“ Given set S of integers and target t, is there a subset with sum exactly t?
- **PARTITION** â€“ Can set S of integers be partitioned into two subsets with equal sum?
- **3-PARTITION** â€“ Can set S of 3m positive integers be partitioned into m triplets each summing to the same value B?

**Knapsack & Bin Packing**

- **0-1 KNAPSACK (decision version)** â€“ Given items with weights and values, and knapsack capacity W and target value V, is there a subset with total weight â‰¤ W and total value â‰¥ V?
- **BIN-PACKING (decision version)** â€“ Can n items with sizes sâ‚,â€¦,sâ‚™ be packed into â‰¤ k bins each of capacity 1?

**Other classic NP-complete problems**

- **SET COVER** â€“ Given universe U and collection of subsets Sâ‚,â€¦,Sâ‚˜, is there a subcollection of â‰¤ k subsets whose union is U?
- **EXACT COVER** â€“ Is there a subcollection of subsets that are disjoint and whose union is exactly U?
- **GRAPH COLORING (k-COLORING for k â‰¥ 3)** â€“ Can vertices be colored with k colors so no adjacent vertices share a color?
- **FEEDBACK VERTEX SET** â€“ Is there a set of â‰¤ k vertices whose removal makes the graph acyclic?
- **TRAVELING SALESMAN (decision version)** â€“ Is there a tour visiting every city exactly once with total distance â‰¤ B?

### Pseudocode (generic pattern for proving NP-completeness)

```text
PROVE-PROBLEM-X-IS-NP-COMPLETE(problem X)

Step 1: Show X is in NP
    - Define certificate (usually a subset, assignment, cycle, etc.)
    - Give polynomial-time verifier V(instance, certificate)

Step 2: Show some known NP-complete problem Y reduces to X
    - Take instance of Y (e.g. 3-SAT formula, graph G and k, etc.)
    - In polynomial time, construct instance of X
    - Prove: yes for Y â‡” yes for X

return "X is NP-complete"
```

### TypeScript code â€“ Verifier for Vertex Cover (illustrates â€œin NPâ€ part)

```ts
interface Edge {
  u: number;
  v: number;
}

/**
 * Verifier for Vertex Cover (decision version)
 * Certificate = set of vertices claimed to be a cover
 * Returns true if the set covers all edges
 */
function verifyVertexCover(
  edges: Edge[],
  vertices: number[], // proposed cover (vertex indices)
  k: number,
): boolean {
  if (vertices.length > k) return false;

  const cover = new Set(vertices);

  for (const edge of edges) {
    // Edge is covered if at least one endpoint is in the cover
    if (!cover.has(edge.u) && !cover.has(edge.v)) {
      return false;
    }
  }

  return true;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const edges: Edge[] = [
  { u: 0, v: 1 },
  { u: 0, v: 2 },
  { u: 1, v: 2 },
  { u: 2, v: 3 },
  { u: 3, v: 4 },
];

const smallCover = [0, 2, 3]; // covers all edges
console.log("Small cover works?", verifyVertexCover(edges, smallCover, 3)); // true

const badCover = [1, 4]; // misses edge (0,2) and others
console.log("Bad cover works?", verifyVertexCover(edges, badCover, 3)); // false
```

### Important Notes

- All NP-complete problems are polynomial-time interreducible â€” a chain of reductions connects them all.
- Thousands of problems across many domains have been proven NP-complete.
- Proving NP-completeness usually involves a clever reduction that maps structure of one problem into structure of another.
- In practice, NP-complete problems are solved with:
  â€“ Exact exponential-time algorithms (when n is small)
  â€“ Approximation algorithms (when approximation is acceptable)
  â€“ Heuristics, metaheuristics, SAT solvers, constraint programming.
- The reductions themselves are often beautiful and non-obvious â€” thatâ€™s why they are worth studying.

### ğŸ“ Key Takeaway

A problem is NP-complete if it is in NP and NP-hard (every problem in NP reduces to it in polynomial time). The section shows three classic proofs:

- 3-SAT (reduced from SAT)
- Clique (reduced from 3-SAT)
- Vertex cover (reduced from Clique)

These proofs demonstrate how NP-completeness propagates: once we have one NP-complete problem (SAT), we can prove many others are NP-complete by constructing polynomial-time reductions. NP-complete problems are the hardest problems in NP â€” solving any one of them in polynomial time would imply P = NP. This is why NP-completeness is one of the most profound and practically important concepts in computer science.
