# 15. Greedy Algorithms

## üìã Chapter Overview

| Section  | Topic                       | Key Idea                             |
| -------- | --------------------------- | ------------------------------------ |
| **15.1** | Activity selection          | Pick earliest finish time            |
| **15.2** | Elements of greedy strategy | Greedy choice + optimal substructure |
| **15.3** | Huffman codes               | Merge smallest frequencies           |
| **15.4** | Offline caching             | Evict furthest-in-future             |

---

## 15.1 Activity-Selection Problem

The activity-selection problem is the canonical first example of a greedy algorithm.

We are given a set of n activities, each with a start time s_i and finish time f_i (s_i < f_i).
Activities are sorted by finish time: f‚ÇÅ ‚â§ f‚ÇÇ ‚â§ ‚Ä¶ ‚â§ f‚Çô.

**Goal:** Select the maximum number of compatible activities (no two overlap).

- Compatible = one activity finishes before the next starts.

---

### Greedy Choice Property

- The optimal solution always includes the activity that finishes first among remaining compatible activities.

**Theorem (CLRS proof):**

1. Let S be the set of activities sorted by finish time.
2. Let A be any optimal solution.
3. Then A contains the first activity (activity 1).
4. If not ‚Üí replace the first activity in A with activity 1 ‚Üí still optimal (because activity 1 finishes earliest).

This is the greedy choice property ‚Äî we can safely make the locally optimal choice (earliest finish) and still get a globally optimal solution.

---

### Optimal Substructure

- After selecting the first activity (say activity 1),
- The remaining problem is: select maximum compatible activities from those that start after f‚ÇÅ.
- This subproblem is of the same form ‚Üí we can apply the same greedy rule again.

---

### Greedy Algorithm

1. Sort activities by finish time (already given in problem)
2. Initialize selected set A ‚Üê ‚àÖ
3. Add the first activity (earliest finish) to A
4. For each subsequent activity i:
   - If s_i ‚â• finish time of last selected activity ‚Üí add i to A

---

### Pseudocode

```text

GREEDY-ACTIVITY-SELECTOR(s, f, n)  // s = start times, f = finish times
A ‚Üê ‚àÖ
A ‚Üê A ‚à™ {1}                    // select first activity
last ‚Üê 1
for i ‚Üê 2 to n
if s[i] ‚â• f[last]
A ‚Üê A ‚à™ {i}
last ‚Üê i
return A

```

---

### TypeScript code (complete & runnable)

```ts
/**
 * Greedy activity selection ‚Äì O(n) time after sorting
 * Returns list of selected activity indices (1-based)
 */
function greedyActivitySelector(start: number[], finish: number[]): number[] {
  const n = start.length;
  const selected: number[] = [];

  // Assume already sorted by finish time
  let last = 0; // index of last selected activity
  selected.push(0); // select first activity (index 0)

  for (let i = 1; i < n; i++) {
    if (start[i] >= finish[last]) {
      selected.push(i);
      last = i;
    }
  }

  // Convert to 1-based indices if needed
  return selected.map((idx) => idx + 1);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example (CLRS classic)
const start = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12];
const finish = [4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16];

const selected = greedyActivitySelector(start, finish);
console.log("Selected activities (1-based):", selected);
// ‚Üí [1, 4, 8, 11]  (or equivalent maximum set)
```

---

### Important Notes

- Greedy choice: always pick the activity that finishes earliest among compatible ones
- Time complexity: O(n) after sorting (sorting is O(n log n) if not given sorted)
- Proof of correctness: uses greedy stays ahead or exchange argument (CLRS shows exchange proof)
- Classic real-world use: scheduling meetings, CPU scheduling (earliest deadline first), interval scheduling
- This is the simplest greedy algorithm ‚Äî shows greedy works when we have optimal substructure + greedy choice property

---

### Key Takeaway

> The activity-selection problem is solved optimally by always choosing the activity that finishes first among remaining compatible ones. This greedy choice is safe because of the optimal substructure and greedy choice property ‚Äî leading to a very simple and efficient O(n) algorithm after sorting.

---

## 15.2 Elements of the Greedy Strategy

This section explains the two key ingredients that make a greedy algorithm correct:

- Greedy choice property
- Optimal substructure

These conditions allow us to safely make a locally optimal choice at each step and still arrive at a globally optimal solution.

---

### 1. Greedy choice property

- A problem has the greedy choice property if there exists a greedy choice (a locally optimal decision) such that, after making that choice, there remains an optimal solution that includes it.

**In other words:**

- We can make the best-looking choice now, and there will still exist an optimal solution for the remaining subproblem that is compatible with our choice.

**Example (Activity selection 15.1):**

- Choosing the activity that finishes first is a safe greedy choice.
- Any optimal solution that doesn‚Äôt include it can be modified to include it without decreasing the number of activities (exchange argument).
- After selecting it, the remaining compatible activities form a subproblem of the same form.

---

### 2. Optimal substructure

- A problem has optimal substructure if an optimal solution to the overall problem contains optimal solutions to its subproblems.
- This is the same property that dynamic programming uses ‚Äî but in greedy algorithms, we only solve one subproblem (the remaining one after the greedy choice), not all of them.

**Example (Activity selection):**

- After selecting the first-finishing activity, the subproblem of selecting maximum compatible activities from the remaining ones has optimal substructure ‚Äî its optimal solution is part of the overall optimal solution.

---

### How greedy differs from dynamic programming

| Aspect                    | Greedy Algorithms                             | Dynamic Programming                      |
| ------------------------- | --------------------------------------------- | ---------------------------------------- |
| Choice at each step       | Makes one locally optimal choice              | Considers all possible choices           |
| Subproblems solved        | Only the remaining subproblem                 | All overlapping subproblems              |
| Requires                  | Greedy choice property + optimal substructure | Only optimal substructure                |
| Time complexity (typical) | O(n log n) or better (often after sorting)    | O(n¬≤) or O(n¬≥)                           |
| Correctness proof         | Greedy stays ahead or exchange argument       | Optimal substructure + memoization/table |

---

### When greedy works (CLRS summary)

- The problem has optimal substructure
- A greedy choice can always be included in some optimal solution
- Usually proven via exchange argument: swap a non-greedy choice with greedy one without worsening the solution

**Examples where greedy works:**

- Activity selection (15.1)
- Fractional knapsack (greedy by value/weight)
- Huffman coding (greedy by frequency)
- Minimum spanning trees (Kruskal/Prim)
- Single-source shortest paths (Dijkstra)

**Examples where greedy fails:**

- 0-1 knapsack (greedy by value/weight fails)
- General scheduling with deadlines and profits

---

### TypeScript code ‚Äî Activity selection (greedy example revisited)

```ts
/**
 * Greedy activity selection ‚Äì selects maximum number of non-overlapping activities
 * Assumes activities are already sorted by finish time
 */
function activitySelector(start: number[], finish: number[]): number[] {
  const n = start.length;
  const selected: number[] = [0]; // select first activity (index 0)

  let last = 0; // index of last selected

  for (let i = 1; i < n; i++) {
    if (start[i] >= finish[last]) {
      selected.push(i);
      last = i;
    }
  }

  // Convert to 1-based indices
  return selected.map((i) => i + 1);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example (CLRS classic)
const startTimes = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12];
const finishTimes = [4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16];

const selectedActivities = activitySelector(startTimes, finishTimes);
console.log("Selected activities (1-based):", selectedActivities);
// ‚Üí [1, 4, 8, 11] (maximum of 4 activities)
```

---

### Important Notes

- Greedy algorithms are usually simpler and faster than DP when they work
- Correctness depends on proving both greedy choice property and optimal substructure
- Greedy stays ahead: show that greedy solution is always at least as good as optimal at each step
- Exchange argument: show that any optimal solution can be transformed into the greedy one without loss
- Activity selection clearly demonstrates both properties

---

### Key Takeaway

A greedy algorithm works correctly when the problem has:

- Greedy choice property (safe to take the locally best choice now)
- Optimal substructure (optimal solution contains optimal subsolutions)

> When these hold, greedy gives a simple, fast, and correct solution ‚Äî often after sorting.

---

## 15.3 Huffman codes

Huffman codes are a classic greedy algorithm for optimal prefix-free binary codes ‚Äî used to compress data by assigning shorter codewords to more frequent symbols.

**Given:**

- A set of symbols and their frequencies

**Goal:**

- Build a binary tree (Huffman tree) such that:
  - The path from root to each symbol is its codeword
  - More frequent symbols get shorter paths
  - No codeword is a prefix of another (prefix-free)

This minimizes the weighted path length (average code length √ó frequency).

---

### Problem statement

**Input:**

- n symbols a‚ÇÅ, a‚ÇÇ, ‚Ä¶, a‚Çô
- Frequency f[a·µ¢] for each symbol (higher frequency ‚Üí shorter code)

**Output:**

- A binary code for each symbol such that:
  - Codes are prefix-free
  - Total expected code length Œ£ f[a·µ¢] √ó length(code[a·µ¢]) is minimized

---

### Greedy algorithm ‚Äî Huffman‚Äôs method

1. Start with n leaf nodes, each with frequency f[a·µ¢]
2. Repeatedly:
   - Select the two nodes with the smallest frequencies
   - Create a new internal node with frequency = sum of the two
   - Make the two nodes children of this new node (left = smaller or arbitrary)
   - Add the new node back into the pool
3. Continue until only one node remains ‚Äî this is the root of the Huffman tree

---

### Pseudocode (using a min-priority queue)

```text

HUFFMAN(C)  // C = set of n characters with frequencies
Q ‚Üê C  // min-priority queue keyed on frequency
for i ‚Üê 1 to n-1
z ‚Üê new internal node
z.left ‚Üê x ‚Üê EXTRACT-MIN(Q)
z.right ‚Üê y ‚Üê EXTRACT-MIN(Q)
z.freq ‚Üê x.freq + y.freq
INSERT(Q, z)
return EXTRACT-MIN(Q)  // root of Huffman tree

```

---

### TypeScript code (Huffman tree construction + code assignment)

```ts
class HuffmanNode {
  freq: number;
  symbol?: string; // leaf nodes have symbol
  left: HuffmanNode | null = null;
  right: HuffmanNode | null = null;

  constructor(freq: number, symbol?: string) {
    this.freq = freq;
    this.symbol = symbol;
  }
}

class MinPriorityQueue {
  private heap: HuffmanNode[] = [];

  insert(node: HuffmanNode): void {
    this.heap.push(node);
    this.heap.sort((a, b) => a.freq - b.freq);
  }

  extractMin(): HuffmanNode {
    return this.heap.shift()!;
  }

  isEmpty(): boolean {
    return this.heap.length === 0;
  }
}

function huffmanCoding(symbols: string[], freq: number[]): Map<string, string> {
  if (symbols.length !== freq.length) throw new Error("Mismatch");

  const queue = new MinPriorityQueue();

  // Create leaf nodes
  for (let i = 0; i < symbols.length; i++) {
    queue.insert(new HuffmanNode(freq[i], symbols[i]));
  }

  // Build tree
  while (queue.heap.length > 1) {
    const x = queue.extractMin();
    const y = queue.extractMin();

    const z = new HuffmanNode(x.freq + y.freq);
    z.left = x;
    z.right = y;

    queue.insert(z);
  }

  const root = queue.extractMin();

  // Assign codes (left=0, right=1)
  const codes = new Map<string, string>();
  function assignCodes(node: HuffmanNode | null, code: string = ""): void {
    if (!node) return;
    if (node.symbol !== undefined) {
      codes.set(node.symbol, code || "0"); // single node case
      return;
    }
    assignCodes(node.left, code + "0");
    assignCodes(node.right, code + "1");
  }

  assignCodes(root);

  return codes;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example usage
const symbols = ["a", "b", "c", "d", "e", "f"];
const frequencies = [45, 13, 12, 16, 9, 5];
const huffmanCodes = huffmanCoding(symbols, frequencies);

console.log("Huffman Codes:");
for (const [sym, code] of huffmanCodes) {
  console.log(`${sym}: ${code}`);
}
```

---

### Important Notes

- Huffman coding is optimal for prefix-free binary codes given symbol frequencies
- Uses a min-priority queue ‚Üí time complexity O(n log n)
- Tree is built bottom-up by merging two smallest-frequency nodes
- Codes assigned by traversing the tree (left=0, right=1)
- Prefix-free property holds because every symbol is a leaf
- Real-world use: file compression (ZIP, JPEG, MP3), data transmission

---

### Key Takeaway

Huffman‚Äôs algorithm is a greedy method that builds an optimal prefix-free code by always merging the two lowest-frequency nodes.

- Relies on greedy choice property (merging smallest is safe)
- Relies on optimal substructure (optimal code for subtree is part of overall optimal code)

---

## 15.4 Offline caching

Offline caching (caching problem or page replacement with perfect future knowledge) is a classic problem solved optimally with a greedy algorithm.

---

### Problem statement

- Cache of size k (holds k items/pages)
- Sequence of requests known in advance (offline)

For each request:

- If requested item is in cache ‚Üí hit (cost 0)
- If not ‚Üí miss (cost 1): bring it into cache
- If cache full ‚Üí evict one existing item to make space

üéØ Goal: Minimize total misses (maximize hits)

---

### Greedy algorithm ‚Äî furthest-in-future

- When evicting from a full cache:
  - Evict the item whose next request is furthest in the future
  - If an item is never requested again ‚Üí next request at ‚àû ‚Üí safe to evict
- Ties can be broken arbitrarily
- Known as Belady‚Äôs optimal algorithm (MIN)

---

### Pseudocode

```text

FURTHEST-IN-FUTURE(requests[1..m], k)
cache ‚Üê empty set of size ‚â§ k
misses ‚Üê 0

```

for i ‚Üê 1 to m
req ‚Üê requests[i]
if req ‚àâ cache
misses ‚Üê misses + 1
if |cache| = k
evict ‚Üê argmax\_{x ‚àà cache} nextAppearance(x, i)
remove evict from cache
add req to cache
return misses

```

nextAppearance(x, i) = smallest j ‚â• i such that requests[j] = x, or ‚àû if none.

```

---

### TypeScript code (furthest-in-future offline caching)

```ts
function furthestInFuture(requests: number[], cacheSize: number): number {
  const n = requests.length;
  let misses = 0;
  const cache = new Set<number>();

  for (let i = 0; i < n; i++) {
    const req = requests[i];

    if (cache.has(req)) continue; // hit

    misses++;

    if (cache.size === cacheSize) {
      let furthest = -1;
      let evictCandidate = -1;

      for (const page of cache) {
        let nextUse = Infinity;
        for (let j = i + 1; j < n; j++) {
          if (requests[j] === page) {
            nextUse = j;
            break;
          }
        }

        if (nextUse > furthest) {
          furthest = nextUse;
          evictCandidate = page;
        }
      }

      cache.delete(evictCandidate);
    }

    cache.add(req);
  }

  return misses;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example usage
const requests = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5];
const cacheSize = 3;
const misses = furthestInFuture(requests, cacheSize);
console.log("Total requests:", requests.length);
console.log("Cache misses:", misses); // 8
console.log(
  "Hit rate:",
  (((requests.length - misses) / requests.length) * 100).toFixed(1) + "%",
);
```

---

### Important Notes

- Time complexity: O(n¬≤) naive (can optimize to O(n log k) with better structures)
- Offline ‚Äî requires entire request sequence
- Belady‚Äôs anomaly: for some online algorithms, increasing cache size can increase misses ‚Äî furthest-in-future is optimal offline
- Real-world use: benchmark for online caching algorithms (LRU, FIFO, etc.)
- Greedy choice: evict page requested furthest in future ‚Äî safe due to optimal substructure

---

### Key Takeaway

> The offline caching problem can be solved optimally using a greedy algorithm: evict the page whose next request is furthest in the future. This greedy choice is safe because the problem has both greedy choice property and optimal substructure.
