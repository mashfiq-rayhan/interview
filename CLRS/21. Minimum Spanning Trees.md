# 21. Minimum Spanning Trees

---

## üìã Chapter Overview

| Section | Topic                           | Key Idea                                                         |
| ------- | ------------------------------- | ---------------------------------------------------------------- |
| 21.1    | Growing a Minimum Spanning Tree | Generic algorithm using cut property for safe edge selection     |
| 21.2    | Kruskal's and Prim's Algorithms | Two concrete MST implementations: global greedy vs. local greedy |

---

## 21.1 Growing a Minimum Spanning Tree

### Overview

This section introduces the general concept of a minimum spanning tree (MST) and presents a generic algorithm that grows the MST one edge at a time.

### Definition

A minimum spanning tree of an undirected, connected, weighted graph G = (V, E) is a subset of edges T ‚äÜ E that:

- Connects all vertices (T is a tree)
- Has minimum total edge weight among all such trees

### Generic MST Algorithm

Builds the MST by repeatedly adding the **safest edge** that does not create a cycle.

### Pseudocode (Generic Form)

```text
GENERIC-MST(G, w)
    A ‚Üê ‚àÖ                              // A = set of edges in MST
    while A does not form a spanning tree
        add a safe edge (u,v) to A     // safe = does not create cycle
    return A
```

### Key Question

What makes an edge safe to add?

---

### The Cut Property

**Definition of a Cut:**

- A cut (S, V‚àíS) is a partition of vertices into two disjoint nonempty subsets S and V‚àíS.

**Light Edge Across a Cut:**

- An edge (u,v) crosses the cut if one endpoint is in S and the other is in V‚àíS.
- A light edge is the minimum-weight edge crossing the cut.

**Cut Property (Very Important):**

- Let (S, V‚àíS) be any cut of G that respects A (no edge in A crosses the cut).
- Let (u,v) be a light edge crossing the cut.
- **Then (u,v) is safe to add to A** ‚Äî there exists some MST that includes (u,v).
- This property justifies the greedy choice: always add a light edge across some cut.

---

### Generic Algorithm Using Cut Property

At each step:

- A is a forest (no cycles)
- Consider any cut that respects A
- Add a light edge crossing that cut

### Famous MST Algorithms Following This Template

- **Kruskal's Algorithm:** Uses global light edge ‚Äî lightest edge not creating cycle
- **Prim's Algorithm:** Grows tree from one vertex, always adds lightest edge to fringe
- Both run in O(E log V) time with proper implementation.

---

### TypeScript Implementation (Generic MST Structure)

```typescript
interface Edge {
  u: number;
  v: number;
  weight: number;
}

interface Graph {
  vertices: number[];
  edges: Edge[];
}

// Union-Find (disjoint-set) for cycle detection
class UnionFind {
  private parent: number[];
  private rank: number[];

  constructor(size: number) {
    this.parent = Array.from({ length: size }, (_, i) => i);
    this.rank = new Array(size).fill(0);
  }

  find(x: number): number {
    if (this.parent[x] !== x) {
      this.parent[x] = this.find(this.parent[x]);
    }
    return this.parent[x];
  }

  union(x: number, y: number): boolean {
    const rx = this.find(x);
    const ry = this.find(y);
    if (rx === ry) return false; // cycle

    if (this.rank[rx] < this.rank[ry]) {
      this.parent[rx] = ry;
    } else {
      this.parent[ry] = rx;
      if (this.rank[rx] === this.rank[ry]) this.rank[rx]++;
    }
    return true;
  }
}

// Generic MST skeleton (to be filled by Kruskal or Prim)
function genericMST(graph: Graph): Edge[] {
  const A: Edge[] = [];

  // Sort edges by weight (for Kruskal-like approach)
  const sortedEdges = [...graph.edges].sort((a, b) => a.weight - b.weight);

  const uf = new UnionFind(graph.vertices.length);

  for (const edge of sortedEdges) {
    if (uf.union(edge.u, edge.v)) {
      A.push(edge);
      if (A.length === graph.vertices.length - 1) break;
    }
  }

  return A;
}
```

### Demo Example

**Vertices:** 0, 1, 2, 3  
**Edges:** (0-1:1), (0-2:4), (1-2:2), (1-3:5), (2-3:3)

```typescript
const graph: Graph = {
  vertices: [0, 1, 2, 3],
  edges: [
    { u: 0, v: 1, weight: 1 },
    { u: 0, v: 2, weight: 4 },
    { u: 1, v: 2, weight: 2 },
    { u: 1, v: 3, weight: 5 },
    { u: 2, v: 3, weight: 3 },
  ],
};

const mst = genericMST(graph);
console.log("MST edges:", mst);
// ‚Üí [{u:0,v:1,weight:1}, {u:1,v:2,weight:2}, {u:2,v:3,weight:3}]
// Total weight: 6 (minimum)
```

---

### Important Notes

- The generic algorithm adds safe edges (light edges across cuts that respect current A)
- Kruskal and Prim are concrete implementations of this generic template
- Both produce a minimum spanning tree (if graph is connected)
- If graph is disconnected ‚Üí produces minimum spanning forest
- Time complexity: O(E log V) with binary heap or sorting

> **Key Takeaway:** The generic MST algorithm grows the MST by repeatedly adding a safe edge (a light edge across a cut that respects current A). This safe choice is justified by the cut property ‚Äî it always leads to some minimum spanning tree. This sets the stage for Kruskal's and Prim's algorithms (next section).

---

## 21.2 The Algorithms of Kruskal and Prim

### Overview

This section presents two concrete implementations of the generic MST algorithm from 21.1:

- Kruskal's algorithm
- Prim's algorithm

Both produce a minimum spanning tree (or forest) in O(E log V) time (with proper data structures), but they grow the MST differently.

---

### Kruskal's Algorithm

#### Core Idea

1. Sort all edges by increasing weight.
2. Add the next smallest edge to the MST if it does not create a cycle.
3. Use Union-Find (disjoint-set) to detect cycles efficiently.

#### Pseudocode

```text
KRUSKAL(G, w)
    A ‚Üê ‚àÖ
    Sort edges of G.E into nondecreasing order by weight w
    let u be a new disjoint-set forest (MAKE-SET for each vertex)
    for each edge (u,v) in sorted order
        if FIND-SET(u) ‚â† FIND-SET(v)     // safe edge (no cycle)
            A ‚Üê A ‚à™ {(u,v)}
            UNION(u, v)
    return A
```

#### Time Complexity

- **Sorting:** O(E log E) = O(E log V)
- **Union-Find operations:** nearly O(E Œ±(V)) ‚âà O(E) with path compression + union by rank
- **Total:** O(E log V)

---

### Prim's Algorithm

#### Core Idea

1. Grow the MST starting from an arbitrary vertex.
2. At each step, add the minimum-weight edge that connects a vertex in the current MST to a vertex outside it (the fringe).
3. Use a priority queue to track the cheapest edge leaving the current tree.

#### Pseudocode (Binary Min-Heap)

```text
PRIM(G, w, r)                         // r = arbitrary starting vertex
    for each u in G.V
        u.key ‚Üê ‚àû
        u.œÄ ‚Üê NIL
    r.key ‚Üê 0
    let Q be a min-priority queue containing all vertices keyed by u.key
    while Q ‚â† ‚àÖ
        u ‚Üê EXTRACT-MIN(Q)
        for each vertex v in G.Adj[u]
            if v ‚àà Q and w(u,v) < v.key
                v.œÄ ‚Üê u
                DECREASE-KEY(Q, v, w(u,v))
```

#### Time Complexity (Binary Heap Implementation)

- **EXTRACT-MIN:** O(V log V)
- **DECREASE-KEY:** O(E log V)
- **Total:** O(E log V)
- With Fibonacci heap ‚Üí O(E + V log V), but binary heap is simpler and faster in practice.

---

### TypeScript Implementation (Kruskal's Algorithm)

```typescript
interface Edge {
  u: number;
  v: number;
  weight: number;
}

interface Graph {
  vertices: number[];
  edges: Edge[];
}

class UnionFind {
  private parent: number[];
  private rank: number[];

  constructor(size: number) {
    this.parent = Array.from({ length: size }, (_, i) => i);
    this.rank = new Array(size).fill(0);
  }

  find(x: number): number {
    if (this.parent[x] !== x) {
      this.parent[x] = this.find(this.parent[x]);
    }
    return this.parent[x];
  }

  union(x: number, y: number): boolean {
    const rx = this.find(x);
    const ry = this.find(y);
    if (rx === ry) return false; // cycle

    if (this.rank[rx] < this.rank[ry]) {
      this.parent[rx] = ry;
    } else {
      this.parent[ry] = rx;
      if (this.rank[rx] === this.rank[ry]) this.rank[rx]++;
    }
    return true;
  }
}

function kruskalMST(graph: Graph): Edge[] {
  const A: Edge[] = [];
  const sortedEdges = [...graph.edges].sort((a, b) => a.weight - b.weight);
  const uf = new UnionFind(graph.vertices.length);

  for (const edge of sortedEdges) {
    if (uf.union(edge.u, edge.v)) {
      A.push(edge);
      if (A.length === graph.vertices.length - 1) break;
    }
  }

  return A;
}

// // Demo Example
const graph: Graph = {
  vertices: [0, 1, 2, 3],
  edges: [
    { u: 0, v: 1, weight: 1 },
    { u: 0, v: 2, weight: 4 },
    { u: 1, v: 2, weight: 2 },
    { u: 1, v: 3, weight: 5 },
    { u: 2, v: 3, weight: 3 },
  ],
};

const mst = kruskalMST(graph);
console.log("Kruskal MST edges:", mst);
// ‚Üí [{u:0,v:1,weight:1}, {u:1,v:2,weight:2}, {u:2,v:3,weight:3}]
// Total weight: 6 (minimum)
```

---

### Important Notes

- Both algorithms are correct due to the cut property.
- Kruskal ‚Üí global greedy (lightest edge overall) + Union-Find for cycle check.
- Prim ‚Üí local greedy (lightest edge from current tree) + priority queue.
- Kruskal better for sparse graphs; Prim better for dense graphs (with Fibonacci heap).
- Both run in O(E log V) with binary heap.
- If graph is disconnected ‚Üí both produce minimum spanning forest.

> **Key Takeaway:** Kruskal's and Prim's algorithms are two efficient ways to implement the generic MST-growing strategy: Kruskal adds the globally lightest safe edge (using Union-Find for cycle detection), while Prim grows the MST from one vertex by always adding the lightest edge to the fringe (using priority queue). Both achieve O(E log V) time and produce a minimum spanning tree.
