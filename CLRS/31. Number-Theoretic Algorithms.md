# 31. Number-Theoretic Algorithms

## üìã Chapter Overview

- Elementary divisibility and gcd
- Modular arithmetic and modular inverses
- Solving modular linear equations and the Chinese remainder theorem
- Fast modular exponentiation
- RSA public-key cryptography and primality testing

---

## 31.1 Elementary Number-Theoretic Notions

This section lays the mathematical foundation for all number-theoretic algorithms in Chapter 31: divisibility, gcd, modular arithmetic, congruences, and modular inverses.

### Core Concepts

- **Divisibility and divisors**
  - $a$ divides $b$ (written $a \mid b$) if there exists an integer $k$ such that $b = a\cdot k$.
  - The divisors of $n$ are all integers $d$ such that $d \mid n$.
  - Usually we care about **positive** divisors.

- **Greatest common divisor (gcd)**
  - $\gcd(a, b)$ is the largest positive integer $d$ that divides both $a$ and $b$.
  - Properties:
    - $\gcd(a, b) = \gcd(b, a)$.
    - $\gcd(a, b) = \gcd(a, b + k\,a)$ for any integer $k$ (basis of Euclidean algorithm).
    - $\gcd(a, 0) = |a|$.

- **Relatively prime / coprime**
  - Integers $a$ and $b$ are coprime if $\gcd(a, b) = 1$.

- **Prime and composite numbers**
  - A positive integer $p > 1$ is **prime** if its only positive divisors are $1$ and $p$.
  - A positive integer $>1$ that is not prime is **composite**.

- **Fundamental theorem of arithmetic**
  - Every integer $n > 1$ has a unique prime factorization
    $$
    n = p_1^{e_1} p_2^{e_2} \cdots p_k^{e_k},
    $$
    where the $p_i$ are distinct primes and $e_i \ge 1$.

- **Modular arithmetic ‚Äì congruences**
  - $a \equiv b \pmod m$ iff $m \mid (a - b)$, i.e., $a$ and $b$ leave the same remainder on division by $m$.
  - Properties (all modulo $m$):
    - Symmetry and transitivity: if $a \equiv b$ and $b \equiv c$ then $a \equiv c$.
    - Addition: $a \equiv a'$, $b \equiv b' \Rightarrow a + b \equiv a' + b'$.
    - Multiplication: $a \equiv a'$, $b \equiv b' \Rightarrow ab \equiv a'b'$.

- **Modular inverse**
  - An integer $x$ is a **modular inverse** of $a$ modulo $m$ if
    $$a x \equiv 1 \pmod m.$$
  - A modular inverse exists iff $\gcd(a, m) = 1$.

### Important Theorems

- **Theorem 31.1 (B√©zout‚Äôs identity)**  
  $\gcd(a, b) = d$ iff there exist integers $x, y$ such that
  $$ax + by = d.$$

- **Theorem 31.2 (Existence of modular inverse)**  
  $a$ has a multiplicative inverse modulo $m$ iff $\gcd(a, m) = 1$.

- **Theorem 31.3 (Cancellation law)**  
  If $\gcd(a, m) = 1$ and $a x \equiv a y \pmod m$, then $x \equiv y \pmod m$.

These results are foundational for modular exponentiation, RSA, and primality testing.

### Pseudocode ‚Äì Euclidean and Extended Euclidean Algorithms

**Euclidean gcd (recursive form)**

```text
EUCLIDEAN-GCD(a, b)
    if b = 0
        return a
    else
        return EUCLIDEAN-GCD(b, a mod b)
```

**Extended Euclidean algorithm (recursive form)**

```text
EXTENDED-EUCLIDEAN(a, b)
    if b = 0
        return (a, 1, 0)          // (gcd, x, y)

    (d', x', y') ‚Üê EXTENDED-EUCLIDEAN(b, a mod b)
    return (d', y', x' ‚àí ‚åäa / b‚åã ¬∑ y')
```

### TypeScript ‚Äì gcd, extended gcd, modular inverse

```ts
// Computes gcd(a, b) using the Euclidean algorithm
function gcd(a: number, b: number): number {
  a = Math.abs(a);
  b = Math.abs(b);

  while (b !== 0) {
    const temp = b;
    b = a % b;
    a = temp;
  }

  return a;
}

// Extended Euclidean algorithm
// Returns [gcd, x, y] such that a*x + b*y = gcd
function extendedGcd(a: number, b: number): [number, number, number] {
  if (b === 0) {
    return [a, 1, 0];
  }

  const [d, x1, y1] = extendedGcd(b, a % b);
  const x = y1;
  const y = x1 - Math.floor(a / b) * y1;

  return [d, x, y];
}

// Modular inverse of a modulo m (if it exists)
function modInverse(a: number, m: number): number | null {
  const [g, x] = extendedGcd(a, m);

  if (g !== 1) {
    console.warn(`No modular inverse: gcd(${a}, ${m}) = ${g} ‚â† 1`);
    return null;
  }

  return ((x % m) + m) % m; // make x positive
}

// Example usage
console.log("gcd(48, 18) =", gcd(48, 18)); // 6

const [d, x, y] = extendedGcd(48, 18);
console.log(`48x + 18y = ${d} ‚Üí x = ${x}, y = ${y}`); // 48¬∑(-1) + 18¬∑3 = 6

const inv = modInverse(5, 17);
console.log("Modular inverse of 5 mod 17 =", inv); // 7
console.log("Check: 5 * 7 mod 17 =", (5 * 7) % 17); // 1
```

### üìù Key Takeaway

Elementary number theory provides the language and tools for all number-theoretic algorithms: divisibility, gcd (via Euclidean algorithm), modular congruences, and modular inverses (via the extended Euclidean algorithm). The most important ideas are B√©zout‚Äôs identity and the fact that modular inverses exist exactly when $\gcd(a, m) = 1$.

---

## 31.2 Greatest Common Divisor

This section focuses on the greatest common divisor and the Euclidean algorithm (plus its extended version).

### Core Idea

- **Definition**  
  $\gcd(a, b)$ is the largest positive integer $d$ that divides both $a$ and $b$.

- **Key property (Euclidean algorithm basis)**  
  For integers $a$ and $b$ with $b ‚â† 0$,

  $$
  \gcd(a, b) = \gcd(b, a \bmod b).
  $$

  Repeatedly replacing the larger number by the remainder eventually reaches $0$; the last nonzero remainder is the gcd.

- **Complexity**  
  Euclidean algorithm runs in $O(\log \min(a, b))$. The worst case occurs when $a$ and $b$ are consecutive Fibonacci numbers.

- **Extended Euclidean algorithm**  
  Finds $x, y$ such that
  $$
  ax + by = \gcd(a, b)
  $$
  (B√©zout coefficients). This is crucial for computing modular inverses and solving linear Diophantine equations.

### Pseudocode

```text
EUCLIDEAN-GCD(a, b)
    while b ‚â† 0
        (a, b) ‚Üê (b, a mod b)
    return a
```

```text
EXTENDED-EUCLIDEAN(a, b)
    if b = 0
        return (a, 1, 0)          // gcd = a, x = 1, y = 0

    (d, x1, y1) ‚Üê EXTENDED-EUCLIDEAN(b, a mod b)

    x ‚Üê y1
    y ‚Üê x1 ‚àí ‚åäa / b‚åã √ó y1

    return (d, x, y)
```

```text
MODULAR-INVERSE(a, m)
    (d, x, y) ‚Üê EXTENDED-EUCLIDEAN(a, m)
    if d ‚â† 1
        return "no inverse exists"
    else
        return (x mod m + m) mod m
```

### TypeScript ‚Äì gcd, extended gcd, modular inverse

```ts
// Basic Euclidean algorithm for gcd(a, b)
function gcd(a: number, b: number): number {
  a = Math.abs(a);
  b = Math.abs(b);

  while (b !== 0) {
    const temp = b;
    b = a % b;
    a = temp;
  }

  return a;
}

// Extended Euclidean algorithm
// Returns [gcd, x, y] such that a*x + b*y = gcd
function extendedGcd(a: number, b: number): [number, number, number] {
  if (b === 0) {
    return [Math.abs(a), Math.sign(a), 0];
  }

  const [d, x1, y1] = extendedGcd(b, a % b);

  const x = y1;
  const y = x1 - Math.floor(a / b) * y1;

  return [d, x, y];
}

// Compute modular inverse of a modulo m
function modInverse(a: number, m: number): number | null {
  const [d, x] = extendedGcd(a, m);

  if (d !== 1) {
    console.warn(`No inverse exists: gcd(${a}, ${m}) = ${d}`);
    return null;
  }

  return ((x % m) + m) % m;
}

// Example usage
console.log("gcd(1071, 462) =", gcd(1071, 462)); // 21

const [d, x, y] = extendedGcd(1071, 462);
console.log(`1071x + 462y = ${d} ‚Üí x = ${x}, y = ${y}`);
// Example: 1071¬∑(-5) + 462¬∑11 = 21

const inv = modInverse(5, 17);
console.log(`Inverse of 5 mod 17 = ${inv}`); // 7
console.log(`Check: 5 √ó ${inv} mod 17 = ${(5 * (inv ?? 0)) % 17}`); // 1

// Another example: inverse doesn't exist
console.log(modInverse(6, 15)); // null (gcd = 3 ‚â† 1)
```

### üìù Key Takeaway

The gcd can be computed extremely efficiently using the Euclidean algorithm. The extended Euclidean algorithm additionally finds integers $x, y$ such that $ax + by = \gcd(a, b)$, enabling modular inverses and many number-theoretic constructions (e.g., RSA).

---

## 31.3 Modular Arithmetic

Modular arithmetic lets us work with remainders after division by a fixed modulus $m$. It underlies modular exponentiation, modular inverses, CRT, RSA, and primality testing.

### Core Definitions

- **Congruence**  
  $$a \equiv b \pmod m \iff m \text{ divides } (a - b).$$
  Equivalently, $a$ and $b$ have the same remainder when divided by $m$.

- **Residue class**  
  The class of $a$ modulo $m$ is $\{a + k m \mid k \in \mathbb{Z}\}$.  
  We usually represent residues by an integer in $\{0, 1, \dots, m-1\}$.

### Important Properties (Modulo $m$)

- **Equivalence relation**
  - Reflexive: $a \equiv a$.
  - Symmetric: $a \equiv b \Rightarrow b \equiv a$.
  - Transitive: $a \equiv b,\ b \equiv c \Rightarrow a \equiv c$.

- **Compatibility with operations**
  - If $a \equiv a'$ and $b \equiv b'$, then
    - $a + b \equiv a' + b'$,
    - $ab \equiv a'b'$,
    - $a - b \equiv a' - b'$.
  - If $a \equiv a'$, then $a^k \equiv {a'}^k$ for all $k \ge 0$.

- **Cancellation law**
  - If $\gcd(a, m) = 1$ and $a x \equiv a y \pmod m$, then $x \equiv y \pmod m$.

- **Division as multiplication by inverse**
  - If $\gcd(a, m) = 1$, then $a$ has a multiplicative inverse $a^{-1}$ modulo $m$ such that $a a^{-1} \equiv 1 \pmod m$.
  - "Dividing by $a$" modulo $m$ means multiplying by $a^{-1}$.

### Pseudocode

```text
MOD-ADD(a, b, m)
    return (a + b) mod m

MOD-MUL(a, b, m)
    return (a ¬∑ b) mod m
```

Naive modular exponentiation (too slow for large $b$):

```text
MOD-EXP-NAIVE(a, b, m)    // computes a^b mod m
    result ‚Üê 1
    for i ‚Üê 1 to b
        result ‚Üê (result ¬∑ a) mod m
    return result
```

Modular inverse (via extended gcd):

```text
MOD-INVERSE(a, m)
    (d, x, y) ‚Üê EXTENDED-EUCLIDEAN(a, m)
    if d ‚â† 1
        error "a has no inverse modulo m"
    return (x mod m + m) mod m
```

### TypeScript ‚Äì modular arithmetic utilities

```ts
// (a + b) mod m
function modAdd(a: number, b: number, m: number): number {
  return ((a % m) + (b % m) + m) % m; // +m handles negatives
}

// (a * b) mod m, using BigInt to avoid overflow
function modMul(a: number, b: number, m: number): number {
  return Number(
    (((BigInt(a) * BigInt(b)) % BigInt(m)) + BigInt(m)) % BigInt(m),
  );
}

// Naive modular exponentiation: a^b mod m (slow for large b)
function modPowNaive(a: number, b: number, m: number): number {
  let result = 1;
  a = a % m;

  for (let i = 0; i < b; i++) {
    result = modMul(result, a, m);
  }

  return result;
}

// Fast modular exponentiation: a^b mod m using binary exponentiation
function modPow(a: number, b: number, m: number): number {
  let result = 1;
  a = a % m;

  while (b > 0) {
    if (b & 1) {
      result = modMul(result, a, m);
    }
    a = modMul(a, a, m); // square a
    b >>>= 1; // b = b / 2
  }

  return result;
}

// Modular inverse using extended Euclidean algorithm
function modInverse(a: number, m: number): number | null {
  function extendedGcd(a: number, b: number): [number, number, number] {
    if (b === 0) {
      return [a, 1, 0];
    }
    const [d, x1, y1] = extendedGcd(b, a % b);
    return [d, y1, x1 - Math.floor(a / b) * y1];
  }

  const [g, x] = extendedGcd(a, m);

  if (g !== 1) {
    console.warn(`No modular inverse: gcd(${a}, ${m}) = ${g}`);
    return null;
  }

  return ((x % m) + m) % m;
}

// Example usage
const m = 17;

console.log("5 + 12 mod 17 =", modAdd(5, 12, m)); // 0
console.log("5 * 7 mod 17 =", modMul(5, 7, m)); // 1 (7 inverse of 5)

console.log("2^10 mod 17 =", modPow(2, 10, m));
console.log("Naive 2^10 mod 17 =", modPowNaive(2, 10, m));

const inv = modInverse(5, m);
console.log(`Inverse of 5 mod ${m} = ${inv}`);
console.log(`Check: 5 * ${inv} mod ${m} =`, modMul(5, inv!, m));
```

### üìù Key Takeaway

Modular arithmetic behaves like ordinary arithmetic but with all results taken modulo $m$. The crucial tool is the modular inverse, which exists iff $\gcd(a, m) = 1$. Together with fast modular exponentiation, modular arithmetic enables efficient computation with huge numbers and underpins public-key cryptography.

---

## 31.4 Solving Modular Linear Equations

We want to solve congruences of the form

$$
ax \equiv b \pmod m.
$$

### Existence and Number of Solutions

Let $d = \gcd(a, m)$.

- If $d \nmid b$ ‚Üí **no solutions**.
- If $d \mid b$ ‚Üí **exactly $d$ solutions** modulo $m$.
  - The solutions are spaced $m / d$ apart.

### How to Find the Solutions

1. Compute $d = \gcd(a, m)$ using the Euclidean algorithm.
2. If $d \nmid b$, stop: no solution.
3. Use the extended Euclidean algorithm to find integers $x_0, y$ such that
   $$a x_0 + m y = d.$$
4. Multiply the equation by $b / d$:
   $$a (x_0 b / d) + m (y b / d) = b,$$
   so one particular solution is $x' = x_0 (b / d)$ (mod $m$).
5. All solutions are
   $$x = x' + k \cdot (m / d) \pmod m, \quad k = 0, 1, \dots, d - 1.$$

### Special Case ‚Äì Modular Inverse

For $b = 1$ and $d = 1$ (i.e., $\gcd(a, m) = 1$), the equation

$$
ax \equiv 1 \pmod m
$$

has a unique solution $x$ modulo $m$, which is the **modular inverse** of $a$ modulo $m$.

### Pseudocode

```text
SOLVE-MODULAR-LINEAR-EQUATION(a, b, m)
    // Solve ax ‚â° b (mod m)
    (d, x0, y) ‚Üê EXTENDED-EUCLIDEAN(a, m)

    if b mod d ‚â† 0
        return "no solution"

    x' ‚Üê (x0 √ó (b / d)) mod m

    solutions ‚Üê empty list
    for k ‚Üê 0 to d ‚àí 1
        add (x' + k √ó (m / d)) mod m to solutions

    return solutions
```

```text
MODULAR-INVERSE(a, m)
    (d, x, y) ‚Üê EXTENDED-EUCLIDEAN(a, m)
    if d ‚â† 1
        return "no inverse exists"
    return (x mod m + m) mod m
```

### TypeScript ‚Äì solving modular linear equations

```ts
// Extended Euclidean algorithm
// Returns [gcd, x, y] such that a*x + b*y = gcd
function extendedGcd(a: number, b: number): [number, number, number] {
  if (b === 0) {
    return [Math.abs(a), Math.sign(a), 0];
  }

  const [d, x1, y1] = extendedGcd(b, a % b);
  const x = y1;
  const y = x1 - Math.floor(a / b) * y1;

  return [d, x, y];
}

// Solve ax ‚â° b (mod m)
function solveModularLinear(a: number, b: number, m: number): number[] {
  const [d, x0] = extendedGcd(a, m);

  // No solution if d does not divide b
  if (b % d !== 0) {
    return [];
  }

  // Particular solution: x' = x0 * (b/d) mod m
  const bd = b / d;
  let xp = (x0 * bd) % m;
  if (xp < 0) xp += m;

  // All solutions: x = x' + k*(m/d) mod m
  const solutions: number[] = [];
  const step = m / d;

  for (let k = 0; k < d; k++) {
    solutions.push((xp + k * step) % m);
  }

  return solutions;
}

// Modular inverse: ax ‚â° 1 (mod m)
function modularInverse(a: number, m: number): number | null {
  const solutions = solveModularLinear(a, 1, m);

  if (solutions.length === 0) {
    return null;
  }

  // Since gcd = 1, there is exactly one solution modulo m
  return solutions[0];
}

// Example 1: 14x ‚â° 30 (mod 100)
console.log("Solve 14x ‚â° 30 (mod 100)");
let sols = solveModularLinear(14, 30, 100);
console.log("Solutions:", sols); // [45, 95] (gcd(14,100)=2, 2|30 ‚Üí 2 solutions)

// Example 2: 5x ‚â° 1 (mod 17)
console.log("\nModular inverse of 5 mod 17");
const inv2 = modularInverse(5, 17);
console.log("Inverse:", inv2); // 7
console.log("Check: 5*7 mod 17 =", (5 * 7) % 17); // 1

// Example 3: 6x ‚â° 3 (mod 9)
console.log("\nSolve 6x ‚â° 3 (mod 9)");
sols = solveModularLinear(6, 3, 9);
console.log("Solutions:", sols); // e.g., [2, 5, 8]
```

### üìù Key Takeaway

For non-coprime $(a, m)$, the equation $ax \equiv b \pmod m$ may have multiple solutions or no solution at all. The existence and count are determined by $d = \gcd(a, m)$: no solution if $d \nmid b$; exactly $d$ solutions (modulo $m$) if $d \mid b$. These methods extend to systems of modular linear equations and are fundamental in cryptography and number theory.

The congruence $ax \equiv b \pmod m$ has solutions iff $\gcd(a, m)$ divides $b$. If solutions exist, there are exactly $d = \gcd(a, m)$ distinct solutions modulo $m$, all obtained from a single particular solution using step size $m / d$. The special case $b = 1$ and $d = 1$ yields the modular inverse.

---

## 31.5 The Chinese Remainder Theorem (CRT)

CRT gives a powerful way to solve systems of simultaneous congruences when the moduli are pairwise coprime.

### Statement

Suppose we have

$$
\begin{aligned}
x &\equiv a_1 \pmod{m_1} \\
x &\equiv a_2 \pmod{m_2} \\
&\vdots \\
x &\equiv a_k \pmod{m_k}
\end{aligned}
$$

where the moduli $m_1, \dots, m_k$ are pairwise coprime: $\gcd(m_i, m_j) = 1$ for $i \ne j$.

Let $M = m_1 m_2 \cdots m_k$. Then:

- There exists a solution $x$.
- The solution is **unique modulo $M$**.

### Constructive formula

Define $M_i = M / m_i$. Since $\gcd(M_i, m_i) = 1$, $M_i$ has an inverse $y_i$ modulo $m_i$ such that
$$M_i y_i \equiv 1 \pmod{m_i}.$$

Then one explicit solution is

$$
x \equiv \sum_{i=1}^k a_i M_i y_i \pmod{M}.
$$

### Pseudocode

```text
CHINESE-REMAINDER-THEOREM(a[1..k], m[1..k])
    // Solve x ‚â° a[i] (mod m[i]) for i = 1..k, m[i] pairwise coprime
    M ‚Üê 1
    for i ‚Üê 1 to k
        M ‚Üê M √ó m[i]

    x ‚Üê 0
    for i ‚Üê 1 to k
        Mi ‚Üê M / m[i]
        yi ‚Üê MODULAR-INVERSE(Mi, m[i])  // exists because gcd(Mi, m[i]) = 1
        x ‚Üê x + a[i] √ó Mi √ó yi

    return x mod M
```

### TypeScript ‚Äì CRT

```ts
// Modular inverse via extended Euclidean algorithm
function modInverse(a: number, m: number): number | null {
  let m0 = m;
  let y = 0;
  let x = 1;

  if (m === 1) return 0;

  while (a > 1) {
    const q = Math.floor(a / m);
    let t = m;
    m = a % m;
    a = t;

    t = y;
    y = x - q * y;
    x = t;
  }

  if (x < 0) x += m0;
  return x;
}

// Chinese Remainder Theorem
function chineseRemainderTheorem(a: number[], m: number[]): number {
  const k = a.length;

  // Compute M = product of all moduli
  let M = 1;
  for (let i = 0; i < k; i++) {
    M *= m[i];
  }

  let x = 0;

  for (let i = 0; i < k; i++) {
    const Mi = M / m[i];
    const yi = modInverse(Mi % m[i], m[i]);

    if (yi === null) {
      throw new Error("Moduli are not pairwise coprime (gcd(Mi, mi) ‚â† 1)");
    }

    x += a[i] * Mi * yi;
    x %= M;
  }

  if (x < 0) x += M;
  return x;
}

// Example usage
// x ‚â° 2 mod 3, x ‚â° 3 mod 5, x ‚â° 2 mod 7
const a = [2, 3, 2];
const m = [3, 5, 7];

const x = chineseRemainderTheorem(a, m);
console.log("Solution x =", x); // 23
console.log("Check:");
console.log("23 mod 3 =", 23 % 3);
console.log("23 mod 5 =", 23 % 5);
console.log("23 mod 7 =", 23 % 7);

// Another example
const a2 = [1, 4, 6];
const m2 = [5, 7, 11];
console.log("\nSolution x =", chineseRemainderTheorem(a2, m2));
```

### üìù Key Takeaway

If the moduli are pairwise coprime, CRT guarantees a unique solution modulo $M = m_1 \cdots m_k$ for a system of congruences. It lets us break large modular computations into smaller ones and then recombine them efficiently‚Äîvital in RSA (CRT optimization), parallel computation, and many other settings.

---

## 31.6 Powers of an Element (Modular Exponentiation)

We want to compute

$$
a^b \bmod m
$$

efficiently when $b$ may be very large.

### Binary Exponentiation (Square-and-Multiply)

- Na√Øve method: multiply $a$ by itself $b$ times ‚Üí $O(b)$ multiplications (infeasible for large $b$).
- Binary exponentiation uses the binary expansion of $b$ and requires only $O(\log b)$ modular multiplications.

Two common forms:

- **Left-to-right**: process the bits of $b$ from most-significant to least-significant.
- **Right-to-left**: process from least-significant to most-significant.

Both have $\Theta(\log b)$ complexity.

### Pseudocode (left-to-right binary method)

```text
MOD-EXP(a, b, m)        // computes a^b mod m
    result ‚Üê 1
    a ‚Üê a mod m

    while b > 0
        if b is odd
            result ‚Üê (result ¬∑ a) mod m

        a ‚Üê (a ¬∑ a) mod m      // square
        b ‚Üê b >> 1             // b ‚Üê b / 2

    return result
```

### TypeScript ‚Äì fast modular exponentiation

```ts
// Fast modular exponentiation: (base^exponent) mod modulus
// Uses binary exponentiation with BigInt
function modPow(
  base: number | bigint,
  exponent: number | bigint,
  modulus: number | bigint,
): bigint {
  base = BigInt(base);
  exponent = BigInt(exponent);
  modulus = BigInt(modulus);

  if (modulus === 1n) return 0n;

  let result = 1n;
  base %= modulus;

  while (exponent > 0n) {
    if (exponent & 1n) {
      result = (result * base) % modulus;
    }
    base = (base * base) % modulus;
    exponent >>= 1n;
  }

  return result;
}

// Example usage
console.log(modPow(2, 10, 17)); // 2^10 = 1024 ‚â° 4 mod 17

// Cryptographic-scale example (toy)
const base = 123456789n;
const exp = 65537n; // common RSA public exponent
const mod = 1000000007n; // large prime modulus

const result = modPow(base, exp, mod);
console.log(`Large exponentiation result: ${result}`);

// Example: modular inverse using extended gcd
function modInverseBig(a: bigint, m: bigint): bigint | null {
  function egcd(a: bigint, b: bigint): [bigint, bigint, bigint] {
    if (b === 0n) return [a, 1n, 0n];
    const [d, x1, y1] = egcd(b, a % b);
    return [d, y1, x1 - (a / b) * y1];
  }

  const [g, x] = egcd(a, m);
  if (g !== 1n) return null;

  return ((x % m) + m) % m;
}

console.log("Inverse of 5 mod 17 =", modInverseBig(5n, 17n)); // 7n
```

### üìù Key Takeaway

Binary exponentiation reduces the cost of computing $a^b \bmod m$ from $O(b)$ to $O(\log b)$ by repeatedly squaring and conditionally multiplying based on the bits of $b$. This is at the heart of RSA, Diffie‚ÄìHellman, and many cryptographic primitives.

---

## 31.7 The RSA Public-Key Cryptosystem

RSA is a public-key cryptosystem based on the asymmetry between easy multiplication and hard factorization.

### Core Idea

- **Easy**: multiply two large primes and do modular exponentiation.
- **Hard (believed)**: factor a large composite $n = pq$ back into $p$ and $q$.

The security of RSA relies on the assumed difficulty of factoring large integers.

### Key Components

1. **Key generation** (receiver):
   - Choose large distinct primes $p$ and $q$ (similar bit length).
   - Compute $n = pq$.
   - Compute $\varphi(n) = (p-1)(q-1)$.
   - Choose public exponent $e$ such that $1 < e < \varphi(n)$ and $\gcd(e, \varphi(n)) = 1$ (often $e = 65537$).
   - Compute private exponent $d$ such that
     $$de \equiv 1 \pmod{\varphi(n)}$$
     (use modular inverse via extended gcd).
   - **Public key**: $(n, e)$.
   - **Private key**: $d$ (and typically also $p, q$ for CRT-based speedup).

2. **Encryption** (sender):
   - Represent message $m$ as an integer with $0 \le m < n$.
   - Compute ciphertext
     $$c = m^e \bmod n.$$

3. **Decryption** (receiver):
   - Recover
     $$m = c^d \bmod n.$$

Correctness follows from Euler‚Äôs theorem: since $de = 1 + k\varphi(n)$ for some $k$, we have

$$
m^{de} = m^{1 + k\varphi(n)} \equiv m \pmod n.
$$

### Pseudocode

```text
RSA-KEY-GENERATION(bits)
    p ‚Üê RANDOM-PRIME(bits / 2)
    q ‚Üê RANDOM-PRIME(bits / 2)
    n ‚Üê p √ó q
    œÜ ‚Üê (p ‚àí 1) √ó (q ‚àí 1)
    e ‚Üê 65537      // or choose random e with gcd(e, œÜ) = 1
    d ‚Üê MODULAR-INVERSE(e, œÜ)
    return public-key (n, e), private-key d

RSA-ENCRYPT(m, (n, e))
    return m^e mod n

RSA-DECRYPT(c, d, n)
    return c^d mod n
```

### TypeScript ‚Äì toy RSA implementation

> Educational only ‚Äì not secure for real-world use.

```ts
// Assume modPow and modInverseBig (BigInt versions) are available

// Very simple Miller‚ÄìRabin-based primality check (toy)
function isProbablyPrime(n: bigint): boolean {
  if (n <= 1n) return false;
  if (n <= 3n) return true;
  if (n % 2n === 0n) return false;

  const witnesses = [2n, 3n, 5n, 7n, 11n, 13n, 17n];
  let s = 0n;
  let d = n - 1n;
  while (d % 2n === 0n) {
    d /= 2n;
    s++;
  }

  for (const a of witnesses) {
    if (a >= n) break;
    let x = modPow(a, d, n);
    if (x === 1n || x === n - 1n) continue;

    let continueOuter = false;
    for (let r = 1n; r < s; r++) {
      x = modPow(x, 2n, n);
      if (x === n - 1n) {
        continueOuter = true;
        break;
      }
    }
    if (continueOuter) continue;
    return false;
  }
  return true;
}

// Generate a small random prime (demo only)
function randomSmallPrime(bitLength: number): bigint {
  const min = 1n << BigInt(bitLength - 1);
  const max = (1n << BigInt(bitLength)) - 1n;

  let candidate: bigint;
  do {
    candidate =
      min + (BigInt(Math.floor(Math.random() * Number(max - min))) & ~1n) + 1n;
  } while (!isProbablyPrime(candidate));

  return candidate;
}

// RSA key generation (small keys for demo)
function generateRSAKeys(bitLength: number = 16): {
  publicKey: { n: bigint; e: bigint };
  privateKey: { d: bigint };
} {
  const p = randomSmallPrime(bitLength / 2);
  const q = randomSmallPrime(bitLength / 2);
  const n = p * q;
  const phi = (p - 1n) * (q - 1n);

  const e = 65537n; // common public exponent
  const d = modInverseBig(e, phi)!;

  return { publicKey: { n, e }, privateKey: { d } };
}

// Encrypt
function rsaEncrypt(
  message: bigint,
  publicKey: { n: bigint; e: bigint },
): bigint {
  const { n, e } = publicKey;
  return modPow(message, e, n);
}

// Decrypt
function rsaDecrypt(
  ciphertext: bigint,
  privateKey: { d: bigint },
  n: bigint,
): bigint {
  return modPow(ciphertext, privateKey.d, n);
}

// Example usage (very small keys)
const { publicKey, privateKey } = generateRSAKeys(16);

console.log("Public key: n =", publicKey.n, "e =", publicKey.e);
console.log("Private key: d =", privateKey.d);

const message = 12345n;
console.log("\nOriginal message:", message);

const ciphertext = rsaEncrypt(message, publicKey);
console.log("Ciphertext:", ciphertext);

const decrypted = rsaDecrypt(ciphertext, privateKey, publicKey.n);
console.log("Decrypted:", decrypted);
console.log("Correct?", decrypted === message);
```

### üìù Key Takeaway

RSA uses a public key $(n, e)$ and private key $d$ with $de \equiv 1 \pmod{\varphi(n)}$. Encryption is $c = m^e \bmod n$, decryption is $m = c^d \bmod n$. Its security rests on the difficulty of factoring large $n$, while modular exponentiation remains efficient.

---

## 31.8 Primality Testing

Primality testing asks whether a given integer $n$ is prime or composite. For cryptographic sizes, deterministic trial division up to $\sqrt{n}$ is far too slow, so we use fast probabilistic tests.

### Miller‚ÄìRabin Primality Test

The main algorithm used in practice is **Miller‚ÄìRabin**, a randomized test that can quickly declare a number composite or say it is "probably prime" with very small error probability.

### Key Ideas

- Based on Fermat‚Äôs little theorem and properties of quadratic residues.
- Write $n - 1 = 2^s d$ with $d$ odd.
- For a random $a \in \{2, \dots, n-2\}$, a prime $n$ must satisfy:
  - either $a^d \equiv 1 \pmod n$, or
  - $a^{2^r d} \equiv -1 \pmod n$ for some $0 \le r < s$.
- If neither condition holds, $a$ is a **witness** that $n$ is composite.

Error probability with $k$ independent witnesses is at most $1 / 4^k$.

### Pseudocode

```text
MILLER-RABIN-PRIMALITY-TEST(n, k)
    // n: number to test, k: number of witnesses
    if n = 2 or n = 3
        return "prime"
    if n < 2 or n even
        return "composite"

    write n ‚àí 1 = 2^s ¬∑ d with d odd

    for i ‚Üê 1 to k
        choose random a ‚àà {2, 3, ‚Ä¶, n ‚àí 2}
        x ‚Üê a^d mod n

        if x = 1 or x = n ‚àí 1
            continue to next witness

        for r ‚Üê 1 to s ‚àí 1
            x ‚Üê x¬≤ mod n
            if x = n ‚àí 1
                goto next witness
            if x = 1
                return "composite"

        return "composite"   // all r checks failed

    return "probably prime"
```

### TypeScript ‚Äì Miller‚ÄìRabin primality test

```ts
// Helper: fast modular exponentiation (as defined earlier)
function modPow(base: bigint, exp: bigint, mod: bigint): bigint {
  let result = 1n;
  base %= mod;

  while (exp > 0n) {
    if (exp & 1n) {
      result = (result * base) % mod;
    }
    base = (base * base) % mod;
    exp >>= 1n;
  }
  return result;
}

// Miller‚ÄìRabin primality test
function isProbablyPrime(n: bigint, k: number = 40): boolean {
  if (n <= 1n) return false;
  if (n <= 3n) return true;
  if (n % 2n === 0n) return false;

  // Write n ‚àí 1 = 2^s * d with d odd
  let s = 0n;
  let d = n - 1n;
  while (d % 2n === 0n) {
    d /= 2n;
    s++;
  }

  // Deterministic witnesses for n < 2^64 (common choice)
  const witnesses = [
    2n,
    3n,
    5n,
    7n,
    11n,
    13n,
    17n,
    19n,
    23n,
    29n,
    31n,
    37n,
  ].filter((w) => w < n);

  for (let i = 0; i < Math.min(k, witnesses.length); i++) {
    const a = witnesses[i];

    let x = modPow(a, d, n);
    if (x === 1n || x === n - 1n) continue;

    let continueWitness = false;
    for (let r = 1n; r < s; r++) {
      x = modPow(x, 2n, n);
      if (x === n - 1n) {
        continueWitness = true;
        break;
      }
      if (x === 1n) return false; // composite
    }

    if (continueWitness) continue;
    return false; // composite
  }

  return true; // probably prime
}

// Example usage
const nums = [
  17n,
  1009n,
  10007n,
  999983n,
  1000000007n,
  1000000007n * 1000000009n + 1n, // composite example
];

for (const num of nums) {
  const isPrime = isProbablyPrime(num, 20);
  console.log(`${num} is ${isPrime ? "probably prime" : "composite"}`);
}
```

### üìù Key Takeaway

Probabilistic primality tests like Miller‚ÄìRabin can determine primality of huge integers extremely quickly. With a small number of witnesses, the probability of error is negligible, which is sufficient for cryptographic applications and prime generation in RSA, Diffie‚ÄìHellman, and elliptic-curve systems.
