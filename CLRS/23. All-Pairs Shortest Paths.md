# Chapter 23: All-Pairs Shortest Paths

_(Introduction to Algorithms, 4th Edition ‚Äì CLRS)_

---

## üìã Chapter Overview

| Section | Topic                                    | Key Idea                                                     |
| ------- | ---------------------------------------- | ------------------------------------------------------------ |
| 23.1    | Shortest Paths and Matrix Multiplication | Min-plus matrix products for repeated squaring approach      |
| 23.2    | The Floyd-Warshall Algorithm             | Dynamic programming with intermediate vertices in O(n¬≥) time |
| 23.3    | Johnson's Algorithm for Sparse Graphs    | Combine Bellman-Ford and Dijkstra for sparse graphs          |

---

## 23.1 Shortest Paths and Matrix Multiplication

### Overview

This section shows how the all-pairs shortest paths problem can be solved using repeated matrix multiplication ‚Äî in the (min, +) semiring instead of normal arithmetic.

### Problem Goal

Compute shortest-path distances Œ¥(u, v) between every pair of vertices in a weighted directed graph (weights may be negative, but no negative cycles).

---

### Core Idea ‚Äî Matrix Multiplication over Shortest Paths

Let W be the n √ó n weight matrix:

- W[i][j] = weight of direct edge i ‚Üí j, or +‚àû if no edge

Define the min-plus product (tropical matrix multiplication):

- (L ‚äï M)[i][j] = min\_{k=1..n} (L[i][k] + M[k][j])

This computes the shortest path using exactly one intermediate vertex k.

Then:

- W¬π[i][j] = shortest path with ‚â§1 edge = W[i][j]
- W¬≤[i][j] = shortest path with ‚â§2 edges = W ‚äï W
- W‚Å¥ = W¬≤ ‚äï W¬≤
- W‚Å∏ = W‚Å¥ ‚äï W‚Å¥
- ‚Ä¶ continue doubling until exponent ‚â• n‚àí1

Since any simple path has ‚â§ n‚àí1 edges, W^(n‚àí1) gives correct all-pairs shortest-path distances.

---

### Slow Repeated Squaring Method

### Pseudocode

```text
SLOW-ALL-PAIRS-SHORTEST-PATHS(W, n)
    L^(1) ‚Üê W
    m ‚Üê 1
    while m < n
        L^(2m) ‚Üê EXTEND-SHORTEST-PATHS(L^(m), L^(m))
        m ‚Üê 2m
    return L^(m)

EXTEND-SHORTEST-PATHS(L, M)  // min-plus matrix multiplication
EXTEND-SHORTEST-PATHS(L, M)
    let N be a new n √ó n matrix
    for i ‚Üê 1 to n
        for j ‚Üê 1 to n
            N[i,j] ‚Üê ‚àû
            for k ‚Üê 1 to n
                N[i,j] ‚Üê min(N[i,j], L[i,k] + M[k,j])
    return N
```

### Time Complexity

O(n¬≥ log n) ‚Äî log n squarings, each O(n¬≥)

---

### TypeScript Implementation

```typescript
/**
 * Slow all-pairs shortest paths via repeated min-plus matrix squaring
 * Time: O(n¬≥ log n)
 * Returns distance matrix (‚àû if unreachable)
 */
function slowAllPairsShortestPaths(W: number[][]): number[][] {
  const n = W.length;
  let L = W.map((row) => row.slice()); // copy W

  let m = 1;
  while (m < n) {
    const nextL: number[][] = Array(n)
      .fill(0)
      .map(() => Array(n).fill(Infinity));

    // L^(2m) = L^(m) ‚äï L^(m)
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < n; k++) {
          if (L[i][k] !== Infinity && L[k][j] !== Infinity) {
            nextL[i][j] = Math.min(nextL[i][j], L[i][k] + L[k][j]);
          }
        }
        nextL[i][j] = Math.min(nextL[i][j], L[i][j]); // Keep direct edges if better
      }
    }

    L = nextL;
    m *= 2;
  }

  return L;
}
```

### Demo Example

```typescript
// Small graph with 3 vertices and negative weights, no cycle
// Vertices 0, 1, 2
// Edges: 0‚Üí1:3, 0‚Üí2:8, 1‚Üí2:4, 1‚Üí0:-2

const W = [
  [0, 3, 8],
  [-2, 0, 4],
  [Infinity, Infinity, 0],
];

const distances = slowAllPairsShortestPaths(W);

console.log("All-pairs shortest distances:");
distances.forEach((row, i) => {
  console.log(
    `From ${i}:`,
    row.map((d) => (d === Infinity ? "‚àû" : d)),
  );
});

// Example Output:
// From 0: [0, 3, 7]     (0‚Üí1‚Üí2 = 3+4=7 < 8)
// From 1: [-2, 0, 4]
// From 2: [‚àû, ‚àû, 0]
```

---

### Important Notes

- Works with negative weights (no negative cycle)
- Time O(n¬≥ log n) ‚Äî slower than Floyd-Warshall's O(n¬≥) for practical n
- Theoretical interest: can be accelerated with fast matrix multiplication ‚Üí O(n^œâ), œâ ‚âà 2.37
- In practice, Floyd-Warshall is preferred ‚Äî simpler & faster for typical graph sizes
- Negative cycle detection not built-in ‚Äî requires separate check (Bellman-Ford style)

> **Key Takeaway:** All-pairs shortest paths can be computed by repeatedly "multiplying" W using (min, +). W^(n‚àí1) gives shortest paths with ‚â§ n‚àí1 edges. While elegant and theoretically improvable with fast matrix multiplication, the practical method is Floyd-Warshall (O(n¬≥)).

---

## 23.2 The Floyd-Warshall Algorithm

**From 4th Edition CLRS**

### Overview

The Floyd-Warshall algorithm computes the all-pairs shortest paths in a weighted directed graph (possibly with negative edge weights, but no negative cycles) in Œò(n¬≥) time. It uses dynamic programming and works by considering every possible intermediate vertex k between every pair of vertices (i, j).

---

### Core Recurrence

Define d^(k)[i][j] = shortest-path weight from vertex i to vertex j using only intermediate vertices from the set {1, 2, ‚Ä¶, k}

### Recurrence Relation

```text
d^(k)[i][j] = min( d^(k-1)[i][j] , d^(k-1)[i][k] + d^(k-1)[k][j] )
```

Key insight:

- Either the shortest path does not go through vertex k ‚Üí keep d^(k-1)[i][j]
- Or it does go through k ‚Üí d^(k-1)[i][k] + d^(k-1)[k][j]

### Base Case & Final Result

- Base: d^(0)[i][j] = w(i,j) (direct edge weight, or +‚àû if no edge)
- Final: d^(n)[i][j] = Œ¥(i,j) (shortest path from i to j using any intermediate vertices)

---

### Bottom-Up Implementation

We use a single n√ón matrix d[i][j] and iteratively improve it for k = 1 to n.

### Pseudocode

```text
Floyd-Warshall ‚Äì all-pairs shortest paths
Time: Œò(n¬≥), Space: Œò(n¬≤)
Input: weight matrix W (‚àû = no edge)
Output: distance matrix (‚àû = unreachable)
```

### TypeScript Implementation

```typescript
function floydWarshall(W: number[][]): number[][] {
  const n = W.length;
  const dist = W.map((row) => row.slice()); // copy matrix

  for (let k = 0; k < n; k++) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (dist[i][k] !== Infinity && dist[k][j] !== Infinity) {
          const candidate = dist[i][k] + dist[k][j];
          if (candidate < dist[i][j]) {
            dist[i][j] = candidate;
          }
        }
      }
    }
  }

  return dist;
}
```

### Demo Example

```typescript
// Graph with 4 vertices, some negative weights
// Vertices 0,1,2,3
// Edges: 0‚Üí1:3, 0‚Üí2:8, 1‚Üí2:4, 1‚Üí3:6, 2‚Üí3:1, 3‚Üí0:-2

const W = [
  [0, 3, 8, Infinity],
  [Infinity, 0, 4, 6],
  [Infinity, Infinity, 0, 1],
  [-2, Infinity, Infinity, 0],
];

const distances = floydWarshall(W);

console.log("All-pairs shortest distances:");
distances.forEach((row, i) => {
  console.log(
    `From ${i}:`,
    row.map((d) => (d === Infinity ? "‚àû" : d)),
  );
});

// Example output:
// From 0: [0, 3, 7, 8]
// From 1: [-2, 0, 4, 5]
// From 2: [-3, -1, 0, 1]
// From 3: [-2, 1, 5, 0]
```

### Important Notes

- Time complexity: Œò(n¬≥) ‚Äî three nested loops over n
- Space: Œò(n¬≤) ‚Äî can be done in-place on the same matrix
- Handles negative-weight edges (as long as no negative cycle)
- No built-in negative-cycle detection ‚Äî after running, check if any d[i][i] < 0
- Can keep a predecessor matrix to reconstruct actual paths
- Real-world use: small to medium graphs (n ‚â§ 1000‚Äì2000), network routing, transitive closure, graph analysis

> **Key Takeaway:** Floyd-Warshall uses dynamic programming to compute all-pairs shortest paths: d^(k)[i][j] = min( d^(k-1)[i][j] , d^(k-1)[i][k] + d^(k-1)[k][j] ). It runs in Œò(n¬≥) time, handles negative weights (no negative cycles), and is one of the simplest and most widely taught all-pairs shortest-path algorithms.

---

## 23.3 Johnson's Algorithm for Sparse Graphs

**From 4th Edition CLRS**

### Overview

Johnson's algorithm computes all-pairs shortest paths in a sparse weighted directed graph (possibly with negative edge weights, but no negative cycles) more efficiently than Floyd-Warshall when the graph is sparse (i.e., E is much smaller than V¬≤).

### Core Idea

Johnson's algorithm combines:

- **Bellman-Ford** (to handle negative weights)
- **Dijkstra** (run V times ‚Äî fast for sparse graphs with non-negative weights)

The trick is to transform the graph so that all edge weights become non-negative, allowing us to safely use Dijkstra V times.

### Step-by-Step Algorithm

**1. Add a dummy vertex q**

- Add a new vertex q
- Add an edge q ‚Üí v with weight 0 for every vertex v in the graph

**2. Run Bellman-Ford from q**

- Compute shortest-path distances h[v] = Œ¥(q, v) for all v
- If Bellman-Ford detects a negative cycle ‚Üí report "negative cycle exists" and stop
- Otherwise, h[v] is well-defined for all v

**3. Reweight all edges**
For every original edge u ‚Üí v with weight w(u,v), define new weight:w'(u,v) = w(u,v) + h[u] ‚àí h[v]Theorem: w'(u,v) ‚â• 0 for all edges (no negative weights after reweighting)
Run Dijkstra‚Äôs algorithm from every vertex using the reweighted graph

- For each source s, compute shortest paths Œ¥'(s, v) using w'
- Time per Dijkstra: O(E + V log V) with binary heap ‚Üí total O(V(E + V log V))

**5. Correct the distances back to original weights**

- For each pair (s, v): Œ¥(s, v) = Œ¥'(s, v) ‚àí h[s] + h[v]
- This gives the correct original shortest-path distances

### Why Reweighting Preserves Shortest Paths

For any path p = v‚ÇÄ ‚Üí v‚ÇÅ ‚Üí ‚Ä¶ ‚Üí v‚Çñ with v‚ÇÄ = s, v‚Çñ = v:

```text
Original weight of p = Œ£ w(v·µ¢‚Çã‚ÇÅ, v·µ¢)

Reweighted weight of p = Œ£ (w(v·µ¢‚Çã‚ÇÅ, v·µ¢) + h[v·µ¢‚Çã‚ÇÅ] ‚àí h[v·µ¢])
                       = Œ£ w(v·µ¢‚Çã‚ÇÅ, v·µ¢) + Œ£ (h[v·µ¢‚Çã‚ÇÅ] ‚àí h[v·µ¢])
                       = original weight + (h[s] ‚àí h[v])   (telescoping sum)

‚Üí Œ¥'(s, v) = Œ¥(s, v) + h[s] ‚àí h[v]
‚Üí Œ¥(s, v) = Œ¥'(s, v) ‚àí h[s] + h[v]
```

The reweighting preserves shortest paths (just shifts all distances by a constant). And because w' ‚â• 0, we can safely use Dijkstra.

### TypeScript Implementation

```typescript
interface Edge {
  from: number;
  to: number;
  weight: number;
}

interface Graph {
  vertices: number[];
  edges: Edge[];
}

function johnsonAllPairsShortestPaths(graph: Graph): number[][] | null {
  const n = graph.vertices.length;

  // Step 1: Add dummy source q = n
  const dummy = n;
  const extendedEdges = [...graph.edges];
  for (const v of graph.vertices) {
    extendedEdges.push({ from: dummy, to: v, weight: 0 });
  }

  // Step 2: Bellman-Ford from dummy source
  const h = new Array(n + 1).fill(Infinity);
  h[dummy] = 0;

  // Relax |V| times (including dummy)
  for (let iter = 0; iter < n; iter++) {
    for (const edge of extendedEdges) {
      const u = edge.from;
      const v = edge.to;
      const w = edge.weight;

      if (h[u] !== Infinity && h[u] + w < h[v]) {
        h[v] = h[u] + w;
      }
    }
  }

  // Check for negative cycle
  for (const edge of extendedEdges) {
    const u = edge.from;
    const v = edge.to;
    const w = edge.weight;
    if (h[u] !== Infinity && h[u] + w < h[v]) {
      return null; // Negative cycle detected
    }
  }

  // Step 3: Reweight edges
  const reweightedEdges: Edge[] = graph.edges.map((edge) => ({
    from: edge.from,
    to: edge.to,
    weight: edge.weight + h[edge.from] - h[edge.to],
  }));

  // Build reweighted adjacency list
  const adjReweighted = new Map<number, { to: number; weight: number }[]>();
  for (const v of graph.vertices) {
    adjReweighted.set(v, []);
  }
  for (const edge of reweightedEdges) {
    adjReweighted.get(edge.from)!.push({ to: edge.to, weight: edge.weight });
  }

  // Step 4: Run Dijkstra from every vertex using reweighted graph
  const allDist: number[][] = Array(n)
    .fill(0)
    .map(() => Array(n).fill(Infinity));

  for (let s = 0; s < n; s++) {
    const { distances } = dijkstraReweighted(
      { vertices: graph.vertices, adj: adjReweighted },
      s,
    );

    for (let v = 0; v < n; v++) {
      if (distances.get(v) !== Infinity) {
        // Correct back to original weights
        allDist[s][v] = distances.get(v)! - h[s] + h[v];
      }
    }
  }

  return allDist;
}

// Helper: Dijkstra on reweighted graph (non-negative weights)
function dijkstraReweighted(
  graph: {
    vertices: number[];
    adj: Map<number, { to: number; weight: number }[]>;
  },
  source: number,
) {
  const distances = new Map<number, number>();
  for (const v of graph.vertices) {
    distances.set(v, Infinity);
  }
  distances.set(source, 0);

  // Simple priority queue (not optimized ‚Äì for clarity)
  const pq: [number, number][] = [[0, source]];

  while (pq.length > 0) {
    pq.sort((a, b) => a[0] - b[0]);
    const [distU, u] = pq.shift()!;

    if (distU > distances.get(u)!) continue;

    const neighbors = graph.adj.get(u) || [];
    for (const edge of neighbors) {
      const v = edge.to;
      const w = edge.weight;
      const newDist = distU + w;
      if (newDist < distances.get(v)!) {
        distances.set(v, newDist);
        pq.push([newDist, v]);
      }
    }
  }

  return { distances };
}
```

### Important Notes

- Johnson's algorithm is faster than Floyd-Warshall when the graph is sparse (E << V¬≤)
- Time: O(V E log V) with binary heap Dijkstra (or O(V E + V¬≤ log V) worst-case)
- Handles negative weights (no negative cycles) ‚Äî Bellman-Ford step detects negative cycles
- Reweighting makes all weights non-negative ‚Üí safe to use Dijkstra V times
- Practical use: sparse graphs with negative weights (e.g., financial networks, scheduling)

> **Key Takeaway:** Johnson's algorithm efficiently solves all-pairs shortest paths in sparse graphs (even with negative weights) by adding a dummy source and running Bellman-Ford to compute reweighting potentials h[v], reweighting edges to make all weights non-negative, running Dijkstra from every vertex on the reweighted graph, and correcting distances back to original weights. This gives O(V E log V) time ‚Äî much better than Floyd-Warshall's O(n¬≥) when E is small.

---

## Chapter 23 Summary

All-pairs shortest paths can be computed using three main approaches:

- **Matrix Multiplication** (Section 23.1): O(n¬≥ log n) time using min-plus products
- **Floyd-Warshall** (Section 23.2): O(n¬≥) time with dynamic programming
- **Johnson's Algorithm** (Section 23.3): O(V E log V) time for sparse graphs

The choice depends on graph density, presence of negative weights, and practical constraints. Floyd-Warshall is preferred for dense graphs, while Johnson's algorithm excels with sparse graphs containing negative weights.
