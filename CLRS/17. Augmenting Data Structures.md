# 17. Augmenting Data Structures

## üìã Chapter Overview

| Section | Topic                           | Key Idea                                                                                       |
| ------- | ------------------------------- | ---------------------------------------------------------------------------------------------- |
| 17.1    | Dynamic Order Statistics        | Augment red-black trees with subtree size to enable k-th smallest and rank queries in O(log n) |
| 17.2    | How to Augment a Data Structure | Four-step methodology: choose augmentation, define info, maintain it, use it efficiently       |
| 17.3    | Interval Trees                  | Augment with max-high field to find overlapping intervals in O(log n)                          |

---

## 17.1 Dynamic Order Statistics

This section introduces **order-statistic trees** ‚Äî a way to augment a red-black tree so that we can efficiently:

- Find the k-th smallest element in a dynamic set
- Perform other order-statistic queries in **O(log n)** worst-case time

### Key Concepts

- **Normal BST:** search, insert, delete in O(h) time (O(log n) when balanced)
- **Order-statistic tree:** adds one extra field per node to support rank-based queries efficiently

**Node augmentation:**

```text
size[x] = number of nodes in subtree rooted at x (including x itself)
size[x] = size[x.left] + size[x.right] + 1
size[NIL] = 0
```

With this, we can:

- Find the k-th smallest element
- Find the rank of any element
- Efficiently select minimum, maximum, successor, etc.

All operations remain **O(log n)** due to red-black balancing.

### Core Operations

#### 1. OS-SELECT(x, k)

Find the k-th smallest element in subtree rooted at x

```text
OS-SELECT(x, k)
    r ‚Üê size[x.left] + 1
    if k = r
        return x
    else if k < r
        return OS-SELECT(x.left, k)
    else
        return OS-SELECT(x.right, k - r)
```

- Start from root, compare k with rank of current node
- Go left if k ‚â§ rank, right if k > rank (adjust k)
- **Time:** O(log n)

#### 2. OS-RANK(T, x)

Find the rank of node x (1-based: how many elements ‚â§ x.key)

```text
OS-RANK(T, x)
    r ‚Üê size[x.left] + 1
    y ‚Üê x
    while y ‚â† T.root
        if y = y.p.right
            r ‚Üê r + size[y.p.left] + 1
        y ‚Üê y.p
    return r
```

- Walk up from x to root
- Add size of left subtrees + 1 when coming from right child
- **Time:** O(log n)

### TypeScript Implementation

```typescript
enum Color {
  RED = "RED",
  BLACK = "BLACK",
}

class OSNode {
  key: number;
  size: number = 1;
  color: Color;
  left: OSNode | null = null;
  right: OSNode | null = null;
  parent: OSNode | null = null;

  constructor(key: number, color: Color = Color.RED) {
    this.key = key;
    this.color = color;
  }

  updateSize(): void {
    this.size =
      1 + (this.left ? this.left.size : 0) + (this.right ? this.right.size : 0);
  }
}

class OrderStatisticTree {
  root: OSNode | null = null;
  NIL: OSNode;

  constructor() {
    this.NIL = new OSNode(0, Color.BLACK);
    this.NIL.size = 0;
    this.root = this.NIL;
  }

  insert(key: number): void {
    const z = new OSNode(key);
    z.left = z.right = this.NIL;

    let y: OSNode | null = this.NIL;
    let x = this.root;

    while (x !== this.NIL) {
      y = x;
      x = key < x.key ? x.left! : x.right!;
    }

    z.parent = y;
    if (y === this.NIL) this.root = z;
    else if (key < y.key) y.left = z;
    else y.right = z;

    this.updateSizes(z);
  }

  private updateSizes(node: OSNode): void {
    while (node !== this.NIL) {
      node.updateSize();
      node = node.parent!;
    }
  }

  select(k: number): number | null {
    return this.osSelect(this.root, k)?.key ?? null;
  }

  private osSelect(x: OSNode | null, k: number): OSNode | null {
    if (!x || x === this.NIL) return null;
    const r = (x.left ? x.left.size : 0) + 1;
    if (k === r) return x;
    if (k < r) return this.osSelect(x.left, k);
    return this.osSelect(x.right, k - r);
  }

  rank(key: number): number {
    const node = this.search(key);
    if (!node) return -1;
    return this.osRank(node);
  }

  private osRank(x: OSNode): number {
    let r = (x.left ? x.left.size : 0) + 1;
    let y = x;
    while (y !== this.root) {
      if (y === y.parent!.right) {
        r += (y.parent!.left ? y.parent!.left.size : 0) + 1;
      }
      y = y.parent!;
    }
    return r;
  }

  search(key: number): OSNode | null {
    let curr = this.root;
    while (curr !== this.NIL && key !== curr.key) {
      curr = key < curr.key ? curr.left! : curr.right!;
    }
    return curr === this.NIL ? null : curr;
  }

  inorder(node: OSNode | null = this.root): number[] {
    const res: number[] = [];
    if (node && node !== this.NIL) {
      res.push(...this.inorder(node.left));
      res.push(node.key);
      res.push(...this.inorder(node.right));
    }
    return res;
  }
}

// ‚îÄ‚îÄ Demo ‚îÄ‚îÄ
const ost = new OrderStatisticTree();
[19, 12, 25, 5, 15, 22, 30, 8, 27].forEach((k) => ost.insert(k));
console.log("Inorder (sorted):", ost.inorder()); // [5,8,12,15,19,22,25,27,30]
console.log("3rd smallest:", ost.select(3)); // 12
console.log("Rank of 22:", ost.rank(22)); // 6
console.log("8th smallest:", ost.select(8)); // 27
```

### Important Notes

- Augmenting each node with **size** allows rank queries and k-th selection
- All operations remain **O(log n)** due to red-black balancing
- Size updates happen in **O(log n)** during insert/delete
- Rotations preserve sizes correctly (bottom-up update)
- **Applications:** database indexing, sorted sets (Redis ZSET), TreeMap with rank

> **Key Takeaway:** By adding subtree size, a red-black tree becomes an order-statistic tree supporting k-th smallest and rank queries in **O(log n)** worst-case time.

---

## 17.2 How to Augment a Data Structure

Augmenting a data structure means adding extra information to each node (or globally) to answer new queries efficiently, while still supporting original operations (insert, delete, search) in roughly the same time.

**Key principle:** keep extra info updated during structural changes without hurting performance guarantees.

### Four-Step Process (CLRS Methodology)

1. **Choose what to augment**: Decide what info to store per node or globally to answer queries.
2. **Define the new information**: Specify the meaning and relation to original structure.
3. **Show how to maintain it**: Ensure updates during insert, delete, rotations, etc. are efficient.
4. **Show how to use it**: Demonstrate how augmented info enables fast queries (O(log n) or better).

### Classic Example: Order-Statistic Tree (17.1)

```text
size[x] = number of nodes in subtree rooted at x (including x)
size[NIL] = 0
size[x] = size[x.left] + size[x.right] + 1
```

**Maintenance:**

- Rotation: recompute size of affected nodes (O(1))
- Insert/Delete: update size along path to root (O(log n))

**Usage:**

- k-th smallest: walk down tree comparing k with size[left] + 1
- Rank of node: sum left subtree sizes + 1 while walking up to root

All operations remain O(log n).

### Another Example: Dynamic Table (Resizing Array)

- Augment with **current size** and **current capacity**
- During insert: if size == capacity ‚Üí double capacity and copy (O(n))
- Amortized cost: O(1) (aggregate/potential analysis)

### General Guidelines

- Choose info easy to update locally (O(1) per rotation, O(log n) per path)
- Prefer fields computable from children (e.g., size = left.size + right.size + 1)
- Ensure rotations correctly update size/color/other fields
- Prove structure still satisfies original invariants (BST property, red-black rules)

### TypeScript Implementation

```typescript
enum Color {
  RED = "RED",
  BLACK = "BLACK",
}

class OSNode {
  key: number;
  size: number = 1; // augmented field
  color: Color;
  left: OSNode | null = null;
  right: OSNode | null = null;
  parent: OSNode | null = null;

  constructor(key: number) {
    this.key = key;
    this.color = Color.RED;
  }

  updateSize(): void {
    this.size =
      1 + (this.left ? this.left.size : 0) + (this.right ? this.right.size : 0);
  }
}

class OrderStatisticTree {
  root: OSNode | null = null;

  insert(key: number): void {
    const z = new OSNode(key);
    if (!this.root) {
      this.root = z;
      z.color = Color.BLACK;
      return;
    }

    let curr: OSNode | null = this.root;
    let par: OSNode | null = null;
    while (curr) {
      par = curr;
      curr = key < curr.key ? curr.left : curr.right;
    }

    z.parent = par;
    if (key < par!.key) par!.left = z;
    else par!.right = z;

    let node = par;
    while (node) {
      node.updateSize();
      node = node.parent;
    }
  }

  select(k: number): number | null {
    return this.osSelect(this.root, k)?.key ?? null;
  }

  private osSelect(x: OSNode | null, k: number): OSNode | null {
    if (!x) return null;
    const leftSize = x.left ? x.left.size : 0;
    const r = leftSize + 1;
    if (k === r) return x;
    if (k < r) return this.osSelect(x.left, k);
    return this.osSelect(x.right, k - r);
  }

  inorder(node: OSNode | null = this.root): number[] {
    const res: number[] = [];
    if (node) {
      res.push(...this.inorder(node.left));
      res.push(node.key);
      res.push(...this.inorder(node.right));
    }
    return res;
  }
}

// ‚îÄ‚îÄ Demo ‚îÄ‚îÄ
const ost = new OrderStatisticTree();
[19, 12, 25, 5, 15, 22, 30, 8, 27].forEach((k) => ost.insert(k));
console.log("Inorder (sorted):", ost.inorder()); // [5,8,12,15,19,22,25,27,30]
console.log("3rd smallest:", ost.select(3)); // 12
console.log("6th smallest:", ost.select(6)); // 22
```

### Important Notes

- Augmentation adds **one extra field (size)** ‚Üí allows O(log n) order statistics
- Size updates along path from insert/delete to root are O(log n)
- Rotations recompute size of affected nodes in O(1)
- Red-black balancing keeps height O(log n)

> **Key Takeaway:**
>
> 1. Choose extra info (e.g., subtree size)
> 2. Maintain during insert/delete/rotations
> 3. Use it for new queries efficiently (O(log n))
> 4. Ensure original operations stay efficient

---

## 17.3 Interval Trees

Interval trees are a classic example of augmenting a red-black tree for **efficient interval-based queries**.

- Store closed intervals [low, high] ordered by low (BST property)
- Augment each node with **max** = maximum high in its subtree (including itself)

```text
max[x] = max(high[x], max[x.left], max[x.right])
max[NIL] = -‚àû
```

This allows queries like: Given [i, j], find any stored interval that overlaps with [i, j].

**Overlap condition:**

```text
[a,b] overlaps [c,d] ‚áî a ‚â§ d and c ‚â§ b
```

### Maintaining max Field

- Rotation ‚Üí recompute max of affected nodes (O(1))
- Insert/Delete ‚Üí update max along path to root (O(log n))
- Similar to maintaining size in order-statistic trees

### Core Query: INTERVAL-SEARCH

**Goal:** find any interval overlapping [l, h]

```text
INTERVAL-SEARCH(T, i)
    x ‚Üê T.root
    while x ‚â† T.NIL and !OVERLAP(x.interval, i)
        if x.left ‚â† T.NIL and x.left.max ‚â• i.low
            x ‚Üê x.left
        else
            x ‚Üê x.right
    return x

OVERLAP([l1,h1],[l2,h2])
    return l1 ‚â§ h2 and l2 ‚â§ h1
```

**Why it works:**

- If x overlaps ‚Üí return
- Else:
  - If left.max ‚â• query.low ‚Üí go left
  - Else ‚Üí go right
- Always finds **some overlapping interval** if exists
- **Time:** O(log n)

### TypeScript Implementation

```typescript
enum Color {
  RED = "RED",
  BLACK = "BLACK",
}

class IntervalNode {
  low: number;
  high: number;
  max: number;
  color: Color;
  left: IntervalNode | null = null;
  right: IntervalNode | null = null;
  parent: IntervalNode | null = null;

  constructor(low: number, high: number) {
    this.low = low;
    this.high = high;
    this.max = high;
    this.color = Color.RED;
  }

  updateMax(): void {
    this.max = this.high;
    if (this.left) this.max = Math.max(this.max, this.left.max);
    if (this.right) this.max = Math.max(this.max, this.right.max);
  }
}

class IntervalTree {
  root: IntervalNode | null = null;
  NIL: IntervalNode;

  constructor() {
    this.NIL = new IntervalNode(-Infinity, -Infinity);
    this.NIL.color = Color.BLACK;
    this.NIL.max = -Infinity;
    this.root = this.NIL;
  }

  insert(low: number, high: number): void {
    const z = new IntervalNode(low, high);
    z.left = z.right = this.NIL;

    let y: IntervalNode | null = this.NIL;
    let x = this.root;

    while (x !== this.NIL) {
      y = x;
      x = low < x.low ? x.left! : x.right!;
    }

    z.parent = y;
    if (y === this.NIL) this.root = z;
    else if (low < y.low) y.left = z;
    else y.right = z;

    this.updateMaxPath(z);
  }

  private updateMaxPath(node: IntervalNode): void {
    while (node !== this.NIL) {
      node.updateMax();
      node = node.parent!;
    }
  }

  search(low: number, high: number): IntervalNode | null {
    let x = this.root;
    while (x !== this.NIL && !(low <= x.high && x.low <= high)) {
      if (x.left !== this.NIL && x.left!.max >= low) x = x.left!;
      else x = x.right!;
    }
    return x === this.NIL ? null : x;
  }

  inorder(node: IntervalNode | null = this.root): [number, number][] {
    const res: [number, number][] = [];
    if (node && node !== this.NIL) {
      res.push(...this.inorder(node.left));
      res.push([node.low, node.high]);
      res.push(...this.inorder(node.right));
    }
    return res;
  }
}

// ‚îÄ‚îÄ Demo ‚îÄ‚îÄ
const it = new IntervalTree();
[
  it.insert(15, 20),
  it.insert(10, 30),
  it.insert(17, 19),
  it.insert(5, 20),
  it.insert(12, 15),
  it.insert(30, 40),
];
console.log("Intervals (sorted by low):", it.inorder());
const overlap = it.search(16, 22);
console.log(
  "Overlapping with [16,22]:",
  overlap ? [overlap.low, overlap.high] : null,
);
```

### Important Notes

- Each node stores **max high** in subtree
- Updates along path to root after insert/delete: O(log n)
- Rotations recompute max of affected nodes: O(1)
- INTERVAL-SEARCH: find overlapping interval in O(log n)
- Real-world use: computational geometry, range queries, scheduling, collision detection

> **Key Takeaway:** Interval trees augment red-black trees with a max-high field to find overlapping intervals in O(log n), while maintaining insert/delete efficiency.
