# 13. Red-Black Trees

## üìã Chapter Overview

| Section  | Topic      | Key Idea                           |
| -------- | ---------- | ---------------------------------- |
| **13.1** | Properties | Five rules + black-height          |
| **13.2** | Rotations  | Local restructuring in O(1)        |
| **13.3** | Insertion  | Fix-up with color flips/rotations  |
| **13.4** | Deletion   | Fix-up for black-height violations |

---

## 13.1 Properties of Red-Black Trees

### Overview

Red-black trees are **self-balancing binary search trees** ensuring **O(log n)** worst-case time for search, insert, and delete operations. Balance is maintained through node coloring (red or black).

---

### 1. Definition & Coloring Rules (5 Properties)

A red-black tree is a BST with these additional properties:

1. Every node is either red or black.
2. Root is always black.
3. Every leaf (NIL) is black.
4. If a node is red, both its children are black (no two reds adjacent).
5. All paths from a node to its descendant leaves contain the same number of black nodes (black-height).

These rules prevent the tree from becoming too unbalanced.

---

### 2. Black-Height Definition

**Black-height (bh(x))**: number of black nodes on any simple path from node `x` (excluding `x`) to a leaf.

- Well-defined due to property 5

**Lemma:** A red-black tree with `n` internal nodes has height ‚â§ `2 log‚ÇÇ(n+1)` ‚Üí guarantees `O(log n)` operations.

---

### 3. Why These Rules Prevent Long Chains

These properties work together to maintain balance:

- **Property 4** prevents long chains of red nodes (alternating pattern required)
- **Property 5** forces balance in terms of black nodes across all paths
- **Result:** Longest path ‚â§ roughly twice the shortest path

---

### 4. Visual Example

```
        7(b)
       /    \
    3(b)    18(b)
   /  \     /   \
 1(r) 5(r) 15(r) 20(b)
 /              /
NIL            17(r)
```

- Root black
- No two reds adjacent
- All root-to-leaf paths have 2 black nodes (black-height = 2)

---

### 5. TypeScript Node Structure

```ts
enum Color {
  RED = "RED",
  BLACK = "BLACK",
}

class RBNode {
  key: number;
  color: Color;
  left: RBNode | null = null;
  right: RBNode | null = null;
  parent: RBNode | null = null;

  constructor(key: number, color: Color = Color.RED) {
    this.key = key;
    this.color = color;
  }
}

class RedBlackTree {
  root: RBNode | null = null;

  insert(key: number): void {
    const node = new RBNode(key, Color.RED);
    // Standard BST insert (no balancing yet)
    // Fixup would be called here in full implementation
  }

  inorder(node: RBNode | null = this.root): number[] {
    const res: number[] = [];
    if (node) {
      res.push(...this.inorder(node.left));
      res.push(node.key);
      res.push(...this.inorder(node.right));
    }
    return res;
  }
}

// ‚îÄ‚îÄ Demo ‚îÄ‚îÄ
const rbt = new RedBlackTree();
// Insertions would go here in real code
```

---

### Important Notes

- Red-black trees are approximately balanced, not perfect
- Black-height guarantees height ‚â§ `2 log‚ÇÇ(n+1)`
- All valid red-black trees satisfy the 5 properties
- Properties are maintained via rotations and color flips during insert/delete
- Many standard libraries use red-black trees (Java TreeMap, C++ std::map, Python sortedcontainers)

**Key Takeaway:**
Red-black trees enforce balance via coloring rules, ensuring worst-case `O(log n)` operations without perfect height equality.

---

## 13.2 Rotations

### Overview

Rotations are local restructuring operations in self-balancing BSTs (red-black, AVL, splay trees) that maintain balance after insertions/deletions. They preserve in-order traversal and are `O(1)` time operations.

**Types:**

- Left rotation (on node x)
- Right rotation (on node y)

**Purpose:** Adjust tree height locally to reduce unbalanced chains without violating BST property.

---

### 1. Right Rotation (on node y)

Performed when left subtree of `y` is too tall.

**Before:**

```
      y
     /
    x
   / \
  a   b
```

**After:**

```
      x
     / \
    a   y
       / \
      b   c
```

**Pseudocode:**

```text
RIGHT-ROTATE(T, y)
    x ‚Üê y.left
    y.left ‚Üê x.right
    if x.right ‚â† NIL
        x.right.p ‚Üê y
    x.p ‚Üê y.p
    if y.p = NIL
        T.root ‚Üê x
    else if y = y.p.left
        y.p.left ‚Üê x
    else
        y.p.right ‚Üê x
    x.right ‚Üê y
    y.p ‚Üê x
```

---

### 2. Left Rotation (on node x)

Mirror of right rotation, used when right subtree of `x` is too tall.

**Before:**

```
    x
     \
      y
     / \
    b   c
```

**After:**

```
      y
     / \
    x   c
   / \
  a   b
```

**Pseudocode:**

```text
LEFT-ROTATE(T, x)
    y ‚Üê x.right
    x.right ‚Üê y.left
    if y.left ‚â† NIL
        y.left.p ‚Üê x
    y.p ‚Üê x.p
    if x.p = NIL
        T.root ‚Üê y
    else if x = x.p.left
        x.p.left ‚Üê y
    else
        x.p.right ‚Üê y
    y.left ‚Üê x
    x.p ‚Üê y
```

---

### TypeScript Implementation

```ts
class TreeNode {
  key: number;
  color: "RED" | "BLACK";
  left: TreeNode | null = null;
  right: TreeNode | null = null;
  parent: TreeNode | null = null;

  constructor(key: number, color: "RED" | "BLACK" = "RED") {
    this.key = key;
    this.color = color;
  }
}

class RedBlackTree {
  root: TreeNode | null = null;

  rightRotate(y: TreeNode): void {
    const x = y.left!;
    y.left = x.right;
    if (x.right) x.right.parent = y;
    x.parent = y.parent;
    if (!y.parent) this.root = x;
    else if (y === y.parent.left) y.parent.left = x;
    else y.parent.right = x;
    x.right = y;
    y.parent = x;
  }

  leftRotate(x: TreeNode): void {
    const y = x.right!;
    x.right = y.left;
    if (y.left) y.left.parent = x;
    y.parent = x.parent;
    if (!x.parent) this.root = y;
    else if (x === x.parent.left) x.parent.left = y;
    else x.parent.right = y;
    y.left = x;
    x.parent = y;
  }

  insert(key: number): void {
    const node = new TreeNode(key, "RED");
    if (!this.root) {
      this.root = node;
      node.color = "BLACK";
      return;
    }
    let curr: TreeNode | null = this.root,
      par: TreeNode | null = null;
    while (curr) {
      par = curr;
      curr = key < curr.key ? curr.left : curr.right;
    }
    node.parent = par;
    if (key < par!.key) par!.left = node;
    else par!.right = node;
    // Color fix & rotations would go here (13.3)
  }

  inorder(node: TreeNode | null = this.root): number[] {
    if (!node) return [];
    return [...this.inorder(node.left), node.key, ...this.inorder(node.right)];
  }
}

// ‚îÄ‚îÄ Demo ‚îÄ‚îÄ
const rbt = new RedBlackTree();
rbt.insert(19);
rbt.insert(12);
rbt.insert(25);
console.log("Inorder:", rbt.inorder());
```

---

### Important Notes

- Rotations preserve in-order traversal (BST property intact)
- Constant number of pointer changes ‚Üí `O(1)` per rotation
- Used in insert/delete fixup to maintain red-black properties
- Right rotation is mirror of le

## 13.3 Insertion

### Overview

Red-black tree insertion combines **standard BST insertion** with a **fixup phase**:

1. Insert using standard BST algorithm
2. Color new node **red**
3. Run **RB-INSERT-FIXUP** to restore red-black properties

Fixup may involve **color flips** and **rotations** to resolve violations.

---

### Step-by-Step Process

1. Insert new node `z` using standard BST insertion (`O(log n)`)
   - `z` is always colored red

2. If tree was empty ‚Üí color root black and done
3. Otherwise ‚Üí run `RB-INSERT-FIXUP` to fix violations

**Three fixup cases based on uncle color and z's position:**

| Case  | Condition                                          | Action                                         |
| ----- | -------------------------------------------------- | ---------------------------------------------- |
| **1** | Uncle is **RED**                                   | Color flip ‚Äî push violation up tree            |
| **2** | Uncle is **BLACK**, z is right child of left child | Rotate left, transition to Case 3              |
| **3** | Uncle is **BLACK**, z is left child of left child  | Rotate right + color flip ‚Äî violation resolved |

After fixup, **root is always black**.

---

### Pseudocode

```text
RB-INSERT(T, z)
    y ‚Üê NIL
    x ‚Üê T.root
    while x ‚â† T.NIL
        y ‚Üê x
        if z.key < x.key
            x ‚Üê x.left
        else
            x ‚Üê x.right
    z.p ‚Üê y
    if y = T.NIL
        T.root ‚Üê z
    else if z.key < y.key
        y.left ‚Üê z
    else
        y.right ‚Üê z
    z.left ‚Üê T.NIL
    z.right ‚Üê T.NIL
    z.color ‚Üê RED
    RB-INSERT-FIXUP(T, z)

RB-INSERT-FIXUP(T, z)
    while z.p.color = RED
        if z.p = z.p.p.left
            y ‚Üê z.p.p.right                     // uncle
            if y.color = RED                     // Case 1
                z.p.color ‚Üê BLACK
                y.color ‚Üê BLACK
                z.p.p.color ‚Üê RED
                z ‚Üê z.p.p
            else
                if z = z.p.right                 // Case 2
                    z ‚Üê z.p
                    LEFT-ROTATE(T, z)
                z.p.color ‚Üê BLACK                 // Case 3
                z.p.p.color ‚Üê RED
                RIGHT-ROTATE(T, z.p.p)
        else (symmetric to then clause)
    T.root.color ‚Üê BLACK
```

---

### TypeScript Implementation

```ts
enum Color {
  RED = "RED",
  BLACK = "BLACK",
}

class RBNode {
  key: number;
  color: Color;
  left: RBNode | null = null;
  right: RBNode | null = null;
  parent: RBNode | null = null;

  constructor(key: number) {
    this.key = key;
    this.color = Color.RED;
  }
}

class RedBlackTree {
  root: RBNode | null = null;
  NIL: RBNode = new RBNode(0);

  constructor() {
    this.NIL.color = Color.BLACK;
    this.root = this.NIL;
  }

  insert(key: number): void {
    const z = new RBNode(key);
    z.left = z.right = this.NIL;

    let y: RBNode | null = this.NIL;
    let x = this.root;

    while (x !== this.NIL) {
      y = x;
      x = z.key < x.key ? x.left! : x.right!;
    }

    z.parent = y;
    if (y === this.NIL) this.root = z;
    else if (z.key < y.key) y.left = z;
    else y.right = z;

    this.insertFixup(z);
  }

  private insertFixup(z: RBNode): void {
    while (z.parent && z.parent.color === Color.RED) {
      if (z.parent === z.parent.parent?.left) {
        const y = z.parent.parent.right!;
        if (y.color === Color.RED) {
          z.parent.color = Color.BLACK;
          y.color = Color.BLACK;
          z.parent.parent.color = Color.RED;
          z = z.parent.parent;
        } else {
          if (z === z.parent.right) {
            z = z.parent;
            this.leftRotate(z);
          }
          z.parent!.color = Color.BLACK;
          z.parent!.parent!.color = Color.RED;
          this.rightRotate(z.parent!.parent!);
        }
      } else {
        const y = z.parent.parent!.left!;
        if (y.color === Color.RED) {
          z.parent.color = Color.BLACK;
          y.color = Color.BLACK;
          z.parent.parent!.color = Color.RED;
          z = z.parent.parent!;
        } else {
          if (z === z.parent.left) {
            z = z.parent;
            this.rightRotate(z);
          }
          z.parent!.color = Color.BLACK;
          z.parent!.parent!.color = Color.RED;
          this.leftRotate(z.parent!.parent!);
        }
      }
    }
    this.root!.color = Color.BLACK;
  }

  private leftRotate(x: RBNode): void {
    /* same as 13.2 */
  }
  private rightRotate(y: RBNode): void {
    /* same as 13.2 */
  }

  inorder(node: RBNode | null = this.root): number[] {
    if (!node || node === this.NIL) return [];
    return [...this.inorder(node.left), node.key, ...this.inorder(node.right)];
  }
}

const rbt = new RedBlackTree();
[19, 12, 25, 5, 15, 22, 30, 8].forEach((k) => rbt.insert(k));
console.log("Inorder (sorted):", rbt.inorder());
// ‚Üí [5, 8, 12, 15, 19, 22, 25, 30]
```

---

### Important Notes

- New node always red
- Fixup may perform up to `O(log n)` rotations/color flips
- Root always black
- Maintains all 5 red-black properties
- Tree remains balanced ‚Üí worst-case insertion `O(log n)`

**Key Takeaway:**
Red-black insertion uses sta

**13.4 Deletion**
_(Introduction to Algorithms, 4th Edition ‚Äì CLRS)_

Deletion in red-black trees is more complex than insertion because removing a node can violate the red-black properties (especially the black-height property), and we may need to propagate fixes up the tree.
The deletion algorithm follows standard BST deletion but adds a fixup step to restore the red-black invariants.

---

### Step-by-Step Process

**Phase 1: Standard BST Deletion**

1. Find node `z` to delete
2. **One child or less:** Replace `z` with child/NIL
3. **Two children:** Replace `z` with successor `y` (minimum in right subtree), then delete `y`

**Phase 2: Fixup (if deleted node was black)**

- Run `RB-DELETE-FIXUP` to restore properties
- May require rotations, color changes
- Propagates double-black violation up tree until resolved

**Key insight:** We track a "double-black" node (`x`) during fixup to handle black-height violations.

---

### Pseudocode

```text
RB-DELETE(T, z)
    y ‚Üê z
    y-original-color ‚Üê y.color

    if z.left = T.NIL
        x ‚Üê z.right
        TRANSPLANT(T, z, z.right)
    else if z.right = T.NIL
        x ‚Üê z.left
        TRANSPLANT(T, z, z.left)
    else
        y ‚Üê TREE-MINIMUM(z.right)
        y-original-color ‚Üê y.color
        x ‚Üê y.right

        if y.p = z
            x.p ‚Üê y
        else
            TRANSPLANT(T, y, y.right)
            y.right ‚Üê z.right
            y.right.p ‚Üê y

        TRANSPLANT(T, z, y)
        y.left ‚Üê z.left
        y.left.p ‚Üê y
        y.color ‚Üê z.color

    if y-original-color = BLACK
        RB-DELETE-FIXUP(T, x)
```

### RB-DELETE-FIXUP: Handling Double-Black Violation

The fixup procedure handles a double-black node `x` by examining its sibling `w`:

```text
RB-DELETE-FIXUP(T, x)
    while x ‚â† T.root and x.color = BLACK
        if x = x.p.left
            w ‚Üê x.p.right                        // sibling

            if w.color = RED                     // Case 1: Red sibling
                w.color ‚Üê BLACK
                x.p.color ‚Üê RED
                LEFT-ROTATE(T, x.p)
                w ‚Üê x.p.right

            if w.left.color = BLACK and w.right.color = BLACK  // Case 2: Black sibling, both children black
                w.color ‚Üê RED
                x ‚Üê x.p
            else
                if w.right.color = BLACK         // Case 3: Black sibling, right child black
                    w.left.color ‚Üê BLACK
                    w.color ‚Üê RED
                    RIGHT-ROTATE(T, w)
                    w ‚Üê x.p.right

                // Case 4: Black sibling, right child red
                w.color ‚Üê x.p.color
                x.p.color ‚Üê BLACK
                w.right.color ‚Üê BLACK
                LEFT-ROTATE(T, x.p)
                x ‚Üê T.root
        else
            // Symmetric (mirror image) of then clause
    x.color ‚Üê BLACK
```

---

### TypeScript Code (Deletion + Fixup Skeleton)

```ts
class RBNode {
  key: number;
  color: "RED" | "BLACK";
  left: RBNode | null = null;
  right: RBNode | null = null;
  parent: RBNode | null = null;

  constructor(key: number, color: "RED" | "BLACK" = "RED") {
    this.key = key;
    this.color = color;
  }
}

class RedBlackTree {
  root: RBNode | null = null;
  NIL: RBNode;

  constructor() {
    this.NIL = new RBNode(0, "BLACK");
    this.root = this.NIL;
  }

  delete(key: number): boolean {
    const z = this.search(key);
    if (z === this.NIL) return false;

    this.rbDelete(z);
    return true;
  }

  private rbDelete(z: RBNode): void {
    let y = z;
    let yOriginalColor = y.color;
    let x: RBNode;

    if (z.left === this.NIL) {
      x = z.right;
      this.transplant(z, z.right);
    } else if (z.right === this.NIL) {
      x = z.left;
      this.transplant(z, z.left);
    } else {
      y = this.minimum(z.right)!;
      yOriginalColor = y.color;
      x = y.right;

      if (y.parent === z) {
        x.parent = y;
      } else {
        this.transplant(y, y.right);
        y.right = z.right;
        y.right!.parent = y;
      }

      this.transplant(z, y);
      y.left = z.left;
      y.left!.parent = y;
      y.color = z.color;
    }

    if (yOriginalColor === "BLACK") {
      this.rbDeleteFixup(x);
    }
  }

  private rbDeleteFixup(x: RBNode): void {
    while (x !== this.root && x.color === "BLACK") {
      if (x === x.parent!.left) {
        let w = x.parent!.right!;

        if (w.color === "RED") {
          // Case 1
          w.color = "BLACK";
          x.parent!.color = "RED";
          this.leftRotate(x.parent!);
          w = x.parent!.right!;
        }

        if (w.left!.color === "BLACK" && w.right!.color === "BLACK") {
          // Case 2
          w.color = "RED";
          x = x.parent!;
        } else {
          if (w.right!.color === "BLACK") {
            // Case 3
            w.left!.color = "BLACK";
            w.color = "RED";
            this.rightRotate(w);
            w = x.parent!.right!;
          }
          // Case 4
          w.color = x.parent!.color;
          x.parent!.color = "BLACK";
          w.right!.color = "BLACK";
          this.leftRotate(x.parent!);
          x = this.root!;
        }
      } else {
        // Symmetric (mirror image) ‚Äî omitted for brevity
      }
    }
    x.color = "BLACK";
  }

  private transplant(u: RBNode, v: RBNode | null): void {
    if (u.parent === this.NIL) {
      this.root = v;
    } else if (u === u.parent!.left) {
      u.parent!.left = v;
    } else {
      u.parent!.right = v;
    }
    if (v) v.parent = u.parent;
  }
}
```

---

### Important Notes

- Deletion is harder than insertion because removing a black node decreases black-height
- We use a double-black concept (`x` is extra black) during fixup
- Fixup may propagate up to the root (O(log n) steps)
- Rotations (left/right) and color changes are used to resolve violations
- Root is always re-colored black at the end
- Worst-case time remains O(log n) ‚Äî balance is preserved

---

### Key Takeaway

Red-black tree deletion follows standard BST deletion but adds a fixup phase to handle black-height violations using rotations and color flips.
The fixup ensures the tree stays a valid red-black tree and maintains O(log n) height in worst case.
