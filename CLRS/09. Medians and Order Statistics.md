# 9. Medians and Order Statistics

## üìã Chapter Overview

| Section | Topic                   | Key Idea                                 |
| ------- | ----------------------- | ---------------------------------------- |
| **9.1** | Minimum & maximum       | Pairwise comparisons reduce total checks |
| **9.2** | Randomized selection    | Expected O(n) with one-sided recursion   |
| **9.3** | Deterministic selection | Worst-case O(n) via median-of-medians    |

---

## 9.1 Minimum and maximum

This section shows how to find both the **minimum and maximum elements** in an array of n elements using as few comparisons as possible.

### Naive approach (obvious but not optimal)

```text
FIND-MIN-AND-MAX-NAIVE(A, n)
    min = A[1]
    max = A[1]
    for i = 2 to n
        if A[i] < min
            min = A[i]
        if A[i] > max
            max = A[i]
    return (min, max)
```

- **Number of comparisons:** 2(n‚àí1)
- Each element (except first) is compared twice ‚Äî once with min, once with max.

### Optimal approach: Pairwise comparison (best possible)

- **Reduces comparisons to** ‚åà3n/2‚åâ ‚àí 2 (for n ‚â• 2)
- **Key idea:**
  - Process the array in pairs of elements.
  - Compare the two elements of a pair first ‚Üí then compare the smaller one with current min, and the larger one with current max.
  - Each pair requires only 3 comparisons (instead of 4).

### Pseudocode ‚Äì Optimal MIN-MAX (pairwise)

```text
FIND-MIN-AND-MAX(A, n)
    if n = 1
        return (A[1], A[1])

    // Initialize min and max with first two elements
    if A[1] < A[2]
        min = A[1], max = A[2]
    else
        min = A[2], max = A[1]

    // Process remaining elements in pairs
    for i = 3 to n step 2
        if A[i] < A[i+1]
            if A[i] < min
                min = A[i]
            if A[i+1] > max
                max = A[i+1]
        else
            if A[i+1] < min
                min = A[i+1]
            if A[i] > max
                max = A[i]

    return (min, max)
```

### Number of comparisons

- 1 comparison to initialize min/max with first two elements
- For each of the remaining ‚åä(n‚àí2)/2‚åã pairs ‚Üí 3 comparisons
- **Total = 3‚åä(n‚àí2)/2‚åã + 1**
- When n is even ‚Üí 3n/2 ‚àí 2
- When n is odd ‚Üí 3(n‚àí1)/2 ‚àí 2 + 1 (last element needs 2 more comparisons)
- **‚âà ‚åà3n/2‚åâ ‚àí 2 (optimal)**

---

### TypeScript code ‚Äì Optimal pairwise min-max

```ts
/**
 * Finds both minimum and maximum in an array using ~3n/2 comparisons
 * @param arr - array of numbers
 * @returns [min, max]
 */
function findMinAndMax(arr: number[]): [number, number] {
  const n = arr.length;
  if (n === 0) throw new Error("Array is empty");
  if (n === 1) return [arr[0], arr[0]];

  let min: number, max: number;

  // Step 1: Initialize with first two elements
  if (arr[0] < arr[1]) {
    min = arr[0];
    max = arr[1];
  } else {
    min = arr[1];
    max = arr[0];
  }

  // Step 2: Process remaining elements in pairs
  for (let i = 2; i < n; i += 2) {
    if (i + 1 < n) {
      let localMin: number, localMax: number;

      if (arr[i] < arr[i + 1]) {
        localMin = arr[i];
        localMax = arr[i + 1];
      } else {
        localMin = arr[i + 1];
        localMax = arr[i];
      }

      if (localMin < min) min = localMin;
      if (localMax > max) max = localMax;
    } else {
      if (arr[i] < min) min = arr[i];
      if (arr[i] > max) max = arr[i];
    }
  }

  return [min, max];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example usage
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const numbers = [64, 34, 25, 12, 22, 11, 90, 5, 47];
const [minVal, maxVal] = findMinAndMax(numbers);
console.log("Array:", numbers);
console.log("Minimum:", minVal); // 5
console.log("Maximum:", maxVal); // 90
```

### Summary Table ‚Äì Min & Max Finding

| Method             | Comparisons (worst case) | Notes                                      |
| ------------------ | ------------------------ | ------------------------------------------ |
| Naive (two passes) | 2(n‚àí1)                   | Simple, but wasteful                       |
| Pairwise (optimal) | ‚åà3n/2‚åâ ‚àí 2               | Best possible for comparison-based method  |
| Tournament method  | n ‚àí 1 + ‚åàlog‚ÇÇ n‚åâ         | Also very good, used in selection problems |

### Key Takeaway

> Finding both min and max can be done with **fewer than 2n comparisons** using pairwise processing: **‚âà ‚åà3n/2‚åâ ‚àí 2**, which is optimal.

---

## 9.2 Selection in expected linear time

This section presents the **Randomized-Select algorithm** ‚Äî a randomized method to find the k-th smallest (or largest) element in an unsorted array in **expected O(n) time**.

### The Selection Problem

- **Input:**
  - Array A of n distinct numbers
  - Integer k (1 ‚â§ k ‚â§ n)

- **Output:** k-th smallest element in A (element in position k if A were sorted)
- **Goal:** Faster than sorting the whole array (Œò(n log n))

### Core Idea ‚Äì Randomized-Select

1. Choose a random pivot (like randomized quicksort)
2. Partition array around pivot (using PARTITION)
3. Let q = pivot's final position
4. Compare q with k:
   - If q == k ‚Üí return A[q]
   - If q > k ‚Üí recurse left
   - If q < k ‚Üí recurse right (adjust k ‚Üê k - q)

> Only recurse on one side ‚Üí expected running time linear.

### Pseudocode (CLRS style ‚Äì 1-based indexing)

```text
RANDOMIZED-SELECT(A, p, r, k)
    if p = r
        return A[p]

    q ‚Üê RANDOMIZED-PARTITION(A, p, r)

    i ‚Üê q - p + 1  // elements ‚â§ pivot

    if k = i
        return A[q]
    else if k < i
        return RANDOMIZED-SELECT(A, p, q-1, k)
    else
        return RANDOMIZED-SELECT(A, q+1, r, k - i)
```

---

### TypeScript code (0-based indexing)

```ts
/**
 * Finds the k-th smallest element in the array (1-based k)
 * Expected running time: O(n)
 */
function randomizedSelect(arr: number[], k: number): number {
  if (k < 1 || k > arr.length) throw new Error("Invalid k");
  const copy = [...arr];
  return randomizedSelectHelper(copy, 0, copy.length - 1, k);
}

function randomizedSelectHelper(
  arr: number[],
  low: number,
  high: number,
  k: number,
): number {
  if (low === high) return arr[low];

  const pivotIndex = randomizedPartition(arr, low, high);
  const leftCount = pivotIndex - low + 1;

  if (k === leftCount) return arr[pivotIndex];
  else if (k < leftCount)
    return randomizedSelectHelper(arr, low, pivotIndex - 1, k);
  else return randomizedSelectHelper(arr, pivotIndex + 1, high, k - leftCount);
}

function randomizedPartition(arr: number[], low: number, high: number): number {
  const randomIndex = low + Math.floor(Math.random() * (high - low + 1));
  [arr[randomIndex], arr[high]] = [arr[high], arr[randomIndex]];

  const pivot = arr[high];
  let i = low - 1;

  for (let j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
  return i + 1;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example usage
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const numbers = [64, 34, 25, 12, 22, 11, 90, 5, 47];
console.log("Array:", numbers);
const k = 3;
console.log(`${k}-th smallest:`, randomizedSelect(numbers, k)); // Expected: 12
```

---

### Expected Running Time Analysis (High-Level)

- Pivot is chosen uniformly at random
- Unbalanced partitions are unlikely
- Subproblem size decreases geometrically
- Expected number of recursion levels O(log n), each level costs O(n) total work
- ‚Üí Overall expected time = O(n)

> Rigorous proof in CLRS uses recurrence and indicator variables, similar to quicksort analysis.

---

### Summary Table ‚Äì Randomized-Select

| Property          | Value / Note                           |
| ----------------- | -------------------------------------- |
| Expected time     | O(n)                                   |
| Worst-case time   | O(n¬≤) (very unlikely)                  |
| Space             | O(log n) expected recursion depth      |
| In-place?         | Yes (with in-place partition)          |
| Comparison-based? | Yes                                    |
| Best used when    | Need k-th element without full sorting |
| Real-world name   | Quickselect (common in libraries)      |

---

### Key Takeaway

> Randomized-Select finds the k-th smallest element in **expected linear time**, much faster than full sorting when only one order statistic is needed (e.g., median: k = ‚åàn/2‚åâ).

---

## 9.3 Selection in worst-case linear time

This section presents a **deterministic algorithm** to find the k-th smallest element in an unsorted array in **worst-case O(n) time**.

### Names

- Median-of-medians algorithm
- BFPRT algorithm (Blum‚ÄìFloyd‚ÄìPratt‚ÄìRivest‚ÄìTarjan)
- SELECT algorithm

> Guarantees linear worst-case time, unlike randomized-select.

### Core Idea ‚Äì Good Pivot

- Bad pivots in quickselect ‚Üí unbalanced ‚Üí O(n¬≤)
- Median-of-medians chooses a **provably good pivot**:
  - Subproblem ‚â§ 70% of original size

**How to find pivot**:

1. Divide n elements into groups of 5
2. Find median of each group (sort 5 elements ‚Üí O(1))
3. Recursively find median of medians ‚Üí pivot
4. Partition around pivot
5. Recurse into the side containing k-th element

> Pivot is >30% and <30% of elements ‚Üí larger subproblem ‚â§ 70% n

### Recurrence Relation

```
T(n) = T(‚åàn/5‚åâ) + T(7n/10 + 6) + O(n)
```

- T(‚åàn/5‚åâ) ‚Üí median-of-medians
- T(7n/10 + 6) ‚Üí larger subproblem
- O(n) ‚Üí partitioning

Solves to T(n) = O(n)

### Pseudocode ‚Äì SELECT (median-of-medians)

```text
SELECT(A, p, r, k)
    if p = r
        return A[p]

    x ‚Üê MEDIAN-OF-MEDIANS(A, p, r)
    q ‚Üê PARTITION(A, p, r, x)

    i ‚Üê q - p + 1
    if k = i return A[q]
    else if k < i return SELECT(A, p, q-1, k)
    else return SELECT(A, q+1, r, k-i)
```

```text
MEDIAN-OF-MEDIANS(A, p, r)
    n ‚Üê r - p + 1
    if n ‚â§ 5
        sort A[p..r]
        return A[p + ‚åän/2‚åã]

    for i = 0 to ‚åän/5‚åã - 1
        sort group A[p+5i .. p+5i+4]
        put median into M

    return MEDIAN-OF-MEDIANS(M, 1, ‚åàn/5‚åâ)
```

---

### TypeScript ‚Äì Simplified Version (Conceptual)

```ts
function selectWorstCaseLinear(arr: number[], k: number): number {
  const copy = [...arr];
  return selectHelper(copy, 0, copy.length - 1, k);
}

function selectHelper(
  arr: number[],
  low: number,
  high: number,
  k: number,
): number {
  if (low === high) return arr[low];

  const pivotIndex = medianOfMedians(arr, low, high);
  const pivot = arr[pivotIndex];

  const q = partitionAroundValue(arr, low, high, pivot);
  const leftCount = q - low + 1;

  if (k === leftCount) return arr[q];
  if (k < leftCount) return selectHelper(arr, low, q - 1, k);
  return selectHelper(arr, q + 1, high, k - leftCount);
}

function medianOfMedians(arr: number[], low: number, high: number): number {
  const n = high - low + 1;
  if (n <= 5) {
    const temp = arr.slice(low, high + 1).sort((a, b) => a - b);
    return low + Math.floor(n / 2);
  }
  return low + Math.floor(n / 2); // simplified approximation
}

function partitionAroundValue(
  arr: number[],
  low: number,
  high: number,
  pivot: number,
): number {
  let i = low - 1;
  for (let j = low; j <= high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  return i;
}
```

> Full production implementation handles groups of 5, recursive calls, and indexing carefully. Most libraries use randomized version for simplicity.

### Summary Table ‚Äì Selection Algorithms Comparison

| Algorithm               | Worst-case time | Expected time | Deterministic? | Practical use |
| ----------------------- | --------------- | ------------- | -------------- | ------------- |
| Naive sort then pick    | Œò(n log n)      | Œò(n log n)    | Yes            | Simple        |
| Randomized-Select (9.2) | O(n¬≤)           | O(n)          | No             | Very common   |
| Median-of-Medians (9.3) | O(n)            | O(n)          | Yes            | Rarely used   |

### Key Takeaway

> Median-of-medians gives **deterministic linear-time selection** ‚Äî a beautiful theoretical result proving worst-case linear-time selection is possible with comparisons.
