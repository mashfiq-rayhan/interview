# 10. Elementary Data Structures

## üìã Chapter Overview

| Section  | Topic                            | Key Idea                             |
| -------- | -------------------------------- | ------------------------------------ |
| **10.1** | Arrays, matrices, stacks, queues | Array-based building blocks          |
| **10.2** | Linked lists                     | Dynamic insertion/deletion           |
| **10.3** | Rooted trees                     | Space-efficient tree representations |

---

## 10.1 Simple array-based data structures: arrays, matrices, stacks, queues

This subsection reviews the most basic and frequently used data structures that are implemented directly using arrays (fixed-size or dynamic).
They form the foundation for almost every non-trivial algorithm and data structure we will see later.

---

### 1. Arrays

### Definition

A contiguous block of memory locations, each holding one element of the same type.
Indexed usually from 0 (most languages) or 1 (CLRS convention).

### Operations (typical time complexity)

| Operation         | Time Complexity | Notes                          |
| ----------------- | --------------- | ------------------------------ |
| Access by index   | O(1)            | Direct memory calculation      |
| Update by index   | O(1)            | Same as access                 |
| Search (unsorted) | O(n)            | Linear scan                    |
| Search (sorted)   | O(log n)        | Binary search                  |
| Insert / Delete   | O(n)            | Shift elements (unless at end) |

### Pseudocode ‚Äì Basic array access & update

```pseudocode
// 1-based indexing (CLRS style)
ACCESS(A, i)
    return A[i]

UPDATE(A, i, x)
    A[i] ‚Üê x
```

### TypeScript code

```ts
// 0-based indexing ‚Äì standard in JS/TS
const arr: number[] = [10, 20, 30, 40, 50];

// Access
console.log(arr[2]); // 30                ‚Üí O(1)

// Update
arr[2] = 999;
console.log(arr); // [10, 20, 999, 40, 50]

// Linear search (unsorted)
function findIndex(arr: number[], target: number): number {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}

console.log(findIndex(arr, 999)); // 2
```

---

### 2. Matrices (2D arrays)

### Definition

A rectangular array ‚Äî m rows √ó n columns.
Stored in memory either row-major or column-major order.

### Common operations

| Operation             | Time Complexity | Notes                                          |
| --------------------- | --------------- | ---------------------------------------------- |
| Access (i,j)          | O(1)            | Single arithmetic operation                    |
| Row/column traversal  | O(n) or O(m)    | Depends on dimension                           |
| Matrix addition       | O(mn)           | Element-wise                                   |
| Matrix multiplication | O(mnp)          | Naive method (later improved by Strassen etc.) |

### Pseudocode ‚Äì Matrix access & multiplication (naive)

```pseudocode
MATRIX-ACCESS(M, i, j)        // 1-based
    return M[i][j]

NAIVE-MATRIX-MULTIPLY(A, B, m, p, n)   // A is m√óp, B is p√ón
    let C be new m√ón matrix
    for i = 1 to m
        for j = 1 to n
            C[i][j] ‚Üê 0
            for k = 1 to p
                C[i][j] ‚Üê C[i][j] + A[i][k] √ó B[k][j]
    return C
```

### TypeScript code ‚Äì 2D array & naive multiplication

```ts
// Matrix as array of arrays
const matrix: number[][] = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

// Access
console.log(matrix[1][2]); // 6

// Naive matrix multiplication
function matrixMultiply(A: number[][], B: number[][]): number[][] {
  const m = A.length;
  const p = A[0].length;
  const n = B[0].length;

  const C: number[][] = Array(m)
    .fill(0)
    .map(() => Array(n).fill(0));

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < p; k++) {
        C[i][j] += A[i][k] * B[k][j];
      }
    }
  }

  return C;
}

const A = [
  [1, 2],
  [3, 4],
];
const B = [
  [5, 6],
  [7, 8],
];
console.log(matrixMultiply(A, B));
// [[19, 22], [43, 50]]
```

---

### 3. Stacks (LIFO ‚Äì Last In First Out)

### Operations

| Operation      | Time Complexity | Description                   |
| -------------- | --------------- | ----------------------------- |
| push(x)        | O(1)            | Add element to top            |
| pop()          | O(1)            | Remove and return top element |
| top() / peek() | O(1)            | Look at top without removing  |
| isEmpty()      | O(1)            | Check if stack is empty       |

### Pseudocode ‚Äì Array-based stack

```pseudocode
STACK-EMPTY(S)
    return S.top = 0

PUSH(S, x)
    S.top ‚Üê S.top + 1
    S[S.top] ‚Üê x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    x ‚Üê S[S.top]
    S.top ‚Üê S.top - 1
    return x
```

### TypeScript code ‚Äì Stack

```ts
class Stack<T> {
  private items: T[] = [];

  push(item: T): void {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }

  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }

  size(): number {
    return this.items.length;
  }
}

// Usage
const stack = new Stack<number>();
stack.push(10);
stack.push(20);
stack.push(30);

console.log(stack.peek()); // 30
console.log(stack.pop()); // 30
console.log(stack.pop()); // 20
console.log(stack.isEmpty()); // false
```

---

### 4. Queues (FIFO ‚Äì First In First Out)

### Operations

| Operation  | Time Complexity | Description           |
| ---------- | --------------- | --------------------- |
| enqueue(x) | O(1)            | Add to rear           |
| dequeue()  | O(1)            | Remove from front     |
| front()    | O(1)            | Look at front element |
| isEmpty()  | O(1)            | Check if empty        |

### Pseudocode ‚Äì Array-based queue (circular, simple version)

```pseudocode
ENQUEUE(Q, x)
    Q[Q.tail] ‚Üê x
    Q.tail ‚Üê (Q.tail + 1) mod Q.length

DEQUEUE(Q)
    x ‚Üê Q[Q.head]
    Q.head ‚Üê (Q.head + 1) mod Q.length
    return x
```

### TypeScript code ‚Äì Queue (array-based)

```ts
class Queue<T> {
  private items: T[] = [];

  enqueue(item: T): void {
    this.items.push(item);
  }

  dequeue(): T | undefined {
    return this.items.shift();
  }

  front(): T | undefined {
    return this.items[0];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }

  size(): number {
    return this.items.length;
  }
}

// Usage
const queue = new Queue<string>();
queue.enqueue("A");
queue.enqueue("B");
queue.enqueue("C");

console.log(queue.front()); // "A"
console.log(queue.dequeue()); // "A"
console.log(queue.dequeue()); // "B"
console.log(queue.isEmpty()); // false
```

---

### Summary Table ‚Äì Comparison of array-based structures

| Structure | Access | Insert | Delete | Order   | Typical Use Case                      |
| --------- | ------ | ------ | ------ | ------- | ------------------------------------- |
| Array     | O(1)   | O(n)   | O(n)   | Indexed | Random access, fixed-size data        |
| Stack     | O(1)   | O(1)   | O(1)   | LIFO    | Undo/redo, recursion, expression eval |
| Queue     | O(1)   | O(1)   | O(1)   | FIFO    | Task scheduling, BFS, buffers         |
| Matrix    | O(1)   | ‚Äî      | ‚Äî      | 2D grid | Image processing, linear algebra      |

> These simple structures appear everywhere ‚Äî they are the building blocks for linked lists, trees, hash tables, graphs, and almost every algorithm in the book.

---

## 10.2 Linked lists

Linked lists are one of the most fundamental dynamic data structures.
Unlike arrays (fixed size or costly resizing), linked lists allow efficient insertion and deletion at known positions.

---

### 1. Singly linked list ‚Äì Basic structure

Each node contains:

- data (the value)
- next pointer (reference to the next node)

The list is identified by a pointer to the head node.
The last node has next = null.

### Visual representation

```text
head ‚Üí [data | next] ‚Üí [data | next] ‚Üí [data | null]
```

---

### 2. Common operations & time complexities

| Operation                      | Time Complexity | Notes / Reason                            |
| ------------------------------ | --------------- | ----------------------------------------- |
| Access by index                | O(n)            | Must traverse from head                   |
| Search (unsorted)              | O(n)            | Linear scan                               |
| Insert at head                 | O(1)            | Update head pointer                       |
| Insert at tail (no tail ptr)   | O(n)            | Must traverse to last node                |
| Insert at tail (with tail ptr) | O(1)            | Direct update via tail                    |
| Insert after known node        | O(1)            | If we already have pointer to predecessor |
| Delete at head                 | O(1)            | Update head pointer                       |
| Delete arbitrary node          | O(1)            | If we have pointer to the node (and prev) |
| Delete by value (no prev)      | O(n)            | Must find node + update previous          |

---

### 3. Pseudocode ‚Äì Core operations (singly linked list)

```pseudocode
// Node structure (conceptual)
Node:
    key        // the data
    next       // pointer to next node

// Insert node x after node prev (O(1))
LIST-INSERT-AFTER(prev, x)
    x.next ‚Üê prev.next
    prev.next ‚Üê x

// Delete node x (assumes we have pointer to x and its predecessor prev)
LIST-DELETE(prev, x)
    prev.next ‚Üê x.next

// Search for first node with key k (O(n))
LIST-SEARCH(L, k)
    x ‚Üê L.head
    while x ‚â† null and x.key ‚â† k
        x ‚Üê x.next
    return x
```

---

### 4. TypeScript code ‚Äì Singly Linked List (with head & tail)

```ts
class ListNode<T> {
  value: T;
  next: ListNode<T> | null = null;

  constructor(value: T) {
    this.value = value;
  }
}

class SinglyLinkedList<T> {
  private head: ListNode<T> | null = null;
  private tail: ListNode<T> | null = null;
  private length: number = 0;

  // Insert at the end ‚Äì O(1) thanks to tail pointer
  push(value: T): void {
    const newNode = new ListNode(value);

    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail!.next = newNode;
      this.tail = newNode;
    }

    this.length++;
  }

  // Insert at the beginning ‚Äì O(1)
  unshift(value: T): void {
    const newNode = new ListNode(value);
    newNode.next = this.head;

    this.head = newNode;
    if (!this.tail) this.tail = newNode;

    this.length++;
  }

  // Remove from beginning ‚Äì O(1)
  shift(): T | undefined {
    if (!this.head) return undefined;

    const removed = this.head;
    this.head = this.head.next;

    if (!this.head) this.tail = null;
    this.length--;

    return removed.value;
  }

  // Remove from end ‚Äì O(n) because we need to find new tail
  pop(): T | undefined {
    if (!this.head) return undefined;
    if (this.length === 1) {
      const value = this.head.value;
      this.head = null;
      this.tail = null;
      this.length--;
      return value;
    }

    // Traverse to second-to-last node
    let current = this.head;
    while (current.next !== this.tail) {
      current = current.next!;
    }

    const value = this.tail!.value;
    current.next = null;
    this.tail = current;
    this.length--;

    return value;
  }

  // Insert after a specific value (O(n) search + O(1) insert)
  insertAfter(targetValue: T, newValue: T): boolean {
    let current = this.head;

    while (current) {
      if (current.value === targetValue) {
        const newNode = new ListNode(newValue);
        newNode.next = current.next;
        current.next = newNode;

        if (current === this.tail) {
          this.tail = newNode;
        }

        this.length++;
        return true;
      }
      current = current.next;
    }

    return false; // target not found
  }

  // Get value at index ‚Äì O(n)
  get(index: number): T | undefined {
    if (index < 0 || index >= this.length) return undefined;

    let current = this.head;
    let count = 0;

    while (current && count < index) {
      current = current.next;
      count++;
    }

    return current?.value;
  }

  // Print the list
  print(): void {
    const values: T[] = [];
    let current = this.head;
    while (current) {
      values.push(current.value);
      current = current.next;
    }
    console.log(values.join(" ‚Üí "));
  }

  size(): number {
    return this.length;
  }

  isEmpty(): boolean {
    return this.length === 0;
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example usage
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const list = new SinglyLinkedList<number>();

list.push(10);
list.push(20);
list.push(30);

list.unshift(5);

console.log("List:");
list.print(); // 5 ‚Üí 10 ‚Üí 20 ‚Üí 30

console.log("Get index 2:", list.get(2)); // 20

list.insertAfter(10, 15);
list.print(); // 5 ‚Üí 10 ‚Üí 15 ‚Üí 20 ‚Üí 30

console.log("Popped:", list.pop()); // 30
list.print(); // 5 ‚Üí 10 ‚Üí 15 ‚Üí 20

console.log("Shifted:", list.shift()); // 5
list.print(); // 10 ‚Üí 15 ‚Üí 20
```

---

### Summary Table ‚Äì Singly Linked List vs Array

| Feature                     | Singly Linked List         | Array (dynamic)          |
| --------------------------- | -------------------------- | ------------------------ |
| Access by index             | O(n)                       | O(1)                     |
| Insert at beginning         | O(1)                       | O(n)                     |
| Insert at end (with tail)   | O(1)                       | Amortized O(1)           |
| Delete arbitrary (with ptr) | O(1)                       | O(n)                     |
| Memory usage                | Higher (pointers)          | Lower (contiguous)       |
| Cache performance           | Poor (jumps in memory)     | Excellent (sequential)   |
| Best for                    | Frequent head/tail inserts | Random access, iteration |

---

### Key Takeaway

> Linked lists trade random-access speed for efficient insertion/deletion at known positions. They are essential building blocks for stacks, queues, hash tables (chaining), graphs (adjacency lists), and many other structures.

---

## 10.3 Representing rooted trees

Rooted trees appear everywhere in computer science:

- parse trees in compilers
- family trees / organization charts
- file systems
- search trees (binary search trees, tries, etc.)
- game trees
- recursion trees in algorithm analysis

CLRS shows three common ways to represent a rooted tree using arrays (very space-efficient when the tree is not too sparse).

---

### 1. Three standard array-based representations

Let n = number of nodes.
Nodes are labeled 1 to n (or 0 to n-1).

| Representation                            | Arrays used                                       | Key property / advantage                       | Space | Best for                            |
| ----------------------------------------- | ------------------------------------------------- | ---------------------------------------------- | ----- | ----------------------------------- |
| Parent representation                     | parent[1..n]                                      | parent[i] = parent of node i (root has 0/null) | O(n)  | Finding parent, ancestor queries    |
| Child-sibling (left-child, right-sibling) | left-child[1..n], right-sibling[1..n]             | Classic linked-list per level                  | O(n)  | Tree traversal, dynamic children    |
| Full binary tree (with parent)            | parent[1..n], left-child[1..n], right-child[1..n] | Most common in binary heaps & BSTs             | O(n)  | Binary trees, heaps, BST operations |

Most common representation in algorithms (used in heaps, BSTs, etc.)

---

### 2. Left-child / right-sibling representation

(also called child-sibling or first-child/next-sibling)

Arrays:

- left-child[i] = index of leftmost child of i (or null/0)
- right-sibling[i] = index of right sibling of i (or null/0)

Root has no parent (usually index 1 or given separately).

### Example tree

```text
1 (root)
       /   |   \
      2    3    4
     / \       / \
    5   6     7   8
```

### Left-child & right-sibling representation

| Node | left-child | right-sibling |
| ---- | ---------- | ------------- |
| 1    | 2          | null          |
| 2    | 5          | 3             |
| 3    | null       | 4             |
| 4    | 7          | null          |
| 5    | null       | 6             |
| 6    | null       | null          |
| 7    | null       | 8             |
| 8    | null       | null          |

---

### 3. Pseudocode ‚Äì Basic operations (left-child / right-sibling)

```pseudocode
// Find first child of node x
FIRST-CHILD(x) = left-child[x]

// Find next sibling of node x
NEXT-SIBLING(x) = right-sibling[x]

// Find parent of node x (requires O(n) scan ‚Äì not efficient)
PARENT(x)
    for i = 1 to n
        if left-child[i] = x or any sibling chain reaches x
            return i
    return null  // root or not found

// Preorder traversal (recursive)
PREORDER(x)
    visit x
    y ‚Üê FIRST-CHILD(x)
    while y ‚â† null
        PREORDER(y)
        y ‚Üê NEXT-SIBLING(y)
```

---

### 4. TypeScript code ‚Äì Left-child / right-sibling representation

```ts
// We use 1-based indexing to match CLRS convention
// null represented by 0

class RootedTree {
  private n: number;
  private leftChild: number[] = [];
  private rightSibling: number[] = [];

  constructor(n: number) {
    this.n = n;
    this.leftChild = new Array(n + 1).fill(0);
    this.rightSibling = new Array(n + 1).fill(0);
  }

  // Set leftmost child of node
  setLeftChild(parent: number, child: number): void {
    this.leftChild[parent] = child;
  }

  // Add a new child to the right of existing sibling
  addRightSibling(node: number, newSibling: number): void {
    this.rightSibling[node] = newSibling;
  }

  // Preorder traversal (visit root ‚Üí leftmost child ‚Üí siblings)
  preorderTraversal(start: number = 1, visit: (node: number) => void): void {
    visit(start);

    // Visit leftmost child and its siblings
    let child = this.leftChild[start];
    while (child !== 0) {
      this.preorderTraversal(child, visit);
      child = this.rightSibling[child];
    }
  }

  // Print tree structure (simple indented)
  printTree(node: number = 1, depth: number = 0): void {
    console.log("  ".repeat(depth) + node);

    let child = this.leftChild[node];
    while (child !== 0) {
      this.printTree(child, depth + 1);
      child = this.rightSibling[child];
    }
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example: build the tree from earlier diagram
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const tree = new RootedTree(8);

// Root 1 has children 2,3,4
tree.setLeftChild(1, 2);
tree.addRightSibling(2, 3);
tree.addRightSibling(3, 4);

// Node 2 has children 5,6
tree.setLeftChild(2, 5);
tree.addRightSibling(5, 6);

// Node 4 has children 7,8
tree.setLeftChild(4, 7);
tree.addRightSibling(7, 8);

console.log("Tree structure:");
tree.printTree();
// Output:
// 1
//   2
//     5
//     6
//   3
//   4
//     7
//     8

console.log("\nPreorder traversal:");
const order: number[] = [];
tree.preorderTraversal(1, (node) => order.push(node));
console.log(order); // [1, 2, 5, 6, 3, 4, 7, 8]
```

---

### Summary Table ‚Äì Tree Representations

| Representation             | Arrays needed                   | Space | Parent query | Child iteration  | Best for                             |
| -------------------------- | ------------------------------- | ----- | ------------ | ---------------- | ------------------------------------ |
| Parent pointer             | parent[1..n]                    | O(n)  | O(1)         | O(n) scan        | Ancestor queries, union-find         |
| Left-child / right-sibling | left-child, right-sibling       | O(n)  | O(n) scan    | O(1) per sibling | General trees, traversal             |
| Binary (left/right child)  | left-child, right-child, parent | O(n)  | O(1)         | O(1) per child   | Binary heaps, BSTs, expression trees |

---

### Key Takeaway

> The left-child / right-sibling representation is the most flexible for general rooted trees when we need to iterate over children efficiently. The binary representation (left & right child) is the most common in practice because most important tree structures (heaps, BSTs, tries) are binary or can be treated as binary.
