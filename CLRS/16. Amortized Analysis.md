# 16. Amortized Analysis

## ğŸ“‹ Chapter Overview

| Section  | Topic              | Key Idea                    |
| -------- | ------------------ | --------------------------- |
| **16.1** | Aggregate analysis | Average cost over sequences |
| **16.2** | Accounting method  | Banker's credit argument    |
| **16.3** | Potential method   | Stored energy (potential)   |
| **16.4** | Dynamic tables     | Amortized insert/delete     |

---

## 16.1 Aggregate Analysis

Aggregate analysis is the simplest and most intuitive of the three main methods used in amortized analysis.

---

### Idea

Instead of bounding the cost of each individual operation (which can be very expensive in the worst case),
we bound the **total cost of a sequence of n operations**, then divide by n to get the **amortized cost per operation**.

If the total cost of n operations is `T(n)`, then the amortized cost per operation is:

```
amortized cost = T(n) / n
```

This method is powerful when expensive operations are rare and most operations are cheap.

---

### Classic Example: Dynamic Table Expansion

Many languages use dynamic arrays (ArrayList in Java, vector in C++, [] in JS/Python) that grow automatically when full.

#### Typical Implementation

1. Start with small capacity (e.g., 1 or 16)
2. When inserting and the array is full â†’ allocate a new larger array (usually double the size)
3. Copy all old elements to the new array
4. Insert the new element
5. Discard the old array

#### Costs

- **Worst-case cost of a single insert:** Î˜(n) â€” when resizing
- **Amortized cost:** O(1) â€” average per insert

---

### Aggregate Analysis of Dynamic Table Expansion

- Start with capacity 1 and **double capacity** every time table is full
- Let n = number of insertions

**Total cost of n insertions:**

- Most insertions cost 1 (just place the element)
- Resizes happen at sizes: 1, 2, 4, 8, â€¦, 2^k
- Cost of resize at size 2^k = 2^k (copy elements)

**Resizing costs:**

```
1 + 2 + 4 + 8 + â€¦ + 2^k = 2^(k+1) âˆ’ 1 < 2n
```

**Non-resizing insertions:** â‰¤ n

**Total cost T(n) â‰¤ n + 2n = 3n = O(n)**

**Amortized cost per insertion:**

```
T(n)/n = O(1)
```

> Even though some insertions cost Î˜(n), average (amortized) cost is O(1).

---

### TypeScript Implementation: Dynamic Array with Doubling

```ts
class DynamicArray<T> {
  private data: T[] = [];
  private capacity: number = 1;
  private size: number = 0;

  // Insert an element (amortized O(1))
  push(value: T): void {
    if (this.size === this.capacity) {
      this.resize(this.capacity * 2);
    }
    this.data[this.size] = value;
    this.size++;
  }

  private resize(newCapacity: number): void {
    console.log(`Resizing from ${this.capacity} to ${newCapacity}`);
    const newData = new Array(newCapacity);
    for (let i = 0; i < this.size; i++) {
      newData[i] = this.data[i];
    }
    this.data = newData;
    this.capacity = newCapacity;
  }

  get length(): number {
    return this.size;
  }

  get(index: number): T {
    if (index < 0 || index >= this.size) {
      throw new Error("Index out of bounds");
    }
    return this.data[index];
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Demo â€“ watch resizes
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const arr = new DynamicArray<number>();
for (let i = 0; i < 20; i++) {
  arr.push(i);
  console.log(
    `Inserted ${i}, size=${arr.length}, capacity=${(arr as any).capacity}`,
  );
}
```

> Output shows resizes at sizes: 1â†’2, 2â†’4, 4â†’8, 8â†’16...
> Total copy cost â‰ˆ 2n, amortized O(1) per push

---

### Important Notes

- Aggregate analysis proves **amortized O(1)** per operation even though single operations can be expensive
- Doubling is common (Ã—2) â€” gives amortized O(1)
- Multiplying by 1.5 or other factors also works
- Real languages (Java ArrayList, Python list, JS array) use this doubling strategy
- Aggregate analysis is the **simplest amortized method** â€” later sections cover accounting & potential methods

---

### Key Takeaway

1. Sum total cost of n operations â†’ divide by n â†’ get amortized cost per operation
2. In dynamic table expansion:
   - Total copy cost = O(n) over n insertions
   - Amortized cost = O(1) per insert â€” even though some inserts cost O(n)

---

## 16.2 The Accounting Method

The **accounting method** (also called the banker's method) is a technique for proving amortized bounds.
It is more flexible than aggregate analysis because it assigns different costs to different operations â€” some operations are charged more than their actual cost, and the extra "credit" is saved in a bank to pay for expensive operations later.

---

### Idea

1. Define an amortized cost for each operation
2. Show that the total amortized cost over any sequence of operations is an upper bound on the actual total cost
3. The difference (`amortized âˆ’ actual`) is stored as credit to pay for future expensive operations

> If amortized cost is O(f(n)) per operation, then average cost per operation is O(f(n)).

---

### Classic Example: Dynamic Table Expansion (Doubling)

- Use the same dynamic array as in 16.1
- **Insertion costs:**
  - Actual: usually 1 (append)
  - Expensive case: Î˜(n) when resizing and copying everything
- Goal: amortized cost O(1) per insertion

### Accounting Method Solution

- Charge **3 credits per insertion**
  - 1 credit for the actual insertion
  - 2 extra credits saved in the bank

**During resize (double capacity):**

- Need to copy `m` elements (current size)
- Bank has 2 credits per previous insertion â†’ exactly 2m credits saved
- Copying costs m â†’ use m credits from bank
- Bank never goes negative:
  - Before resize: 2m credits
  - Pay m for copying â†’ 2m âˆ’ m = m credits left
- After resize: capacity = 2m â†’ continue charging 3 per insertion

**Total amortized cost:** 3 per insertion â†’ O(1)

---

### Pseudocode â€“ Dynamic Table with Accounting Intuition

```text
dynamic-table-insert(T, x)
    // Amortized cost = 3
    // 1 for insert, 2 saved for future copy

    if T.size = T.capacity
        // Resize: double capacity
        new-capacity â† 2 Ã— T.capacity
        allocate new-array of size new-capacity
        copy T.data[1..T.size] to new-array[1..T.size]  // paid by saved credits
        T.data â† new-array
        T.capacity â† new-capacity

    T.size â† T.size + 1
    T.data[T.size] â† x
```

---

### TypeScript Implementation: Dynamic Array with Accounting

```ts
class DynamicArray<T> {
  private data: T[] = [];
  private capacity: number = 1;
  private size: number = 0;

  // Each push is charged 3 units amortized
  // 1 for actual push, 2 saved for future copy
  push(value: T): void {
    if (this.size === this.capacity) {
      // Resize: copy current size elements
      // Paid by the 2 credits saved per previous insertion
      console.log(
        `Resizing from ${this.capacity} to ${this.capacity * 2} (copying ${this.size} elements)`,
      );
      const newData = new Array(this.capacity * 2);
      for (let i = 0; i < this.size; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
      this.capacity *= 2;
    }

    this.data[this.size] = value;
    this.size++;
  }

  get length(): number {
    return this.size;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Demo â€“ see amortized cost in action
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const arr = new DynamicArray<number>();
for (let i = 0; i < 20; i++) {
  arr.push(i);
  console.log(
    `Inserted ${i}, size=${arr.length}, capacity=${(arr as any).capacity}`,
  );
}
```

> Resizes happen at sizes: 1â†’2, 2â†’4, 4â†’8, 8â†’16...
> Total copy cost â‰ˆ 2n, amortized O(1) per push

---

### Important Notes

- Accounting method assigns **fictitious costs (amortized costs)**
- Extra credits are saved for expensive future operations
- Must prove that the **bank never goes negative (credit invariant)**
- In dynamic table doubling: charge 3 per insert â†’ 1 for push, 2 saved â†’ exactly enough to pay for copy at resize
- More flexible than aggregate analysis â€” gives insight into why amortized cost works

---

### Key Takeaway

> The accounting method proves amortized bounds by charging each operation more than its actual cost, saving the difference as credit to pay for expensive future operations. In dynamic table doubling, charging 3 per insertion ensures enough credit to pay for copying during resizes.

---

## 16.3 The Potential Method

The **potential method** is the third (and often most powerful) technique for proving amortized bounds.
It is more general than aggregate and accounting methods because it uses a **potential function** to measure the "stored energy" in the data structure.

---

### Idea

1. Define a potential function Î¦ mapping the state of the data structure to a non-negative number
2. Cheap operation â†’ potential usually increases (store energy)
3. Expensive operation â†’ potential decreases (release energy)

**Amortized cost:**

```
amortized cost = actual cost + change in potential
```

> If each amortized cost is O(f(n)), then total cost of n operations is O(n f(n)).

---

### Formal Definition

- Let cáµ¢ = actual cost of the i-th operation
- Let Î¦áµ¢ = potential after the i-th operation
- Î¦â‚€ = initial potential (usually 0)

**Amortized cost Ã¢áµ¢:**

```
Ã¢áµ¢ = cáµ¢ + Î¦áµ¢ âˆ’ Î¦áµ¢â‚‹â‚
```

**Total cost of n operations:**

```
Î£ cáµ¢ = Î£ Ã¢áµ¢ âˆ’ Î¦â‚™ + Î¦â‚€
```

If Î¦â‚™ â‰¥ 0 and Î¦â‚€ = 0 â†’ Î£ cáµ¢ â‰¤ Î£ Ã¢áµ¢

> Each Ã¢áµ¢ â‰¤ O(f(n)) â†’ total cost O(n f(n)) â†’ amortized O(f(n)) per operation

---

### Classic Example: Dynamic Table Expansion (Doubling)

- Use same dynamic array
- **Potential function (CLRS choice):**

```
Î¦áµ¢ = 2 Ã— num_elements âˆ’ capacity
```

### Why This Works

- Insert without resizing:
  - num_elements +1 â†’ Î¦ +2
  - Actual cost = 1 â†’ amortized cost = 1 + 2 = 3
- Resize (double capacity):
  - Before: capacity = m, num_elements = m â†’ Î¦ = m
  - After: capacity = 2m, num_elements = m+1 â†’ Î¦ = 2
  - Copy cost = m â†’ amortized = (m+1) + (2 âˆ’ m) = 3

> Every insertion has amortized cost â‰¤ 3 â†’ O(1) amortized

---

### Pseudocode â€“ Dynamic Table with Potential

```text
dynamic-table-insert(T, x)
    // Potential: Î¦ = 2 Ã— size âˆ’ capacity

    if T.size = T.capacity
        new-capacity â† 2 Ã— T.capacity
        allocate new-array of size new-capacity
        copy T.data[1..T.size] to new-array[1..T.size]    // paid by potential drop
        T.data â† new-array
        T.capacity â† new-capacity

    T.size â† T.size + 1
    T.data[T.size] â† x
```

---

### TypeScript Implementation: Dynamic Array (Potential)

```ts
class DynamicArray<T> {
  private data: T[] = [];
  private capacity: number = 1;
  private size: number = 0;

  // Amortized O(1) per push using potential method
  // Potential Î¦ = 2*size - capacity
  push(value: T): void {
    if (this.size === this.capacity) {
      const oldCapacity = this.capacity;
      this.capacity *= 2;
      console.log(
        `Resizing from ${oldCapacity} to ${this.capacity} (copying ${this.size} elements)`,
      );
      const newData = new Array(this.capacity);
      for (let i = 0; i < this.size; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }

    this.data[this.size] = value;
    this.size++;
  }

  get length(): number {
    return this.size;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Demo
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const arr = new DynamicArray<number>();
for (let i = 0; i < 20; i++) {
  arr.push(i);
  console.log(
    `Inserted ${i}, size=${arr.length}, capacity=${(arr as any).capacity}`,
  );
}
```

> Resizes at 1â†’2, 2â†’4, 4â†’8, 8â†’16...
> Potential method shows each push costs amortized O(1)

---

### Important Notes

- Potential function Î¦ must be **non-negative**
- In dynamic doubling: Î¦ = 2Ã—size âˆ’ capacity works perfectly
- Before resize: Î¦ â‰ˆ size â†’ enough credit to pay for copying
- After resize: Î¦ â‰ˆ size again â†’ credit restored for next resize
- Accounting method is similar but assigns fixed credit per operation
- Potential method is more general â€” can handle variable costs elegantly

---

### Key Takeaway

> The potential method proves amortized bounds by defining a potential function Î¦ that stores credit when operations are cheap and releases it when operations are expensive. In dynamic table doubling, Î¦ = 2Ã—size âˆ’ capacity ensures amortized O(1) per insertion.

---

## 16.4 Dynamic Tables

Dynamic tables (resizable arrays) automatically grow (and sometimes shrink) as elements are inserted or deleted.
This section analyzes the amortized cost of **insert** and **delete** operations using all three methods.

---

### Key Question

Even though a single insertion can take O(n) time (resizing + copying), what is the amortized cost per operation?

---

### 1. Dynamic Table Operations

- **TABLE-INSERT(T, x):** add element x (may trigger resize)
- **TABLE-DELETE(T, x):** remove element x (may trigger shrink, optional)

**Common strategies:**

- Growth: double capacity when full
- Shrink: halve capacity when load factor < 1/4 (avoid thrashing)

---

### 2. Aggregate Analysis (Simplest)

- Only double on insert (no shrink)
- Most insertions cost 1
- Resize occurs at size = capacity = 2áµ â†’ copy 2áµ elements

**Total copy cost over n insertions:**

```
1 + 2 + 4 + â€¦ + 2áµ = 2^(k+1) âˆ’ 1 < 2n
```

**Total insertion cost:** n (excluding copies)
**Total cost T(n) â‰¤ n + 2n = 3n**
**Amortized cost per insertion:** T(n)/n â‰¤ 3 = O(1)

---

### 3. Accounting Method (Banker's View)

- Charge **3 credits per insertion**
  - 1 for actual insertion
  - 2 saved in bank
- Resize at size m = 2áµ:
  - Copy m elements â†’ use m credits from bank
  - Bank has m left â†’ never negative
- **Amortized cost â‰¤ 3 per insertion â†’ O(1)**

---

### 4. Potential Method (Physicist's View)

- Potential function:

```
Î¦áµ¢ = 2 Ã— num_elementsáµ¢ âˆ’ capacityáµ¢
```

- Amortized cost:

```
Ã¢áµ¢ = cáµ¢ + Î¦áµ¢ âˆ’ Î¦áµ¢â‚‹â‚
```

- Normal insertion (no resize): cáµ¢ = 1, Î¦ +2 â†’ Ã¢áµ¢ = 3
- Resize (m â†’ 2m): cáµ¢ â‰ˆ m + 1, Î”Î¦ â‰ˆ 2 âˆ’ m â†’ Ã¢áµ¢ â‰ˆ 3

> Amortized O(1) per insertion

---

### TypeScript Implementation: Dynamic Table (Potential)

```ts
class DynamicTable<T> {
  private data: T[] = [];
  private capacity: number = 1;
  private size: number = 0;

  // Amortized O(1) per insert (Î¦ = 2*size - capacity)
  insert(value: T): void {
    if (this.size === this.capacity) {
      const oldCapacity = this.capacity;
      this.capacity *= 2;
      console.log(
        `Resize: ${oldCapacity} â†’ ${this.capacity} (copy ${this.size})`,
      );
      const newData = new Array(this.capacity);
      for (let i = 0; i < this.size; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }

    this.data[this.size] = value;
    this.size++;
  }

  get length(): number {
    return this.size;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Demo
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const table = new DynamicTable<number>();
for (let i = 0; i < 20; i++) {
  table.insert(i);
  console.log(
    `Insert ${i} | size=${table.length} | capacity=${(table as any).capacity}`,
  );
}
```

> Resizes at 1â†’2, 2â†’4, 4â†’8, 8â†’16...
> Total copy cost â‰ˆ 2n â†’ amortized O(1)

---

### Important Notes

- All three methods prove **amortized O(1) per insert**
  - Aggregate: simplest
  - Accounting: explicit credit assignment
  - Potential: most general (handles deletions/contractions)

- Real languages use doubling (or 1.5Ã—) â†’ amortized O(1) insert
- Shrinking (halve when load < 1/4) â†’ amortized O(1) delete using similar potential

---

### Key Takeaway

> Dynamic tables with doubling achieve amortized O(1) insert cost, even though single resizes cost O(n). The potential method (Î¦ = 2Ã—size âˆ’ capacity) shows how credit is saved during normal inserts and spent during expensive resizes â€” keeping amortized cost constant.
