# 19. Data Structures for Disjoint Sets

## ğŸ“‹ Chapter Overview

| Section | Topic                                           | Key Idea                                                                                             |
| ------- | ----------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| 19.1    | Disjoint-set operations                         | Union-find data structure with union by rank and path compression for nearly constant amortized time |
| 19.2    | Linked-list representation                      | Simple but inefficient O(n) implementation using linked lists                                        |
| 19.3    | Disjoint-set forests                            | Tree-based representation with heuristics achieving O(Î±(n)) amortized time                           |
| 19.4    | Analysis of union by rank with path compression | Rigorous analysis showing O(Î±(n)) bound via inverse Ackermann function                               |

---

## 19.1 Disjoint-set operations

The disjoint-set data structure (also called union-find) maintains a collection of disjoint sets and supports two main operations efficiently:

### Core Operations

- **MAKE-SET(x)**: create a new set containing only element x
- **UNION(x, y)**: merge the sets containing x and y into one set
- **FIND-SET(x)**: return a representative (any element) of the set containing x

Two elements are in the same set if and only if FIND-SET(x) = FIND-SET(y).

### Applications

- Kruskal's MST
- Connected components
- Cycle detection
- Image segmentation

### Naive Implementation (Linked-List Style)

- MAKE-SET(x): create a list with only x (O(1))
- FIND-SET(x): follow parent pointers to the root of the list (O(n) worst-case)
- UNION(x, y): append one list to the end of the other (O(1) if we keep tail pointer)

Worst-case time for FIND-SET is O(n) â†’ very slow for long chains.

### Better Approach: Union by Rank + Path Compression

**Heuristics:**

1. **Union by rank**: attach shorter tree under taller tree â†’ keeps tree height small (O(log n))
2. **Path compression**: during FIND-SET, make every node on the path point directly to the root â†’ flattens the tree

Together, almost O(1) amortized time per operation (Ackermann function â€” practically constant).

### Pseudocode

```text

MAKE-SET(x)
x.p â† x
x.rank â† 0

FIND-SET(x)
if x â‰  x.p
x.p â† FIND-SET(x.p)   // path compression
return x.p

UNION(x, y)
LINK(FIND-SET(x), FIND-SET(y))

LINK(x, y)  // x and y are roots
if x.rank > y.rank
y.p â† x
else
x.p â† y
if x.rank = y.rank
y.rank â† y.rank + 1
```

### TypeScript Implementation

```typescript
class DisjointSet {
  private parent: Map<number, number> = new Map();
  private rank: Map<number, number> = new Map();

  makeSet(x: number): void {
    this.parent.set(x, x);
    this.rank.set(x, 0);
  }

  findSet(x: number): number {
    if (!this.parent.has(x)) throw new Error(`Element ${x} not in any set`);
    if (this.parent.get(x) !== x)
      this.parent.set(x, this.findSet(this.parent.get(x)!)); // path compression
    return this.parent.get(x)!;
  }

  union(x: number, y: number): void {
    const rootX = this.findSet(x);
    const rootY = this.findSet(y);
    if (rootX === rootY) return; // already same set
    const rankX = this.rank.get(rootX)!;
    const rankY = this.rank.get(rootY)!;
    if (rankX > rankY) this.parent.set(rootY, rootX);
    else {
      this.parent.set(rootX, rootY);
      if (rankX === rankY) this.rank.set(rootY, rankY + 1);
    }
  }

  connected(x: number, y: number): boolean {
    return this.findSet(x) === this.findSet(y);
  }
}

// Demo
const ds = new DisjointSet();
for (let i = 0; i < 10; i++) ds.makeSet(i);

ds.union(1, 2);
ds.union(2, 3);
ds.union(4, 5);
ds.union(3, 5);

console.log("1 and 5 connected?", ds.connected(1, 5)); // true
console.log("0 and 9 connected?", ds.connected(0, 9)); // false

ds.union(0, 9);
console.log("After union 0-9:", ds.connected(0, 9)); // true
```

---

**Important Notes**

- Without path compression & union by rank â†’ worst-case O(n) per find
- With both heuristics â†’ amortized O(Î±(n)) per operation, Î±(n) â‰¤ 5 for all practical n
- Practically constant time
- Widely used: Kruskalâ€™s MST, connected components, image processing, network connectivity

---

> **Key Takeaway:** The disjoint-set data structure supports union and find operations efficiently using union by rank and path compression. Together they give almost constant amortized time â€” one of the most beautiful and practical amortized bounds in algorithms.

---

## 19.2 Linked-list representation of disjoint sets

This section presents a simple (but inefficient) way to implement disjoint-set forests using linked lists. Each set is represented as a linked list with a head (representative) and a tail pointer. Every element has a parent pointer to the next element in the list, and the last element points to null.

### Basic Structure

Each object x has:

- `x.p` â†’ pointer to next object in the list (or null for the last one)
- `x.head` â†’ pointer to the representative (head) of the set

> The representative of a set is the first element in the linked list.

---

**2. Operations**

**MAKE-SET(x)** â€” Create a new set containing only x.

```text
MAKE-SET(x)
    x.p â† NIL
    x.head â† x
```

**FIND-SET(x)** â€” Follow parent pointers to the head of the list.

```text
FIND-SET(x)
    while x.p â‰  NIL
        x â† x.p
    return x.head
```

**UNION(x, y)** â€” Link the two lists by appending the second list to the end of the first. Update the head of every element in the second list to point to the new head.

```text
UNION(x, y)
    rx â† FIND-SET(x)
    ry â† FIND-SET(y)
    if rx = ry
        return  // already same set

    // Append ry's list to rx's list
    tail â† find tail of rx's list (O(n) scan)
    tail.p â† ry

    // Update head of every element in ry's list
    current â† ry
    while current â‰  NIL
        current.head â† rx
        current â† current.p
```

### TypeScript Implementation

```typescript
class DisjointSetNode {
  value: number;
  p: DisjointSetNode | null = null; // next in list
  head: DisjointSetNode | null = null; // representative

  constructor(value: number) {
    this.value = value;
    this.head = this;
  }
}

class LinkedListDisjointSet {
  private nodes: Map<number, DisjointSetNode> = new Map();

  makeSet(value: number): void {
    const node = new DisjointSetNode(value);
    this.nodes.set(value, node);
  }

  findSet(value: number): DisjointSetNode | null {
    const node = this.nodes.get(value);
    if (!node) return null;
    let current: DisjointSetNode | null = node;
    while (current.p) current = current.p;
    return current.head;
  }

  union(valueX: number, valueY: number): void {
    const rootX = this.findSet(valueX);
    const rootY = this.findSet(valueY);
    if (!rootX || !rootY || rootX === rootY) return;

    // Append Y's list to X's list
    let tailX: DisjointSetNode | null = rootX;
    while (tailX.p) tailX = tailX.p;
    tailX.p = rootY;

    // Update head pointer for every node in Y's list
    let current: DisjointSetNode | null = rootY;
    while (current) {
      current.head = rootX;
      current = current.p;
    }
  }

  // For debugging: show set members
  getSet(value: number): number[] {
    const root = this.findSet(value);
    if (!root) return [];
    const members: number[] = [];
    let current: DisjointSetNode | null = root;
    while (current) {
      members.push(current.value);
      current = current.p;
    }
    return members;
  }
}

// Demo
const ds = new LinkedListDisjointSet();
for (let i = 1; i <= 10; i++) ds.makeSet(i);

ds.union(1, 2);
ds.union(3, 4);
ds.union(2, 4);

console.log("Set of 1:", ds.getSet(1)); // [1, 2, 3, 4] (order may vary)
console.log("Set of 5:", ds.getSet(5)); // [5]
```

### Important Notes

- MAKE-SET: O(1)
- FIND-SET: O(n) worst-case (long chain)
- UNION: O(n) worst-case (scan to tail + update all heads)
- Simple but inefficient; long chains can form
- Real-world use: only educational â€” not used without heuristics

> **Key Takeaway:** The linked-list representation of disjoint sets is simple but inefficient: FIND-SET and UNION take O(n) worst-case. Union by rank and path compression (next section) improve performance to nearly constant time.

---

## 19.3 Disjoint-set forests

Disjoint-set forests are a tree-based representation of disjoint sets that dramatically improves performance over the linked-list version (19.2).

- Each set is represented as a tree (forest = collection of trees)
- Each element points to its parent; the root of a tree serves as the representative (set label)

### Core Operations

- **MAKE-SET(x)**: Create a tree with only x (x is its own parent)
- **FIND-SET(x)**: Follow parent pointers to the root of the tree
- **UNION(x, y)**: Link the roots of the two trees containing x and y

> Without optimizations â†’ trees can become long chains â†’ FIND-SET takes O(n) time.

### Two Powerful Heuristics

1. **Union by rank**
   - Attach the tree with smaller rank (approximate height) under the tree with larger rank
   - Rank[x] = upper bound on height of subtree rooted at x
   - When ranks are equal â†’ increase rank of new root by 1

2. **Path compression**
   - During FIND-SET, make every node on the path point directly to the root
   - Flattens the tree â†’ future finds are very fast

### Pseudocode

```text
MAKE-SET(x)
    x.p â† x
    x.rank â† 0

FIND-SET(x)
    if x â‰  x.p
        x.p â† FIND-SET(x.p)   // path compression
    return x.p

UNION(x, y)
    LINK(FIND-SET(x), FIND-SET(y))

LINK(x, y)  // x and y are roots
    if x.rank > y.rank
        y.p â† x
    else
        x.p â† y
        if x.rank = y.rank
            y.rank â† y.rank + 1
```

### TypeScript Implementation

```typescript
class DisjointSetNode {
  value: number;
  parent: DisjointSetNode;
  rank: number = 0;

  constructor(value: number) {
    this.value = value;
    this.parent = this;
  }
}

class DisjointSetForest {
  private nodes: Map<number, DisjointSetNode> = new Map();

  makeSet(value: number): void {
    if (this.nodes.has(value)) return;
    this.nodes.set(value, new DisjointSetNode(value));
  }

  findSet(value: number): DisjointSetNode | null {
    const node = this.nodes.get(value);
    if (!node) return null;
    if (node.parent !== node) node.parent = this.findSet(node.parent.value)!; // path compression
    return node.parent;
  }

  union(valueX: number, valueY: number): void {
    const rootX = this.findSet(valueX);
    const rootY = this.findSet(valueY);
    if (!rootX || !rootY || rootX === rootY) return;
    if (rootX.rank > rootY.rank) rootY.parent = rootX;
    else {
      rootX.parent = rootY;
      if (rootX.rank === rootY.rank) rootY.rank++;
    }
  }

  connected(valueX: number, valueY: number): boolean {
    const rx = this.findSet(valueX);
    const ry = this.findSet(valueY);
    return rx !== null && ry !== null && rx === ry;
  }

  getRepresentative(value: number): number | null {
    return this.findSet(value)?.value ?? null;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Demo
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const ds = new DisjointSetForest();
for (let i = 0; i < 10; i++) ds.makeSet(i);

ds.union(1, 2);
ds.union(2, 3);
ds.union(4, 5);
ds.union(3, 5);
ds.union(6, 7);
ds.union(7, 8);

console.log("1 and 5 connected?", ds.connected(1, 5)); // true
console.log("6 and 8 connected?", ds.connected(6, 8)); // true
console.log("0 and 9 connected?", ds.connected(0, 9)); // false
console.log("Representative of 3:", ds.getRepresentative(3));
```

---

**Important Notes**

- MAKE-SET: O(1)
- FIND-SET: almost O(1) amortized with path compression
- UNION: almost O(1) amortized with union by rank
- Amortized time per operation: O(Î±(n)) (Î± = inverse Ackermann function â‰¤ 5 for practical n)
- No actual tree traversal needed after compression
- Used everywhere: Kruskalâ€™s MST, connected components, cycle detection, image processing

---

> **Key Takeaway:** Disjoint-set forests use trees with parent pointers. Union by rank keeps trees shallow; path compression flattens them during finds, giving nearly constant amortized time per operation (O(Î±(n)) â‰ˆ O(1) in practice).

---

## 19.4 Analysis of union by rank with path compression

This section gives the rigorous amortized analysis of the disjoint-set forest data structure when using both union by rank and path compression.

- Amortized time per operation: O(Î±(n))
- Î±(n) = inverse Ackermann function, grows extremely slowly, effectively constant for practical n.

---

**1. The inverse Ackermann function Î±(n)**

Defined via Ackermann function A(m, n):

- A(0, n) = n + 1
- A(1, n) = n + 2
- A(2, n) = 2n + 3
- A(3, n) = 2â†‘â†‘(n+3) âˆ’ 3 (tower of 2's)
- A(4, n) = insanely large

Properties:

- Î±(n) = smallest m such that A(m, m) â‰¥ n
- Practical values:
  - Î±(n) â‰¤ 4 for n â‰¤ 10Â¹â°â°â°â°â°
  - Î±(n) â‰¤ 5 for any conceivable real-world n
  - Effectively constant â€” slower than log*, log log*, etc.

So amortized cost is O(Î±(n)) â‰ˆ O(1) in practice.

### Why Union by Rank + Path Compression is Powerful

- Union by rank keeps tree height small: O(log n)
- Path compression flattens trees during FIND-SET
- Together: trees almost flat quickly
- Proof uses rank groups, levels, iterated logarithms (non-trivial)

### Key Ideas in the Proof (High-Level Intuition)

- **Rank groups**: group nodes by rank
- **Levels**: define iterated log levels
- **Potential function**: counts nodes per level and rank group
- Each FIND-SET pays tiny amortized cost: O(Î±(n))
- UNION by rank ensures rank grows slowly

Small number of operations can dramatically flatten the structure.

### Practical Implications

- Most operations O(1) after a few finds
- Average time often < 5 operations (near constant)
- Widely used in real systems: Kruskalâ€™s MST, connected components, garbage collection, image segmentation, etc.

### TypeScript Implementation

```typescript
class DisjointSetNode {
  value: number;
  parent: DisjointSetNode;
  rank: number = 0;

  constructor(value: number) {
    this.value = value;
    this.parent = this;
  }
}

class DisjointSetForest {
  private nodes: Map<number, DisjointSetNode> = new Map();

  makeSet(value: number): void {
    if (this.nodes.has(value)) return;
    this.nodes.set(value, new DisjointSetNode(value));
  }

  findSet(value: number): DisjointSetNode | null {
    const node = this.nodes.get(value);
    if (!node) return null;
    if (node.parent !== node) node.parent = this.findSet(node.parent.value)!; // path compression
    return node.parent;
  }

  union(valueX: number, valueY: number): void {
    const rootX = this.findSet(valueX);
    const rootY = this.findSet(valueY);
    if (!rootX || !rootY || rootX === rootY) return;
    const rankX = rootX.rank;
    const rankY = rootY.rank;
    if (rankX > rankY) rootY.parent = rootX;
    else {
      rootX.parent = rootY;
      if (rankX === rankY) rootY.rank++;
    }
  }

  connected(valueX: number, valueY: number): boolean {
    const rx = this.findSet(valueX);
    const ry = this.findSet(valueY);
    return rx !== null && ry !== null && rx === ry;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Demo
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const ds = new DisjointSetForest();
for (let i = 0; i < 10; i++) ds.makeSet(i);

ds.union(1, 2);
ds.union(2, 3);
ds.union(4, 5);
ds.union(3, 5);

console.log("1 and 5 connected?", ds.connected(1, 5)); // true
console.log("0 and 9 connected?", ds.connected(0, 9)); // false
```

### Important Notes

- MAKE-SET: O(1)
- FIND-SET: amortized O(Î±(n)) with path compression
- UNION: amortized O(Î±(n)) with union by rank
- Î±(n) effectively constant (â‰¤ 5 for practical n)
- Path compression alone is already powerful
- Both used in practice for best theoretical bound

> **Key Takeaway:** With union by rank and path compression, the disjoint-set forest achieves amortized time O(Î±(n)) per operation. Î±(n) is one of the slowest-growing functions in mathematics appearing in algorithm analysis, making practical running time essentially constant.
