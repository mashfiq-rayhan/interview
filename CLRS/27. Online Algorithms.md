# Chapter 27: Online Algorithms

> _Introduction to Algorithms, 4th Edition â€“ CLRS_

---

## ğŸ“‹ Chapter Overview

| Section | Topic                     | Key Idea                                                                      |
| ------- | ------------------------- | ----------------------------------------------------------------------------- |
| 27.1    | Waiting for an Elevator   | Online decision making with competitive ratio 2 for elevator closing strategy |
| 27.2    | Maintaining a Search List | Move-to-Front list update achieving 2-competitive online algorithm            |
| 27.3    | Online Caching            | LRU and FIFO caching achieving k-competitive bounds for cache replacement     |

---

## 27.1 Waiting for an Elevator

### ğŸ“– Overview

This section introduces the **online algorithms** concept through a very intuitive and illustrative example: deciding when to close the elevator doors.

### ğŸ’¡ Core Idea

#### Problem Definition

- You are inside an elevator
- People keep entering one by one
- At any moment you can decide to close the doors and go
- You want to **minimize the total waiting time** of all passengers (including yourself)
- You do **not** know how many more people will arrive in the future
- Once you close the doors, no more people can enter â€” the elevator leaves immediately

This is a classic **online decision problem**:

| Characteristic            | Description                                                                          |
| ------------------------- | ------------------------------------------------------------------------------------ |
| **Irrevocable decisions** | You must make decisions without knowing future input                                 |
| **Goal**                  | Strategy whose performance is reasonably close to the best possible offline solution |

### ğŸ“Š Competitive Analysis

The standard way to evaluate online algorithms is **competitive analysis**:

Let:

- $ALG$ = total waiting time produced by your online algorithm
- $OPT$ = total waiting time produced by the optimal offline algorithm (which knows everything in advance)

> **Definition:** The algorithm is **c-competitive** if for every possible input sequence:
> $$ALG \leq c \cdot OPT + \text{additive constant}$$
> The smallest such $c$ is the **competitive ratio**.

### ğŸ”¢ The Elevator Example â€“ Key Results

Suppose people arrive at times $t_1 \leq t_2 \leq \ldots \leq t_k$ (arrival times are increasing).

| Metric                     | Formula                              |
| -------------------------- | ------------------------------------ |
| Waiting time of person $i$ | departure time $- t_i$               |
| Total waiting time         | $\sum (\text{departure time} - t_i)$ |

**Optimal Offline Strategy:** Wait for the last person and then leave.

**Online Challenge:** You don't know who is last!

#### Simple 2-Competitive Strategy

At any moment $t$, compute:

- $W_{now}$ = current total waiting time accumulated so far
- If you leave now, the total waiting time will be $W_{now}$
- If you wait for one more person, the extra cost is at least the waiting time of all current people during that extra time

> **Rule:** Close the doors when $W_{now} \geq$ max possible extra cost if you wait longer

#### Key Theoretical Results

| Result            | Description                                                          |
| ----------------- | -------------------------------------------------------------------- |
| **Lower bound**   | No deterministic online algorithm can be better than 2-competitive   |
| **Upper bound**   | There is a simple deterministic algorithm that is 2-competitive      |
| **Randomization** | With randomization, you can achieve expected competitive ratio $< 2$ |

### ğŸ“ Pseudocode

**2-competitive deterministic elevator algorithm:**

```text
current_waiting_time â† 0
people_inside â† 0
last_arrival_time â† 0

while true:
    if no one is waiting to enter:
        if people_inside > 0:
            close doors and leave
        else:
            wait for next person

    wait until next person arrives or decide to close

    when a new person arrives at time t:
        // add waiting time for all people already inside
        current_waiting_time += people_inside Ã— (t - last_arrival_time)
        people_inside â† people_inside + 1
        last_arrival_time â† t

    // Decision point: should we close now?
    if current_waiting_time â‰¥ people_inside Ã— (some estimate of future wait):
        close doors and leave
```

> **Note:** The book gives a clean deterministic rule achieving competitive ratio 2. The exact rule is: close the doors at the first moment when the current accumulated waiting time is at least as large as the waiting time that would be caused if you waited for exactly one more person.

### ğŸ’» TypeScript Implementation

```typescript
interface Arrival {
  time: number;
  id: number;
}

function elevatorWaiting(arrivals: Arrival[]): {
  closeTime: number;
  totalWaiting: number;
} {
  // Sort arrivals just in case (normally they come in order)
  arrivals.sort((a, b) => a.time - b.time);

  let currentTime = 0;
  let peopleInside = 0;
  let totalWaiting = 0;
  let accumulatedWaiting = 0;
  let lastEventTime = 0;
  let i = 0; // index of next arrival

  while (true) {
    // Advance time to next event (next arrival or potential close)
    let nextTime: number;
    if (i < arrivals.length) {
      nextTime = arrivals[i].time;
    } else {
      // No more arrivals â†’ close immediately if someone is inside
      if (peopleInside > 0) {
        // Add final waiting time
        totalWaiting += accumulatedWaiting;
        return { closeTime: currentTime, totalWaiting };
      } else {
        return { closeTime: currentTime, totalWaiting: 0 };
      }
    }

    // Add waiting time for the time interval
    const delta = nextTime - lastEventTime;
    accumulatedWaiting += peopleInside * delta;
    totalWaiting += peopleInside * delta;

    currentTime = nextTime;
    lastEventTime = nextTime;

    // New person arrives
    if (i < arrivals.length && arrivals[i].time === currentTime) {
      peopleInside++;
      i++;
    }

    // Decision: should we close now?
    // 2-competitive rule (simplified version): close when accumulated waiting
    // is at least as large as the cost if we wait for one more person
    if (peopleInside > 0 && accumulatedWaiting >= peopleInside * 1) {
      // Close doors
      totalWaiting += accumulatedWaiting;
      return { closeTime: currentTime, totalWaiting };
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const arrivals = [
  { time: 0, id: 1 },
  { time: 3, id: 2 },
  { time: 5, id: 3 },
  { time: 10, id: 4 },
  { time: 12, id: 5 },
];

const result = elevatorWaiting(arrivals);

console.log("Close time:", result.closeTime);
console.log("Total waiting time:", result.totalWaiting);
```

### âš ï¸ Important Notes

- This is a classic **online problem** â€” decisions are irrevocable and future arrivals are unknown
- The competitive ratio of **2 is optimal** for deterministic algorithms
- No deterministic algorithm can achieve better than 2 in the worst case
- **Randomized algorithms** can achieve expected competitive ratio $< 2$ (e.g., randomized threshold strategies)
- The problem is closely related to the **ski-rental problem** and **online bidding** â€” all are about deciding when to stop waiting
- Very intuitive way to understand the difference between online and offline algorithms
- The elevator example is pedagogical but captures the essence of many real online decision problems (server scheduling, TCP acknowledgment, etc.)

### âœ… Key Takeaway

> The "waiting for an elevator" problem illustrates the core challenge of online algorithms: you must make **irrevocable decisions** (when to close the doors) without knowing future arrivals. The optimal offline strategy waits for the last person, but online you cannot know who is last. A simple deterministic strategy achieves a **competitive ratio of 2** (worst-case total waiting time is at most twice the optimal offline), and this ratio is provably optimal for deterministic algorithms. The example beautifully introduces the concept of **competitive analysis**, which is the main tool for evaluating online algorithms.

---

## 27.2 Maintaining a Search List

### ğŸ“– Overview

This section presents a classic online list update problem (also known as the **list update problem** or **self-organizing list problem** in the online setting).

### ğŸ’¡ Problem Definition

You maintain an ordered list of $n$ items (e.g., files, records, web bookmarks, menu items, etc.).

**Requests arrive online (one by one):**

| Step | Description                                                                                                          |
| ---- | -------------------------------------------------------------------------------------------------------------------- |
| 1    | Each request is for a particular item $x$                                                                            |
| 2    | You must search for $x$ by scanning the list sequentially from the front until you find it                           |
| 3    | The **cost** of a request is the position of the item in the current list (1 for first position, 2 for second, etc.) |
| 4    | After finding $x$, you can reorganize the list (move $x$ and/or other items) at **no extra cost**                    |

**Goal:** Minimize the total search cost over a sequence of requests.

This is an **online problem** because you must decide how to reorganize after each request without knowing future requests.

### ğŸ“Š Competitive Analysis

| Concept              | Description                                                                  |
| -------------------- | ---------------------------------------------------------------------------- |
| **Offline optimum**  | Knows the entire request sequence in advance and can rearrange optimally     |
| **Online algorithm** | Must make decisions immediately after each request                           |
| **c-competitive**    | $ALG \leq c \cdot OPT + \text{additive constant}$ for every request sequence |

### ğŸ”„ Classic Online Algorithms

| Algorithm               | Description                                                | Competitive Ratio         |
| ----------------------- | ---------------------------------------------------------- | ------------------------- |
| **Move-To-Front (MTF)** | After accessing item $x$, move it to the front of the list | **2-competitive** (tight) |
| **Transpose**           | Swap the accessed item with the one immediately before it  | Much weaker               |
| **Frequency Count**     | Keep list sorted by decreasing access frequency            | Good in practice          |
| **BIT (randomized)**    | Randomized algorithm                                       | **1.75-competitive**      |

The book focuses mainly on **Move-To-Front** and proves that it is **2-competitive**.

#### Why MTF is Good

- **Intuitively:** Items that are accessed often tend to stay near the front
- The 2-competitiveness proof is elegant and uses a **potential function** or **pairwise interchange argument**

### ğŸ“ Pseudocode

**MOVE-TO-FRONT (MTF):**

```text
list â† initial ordered list of n items

for each request x in online sequence:
    cost â† position of x in current list      // 1-based index
    find x in the list
    move x to the front of the list           // reorganize
    output cost
```

### ğŸ’» TypeScript Implementation

```typescript
class MoveToFrontList {
  private list: string[]; // current order of items

  constructor(initialItems: string[]) {
    this.list = [...initialItems]; // copy initial order
  }

  access(item: string): { cost: number; newPosition: number } {
    const index = this.list.indexOf(item);

    if (index === -1) {
      throw new Error(`Item "${item}" not found in list`);
    }

    const cost = index + 1; // 1-based position

    // Move to front (splice and insert at beginning)
    this.list.splice(index, 1);
    this.list.unshift(item);

    return {
      cost,
      newPosition: 1, // now at position 1
    };
  }

  getCurrentOrder(): string[] {
    return [...this.list];
  }

  getTotalCost(requests: string[]): number {
    let totalCost = 0;

    for (const req of requests) {
      const { cost } = this.access(req);
      totalCost += cost;
    }

    return totalCost;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const initialList = ["A", "B", "C", "D", "E"];
const mtf = new MoveToFrontList(initialList);

const requests = ["C", "B", "A", "D", "C", "E", "B", "C", "A", "D"];

console.log("Initial order:", mtf.getCurrentOrder());

let totalCost = 0;
const costs: number[] = [];

for (const req of requests) {
  const { cost } = mtf.access(req);
  costs.push(cost);
  totalCost += cost;
  console.log(
    `Access ${req} â†’ cost = ${cost}, new order:`,
    mtf.getCurrentOrder(),
  );
}

console.log("\nRequest sequence:", requests.join(" â†’ "));
console.log("Costs per access: ", costs.join(", "));
console.log("Total search cost:", totalCost);
```

### âš ï¸ Important Notes

- **Move-To-Front (MTF)** is **2-competitive** â€” its total cost is at most twice the optimal offline cost (plus small additive constant)
- The bound of 2 is **tight** â€” there exist request sequences where MTF pays almost exactly twice OPT
- **No deterministic** online algorithm can achieve better than 2 in the worst case
- MTF is extremely simple and performs **surprisingly well in practice**
- The list update problem is one of the most studied problems in online algorithms
- **Randomized algorithms** (e.g., BIT algorithm) can achieve better expected competitive ratio â‰ˆ 1.75
- Related to self-organizing lists, move-to-front heuristic, online caching, and dynamic optimality conjectures

### âœ… Key Takeaway

> The **list update problem** (or self-organizing list problem) is a classic online problem: you maintain an ordered list and pay for the position each time an item is requested. After each request you can rearrange the list for free. The **Move-To-Front (MTF)** rule â€” moving the accessed item to the front â€” is simple, natural, and provably **2-competitive**, meaning its total cost is at most twice that of the optimal offline algorithm. This ratio is optimal for deterministic online algorithms. The problem beautifully illustrates the power and limitations of online decision-making and competitive analysis.

---

## 27.3 Online Caching

### ğŸ“– Overview

This section presents one of the most famous and most studied problems in online algorithms: the **caching problem** (also known as the **page replacement problem** or **cache replacement problem**).

### ğŸ’¡ Problem Definition

| Component    | Description                                                           |
| ------------ | --------------------------------------------------------------------- |
| **Cache**    | Can hold at most $k$ pages/items at a time                            |
| **Requests** | A sequence of page references arrives online: $r_1, r_2, \ldots, r_m$ |

**For each request $r_i$:**

| Event          | Description                            | Cost |
| -------------- | -------------------------------------- | ---- |
| **Cache Hit**  | Requested page is already in the cache | 0    |
| **Cache Miss** | Requested page is not in the cache     | 1    |

On a miss:

1. We must fetch the page into the cache
2. If the cache is already full (has $k$ pages), we must **evict** one existing page to make room

**Goal:** Design an online eviction policy that **minimizes the total number of cache misses**.

The algorithm must decide which page to evict **immediately** upon a miss when the cache is full â€” without knowledge of future requests.

### ğŸ“Š Offline Optimum (Belady's Algorithm)

The optimal offline algorithm is **Belady's algorithm** (also called MIN or OPT):

> **Rule:** When the cache is full and a miss occurs, evict the page that will be requested **farthest in the future**.

This gives the absolute minimum number of misses possible â€” but it requires knowing the entire future request sequence.

### ğŸ”„ Classic Online Algorithms

| Algorithm                       | Strategy                                                    | Competitive Ratio                 |
| ------------------------------- | ----------------------------------------------------------- | --------------------------------- |
| **FIFO** (First-In, First-Out)  | Evict the page that has been in the cache the longest       | $k$-competitive                   |
| **LRU** (Least Recently Used)   | Evict the page whose most recent access was the longest ago | $k$-competitive                   |
| **LFU** (Least Frequently Used) | Evict the page that has been used the least number of times | Can suffer from "cache pollution" |
| **Randomized Marking**          | Randomized algorithm                                        | Better expected bounds            |

### ğŸ“ˆ Key Theoretical Results

> **Theorem:** Any deterministic online caching algorithm has competitive ratio **at least $k$**.

> **Theorem:** LRU and FIFO are both **$k$-competitive** (tight bound).

In other words: in the worst case, any deterministic online algorithm can be forced to suffer $k$ times as many misses as the optimal offline algorithm.

### ğŸ“ Pseudocode

**LRU (Least Recently Used) â€“ Online Caching:**

```text
cache â† empty set or list of size at most k
order â† doubly linked list or ordered structure to track recency

for each request page in sequence:
    if page is in cache:
        // cache hit
        move page to most-recently-used position (front/head of order)
    else:
        // cache miss
        if cache is full (|cache| = k):
            evict the least-recently-used page
            (remove the item at the tail/end of the order)
        add page to cache
        place page at most-recently-used position (front of order)
```

### ğŸ’» TypeScript Implementation

```typescript
class LRUCache {
  private capacity: number;
  private cache: Map<string, number>; // key â†’ value (we only care about keys here)
  private order: string[]; // most recent at index 0

  constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
    this.order = [];
  }

  access(page: string): boolean {
    // Returns true = hit, false = miss

    if (this.cache.has(page)) {
      // Hit: move to front (most recent)
      const index = this.order.indexOf(page);
      this.order.splice(index, 1);
      this.order.unshift(page);
      return true;
    }

    // Miss
    if (this.cache.size >= this.capacity) {
      // Evict least recently used (last element)
      const lru = this.order.pop()!;
      this.cache.delete(lru);
    }

    // Add new page to front
    this.cache.set(page, 1); // dummy value
    this.order.unshift(page);

    return false;
  }

  getMissCount(requests: string[]): number {
    let misses = 0;

    for (const page of requests) {
      if (!this.access(page)) {
        misses++;
      }
    }

    return misses;
  }

  getCurrentCache(): string[] {
    return [...this.order];
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const requests = [
  "A",
  "B",
  "C",
  "D",
  "A",
  "B",
  "E",
  "A",
  "C",
  "D",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "A",
  "B",
  "C",
];

const cache = new LRUCache(3); // cache size k = 3

console.log("Processing requests:", requests.join(" â†’ "));
const misses = cache.getMissCount(requests);

console.log("\nTotal cache misses:", misses);
console.log(
  "Final cache content (most recent first):",
  cache.getCurrentCache(),
);
```

### âš ï¸ Important Notes

- The caching problem is one of the **most fundamental** and widely studied online problems
- **LRU** is $k$-competitive â€” worst-case competitive ratio exactly $k$
- **No deterministic** online algorithm can achieve better than $k$-competitive ratio
- **Belady's MIN/OPT** algorithm (evict farthest-in-future) is optimal offline but not online
- In practice, LRU performs very well in many real-world caching scenarios:
  - Databases
  - Operating systems
  - Web browsers
  - CDNs
- **Randomized algorithms** exist with better expected competitive ratio (â‰ˆ 1.5â€“2 depending on the variant)
- Related to paging, virtual memory, web caching, disk caching, and many resource management problems

### âœ… Key Takeaway

> The **online caching problem** (or page replacement problem) requires deciding which page to evict when the cache is full and a miss occurs â€” without knowledge of future requests. Any deterministic online algorithm has competitive ratio **at least $k$** (where $k$ is cache size). **LRU (Least Recently Used)** achieves this bound of $k$ and is very widely used in practice due to its simplicity and strong empirical performance. The caching problem is a cornerstone example in online algorithms and competitive analysis, illustrating both the power and the fundamental limits of online decision-making.

---

## ğŸ“š Chapter Summary

| Problem              | Algorithm           | Competitive Ratio | Key Insight                                         |
| -------------------- | ------------------- | ----------------- | --------------------------------------------------- |
| **Elevator Closing** | Threshold-based     | **2**             | Close when accumulated wait â‰¥ potential future cost |
| **List Update**      | Move-To-Front (MTF) | **2**             | Move accessed item to front                         |
| **Online Caching**   | LRU / FIFO          | **$k$**           | Evict least recently used page                      |

### Key Concepts

- **Online algorithms** make irrevocable decisions without knowing future input
- **Competitive analysis** compares online algorithm cost to optimal offline cost
- **Competitive ratio** $c$ means: $ALG \leq c \cdot OPT + O(1)$
- **Deterministic lower bounds** show fundamental limits of online decision-making
- **Randomization** often achieves better expected competitive ratios
- These problems appear everywhere: scheduling, caching, resource allocation, network routing, etc.

### Competitive Ratio Summary

| Problem     | Deterministic Lower Bound | Best Deterministic      | Randomized  |
| ----------- | ------------------------- | ----------------------- | ----------- |
| Elevator    | 2                         | 2 (optimal)             | $< 2$       |
| List Update | 2                         | 2 (MTF, optimal)        | ~1.75 (BIT) |
| Caching     | $k$                       | $k$ (LRU/FIFO, optimal) | $O(\log k)$ |
 