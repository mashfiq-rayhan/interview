# 11. Hash Tables

## ğŸ“‹ Chapter Overview

| Section  | Topic                    | Key Idea                                       |
| -------- | ------------------------ | ---------------------------------------------- |
| **11.1** | Direct-address tables    | O(1) operations with small key universe        |
| **11.2** | Hash tables (chaining)   | Expected O(1) with collisions handled by lists |
| **11.3** | Hash functions           | Uniform, fast mapping from keys to slots       |
| **11.4** | Open addressing          | Probing-based collision resolution (no lists)  |
| **11.5** | Practical considerations | Load factor, resizing, and real-world tuning   |

---

## 11.1 Direct-address tables

Direct-address tables are the simplest and fastest form of a dictionary (key â†’ value store) when the keys are taken from a small, known universe of integers â€” typically 0 to uâˆ’1 where u is not too large.

---

### Core Idea

We use the key itself as the array index.

```text
If the key universe is {0, 1, ..., uâˆ’1},
then we create an array T[0..uâˆ’1] where
T[k] = value associated with key k
       or NIL if no such key exists

â†’ Access, insert, delete all become O(1) â€” no hashing, no probing, no collisions.
```

---

### Operations & Time Complexity

| Operation                          | Time Complexity | Description  |
| ---------------------------------- | --------------- | ------------ |
| Direct-Address-Search(T, k)        | O(1)            | return T[k]  |
| Direct-Address-Insert(T, k, value) | O(1)            | T[k] â† value |
| Direct-Address-Delete(T, k)        | O(1)            | T[k] â† NIL   |

---

### Pseudocode (CLRS style â€“ 0-based keys)

```pseudocode
DIRECT-ADDRESS-SEARCH(T, k)
    return T[k]

DIRECT-ADDRESS-INSERT(T, k, x)
    T[k] â† x

DIRECT-ADDRESS-DELETE(T, k)
    T[k] â† NIL
```

---

### TypeScript â€“ Direct-address Table

```ts
class DirectAddressTable<T> {
  private table: (T | null)[];

  /**
   * @param universeSize - maximum key value + 1 (keys are 0 to universeSize-1)
   */
  constructor(universeSize: number) {
    this.table = new Array(universeSize).fill(null);
  }

  /**
   * Insert or update key â†’ value
   * O(1)
   */
  insert(key: number, value: T): void {
    if (key < 0 || key >= this.table.length) {
      throw new Error("Key out of universe range");
    }
    this.table[key] = value;
  }

  /**
   * Search for value by key
   * O(1)
   */
  search(key: number): T | null {
    if (key < 0 || key >= this.table.length) {
      return null;
    }
    return this.table[key];
  }

  /**
   * Delete key (set to null)
   * O(1)
   */
  delete(key: number): void {
    if (key >= 0 && key < this.table.length) {
      this.table[key] = null;
    }
  }

  /**
   * Check if key exists
   * O(1)
   */
  has(key: number): boolean {
    return this.search(key) !== null;
  }

  // For debugging
  printNonNull(): void {
    const entries: [number, T][] = [];
    this.table.forEach((val, idx) => {
      if (val !== null) {
        entries.push([idx, val]);
      }
    });
    console.log("Non-null entries:", entries);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const universe = 100; // keys 0 to 99
const dict = new DirectAddressTable<string>(universe);

dict.insert(42, "answer to life");
dict.insert(7, "lucky number");
dict.insert(0, "zero");

console.log("Search 42:", dict.search(42)); // "answer to life"
console.log("Search 99:", dict.search(99)); // null

dict.delete(7);
console.log("After delete 7:", dict.search(7)); // null

dict.printNonNull();
// Example output:
// Non-null entries: [ [0, 'zero'], [42, 'answer to life'] ]
```

---

### Advantages & Limitations

### Advantages

- O(1) worst-case time for search, insert, delete
- Extremely simple implementation
- No hash function needed
- Predictable performance (no clustering, no collisions)

### Limitations

- Requires universe size u to be small enough to allocate array of size u
  â†’ if u is huge (e.g. 2â¶â´), impossible to store
- Wastes space if only few keys are actually used (sparsity problem)
- Keys must be non-negative integers (or easily mappable to them)

---

### When to Use Direct-address Tables

- Keys are small integers (e.g. student IDs 1â€“1000, ASCII codes 0â€“127, pixel values 0â€“255)
- Universe size u â‰ˆ O(n) or u is acceptable in memory
- You need guaranteed worst-case O(1) operations

---

### Summary Table â€“ Direct-address Table

| Property                    | Value / Note                   |
| --------------------------- | ------------------------------ |
| Time (search/insert/delete) | O(1) worst-case                |
| Space                       | O(u) â€” universe size           |
| Hashing needed?             | No                             |
| Handles collisions?         | No collisions (direct mapping) |
| Stable?                     | Yes (but not ordered)          |
| Best used when              | Small integer key universe     |

---

### Key Takeaway

> Direct-address tables are the fastest possible dictionary when the key universe is small enough to fit in memory.

---

## 11.2 Hash Tables

Hash tables solve the main limitation of direct-address tables:
when the universe of keys **U** is very large (e.g. all possible strings, 64-bit integers, URLs, etc.), we cannot afford an array of size |U|.

Hash tables give us **expected O(1)** time for **insert, search, delete** â€” even when |U| is huge â€” by using a **hash function** to map keys into a small array.

---

### Core Components of a Hash Table

1. **Hash function** `h(k)` â†’ maps key `k âˆˆ U` to a slot in `{0, 1, â€¦, mâˆ’1}`
   - `m` = number of slots in the table
   - Usually `m â‰ˆ n` or slightly larger

2. **Collision resolution strategy**
   - **Chaining** (focus of CLRS 11.2)
   - **Open addressing** (covered in 11.4)

---

### Chaining (CLRS 11.2 focus)

Each slot contains a **linked list** of all keys that hash to that slot.

```
T[0]     â†’ list of keys with h(k) = 0
T[1]     â†’ list of keys with h(k) = 1
...
T[m âˆ’ 1] â†’ list of keys with h(k) = m âˆ’ 1
```

---

### Operations & Time Complexity (Chaining)

| Operation | Average-case (expected) | Worst-case | Notes                   |
| --------- | ----------------------- | ---------- | ----------------------- |
| Search    | Î˜(1 + Î±)                | O(n)       | Î± = load factor = n / m |
| Insert    | Î˜(1)                    | O(1)       | Insert at head of list  |
| Delete    | Î˜(1 + Î±)                | O(n)       | Requires search first   |

#### Load Factor

```
Î± = n / m
```

If we keep **Î± bounded** (e.g. Î± â‰¤ 1), the expected time per operation is **O(1)**.

---

### Good Hash Functions â€“ Simple Examples

A good hash function should:

- Distribute keys **uniformly** across slots
- Be **fast** to compute
- **Minimize collisions**

#### Common Hash Functions (Integer Keys)

##### 1. Division Method (CLRS-recommended for simplicity)

```
h(k) = k mod m
```

- Choose `m` as a **prime**
- Avoid `m` close to powers of 2

##### 2. Multiplication Method

```
h(k) = âŒŠ m (kA mod 1) âŒ‹
```

- `A` is an irrational constant
- Knuth recommends:

```
A = (âˆš5 âˆ’ 1) / 2 â‰ˆ 0.6180339887
```

---

### Pseudocode â€“ Chaining Hash Table (CLRS style)

```
CHAINED-HASH-INSERT(T, k, x)
    insert x at the head of list T[h(k)]

CHAINED-HASH-SEARCH(T, k)
    search for key k in list T[h(k)]
    return the element or NIL

CHAINED-HASH-DELETE(T, x)
    delete x from the list T[h(x.key)]
```

---

### TypeScript â€“ Chained Hash Table (Educational Implementation)

```ts
class HashNode<K, V> {
  key: K;
  value: V;
  next: HashNode<K, V> | null = null;

  constructor(key: K, value: V) {
    this.key = key;
    this.value = value;
  }
}

class ChainedHashTable<K, V> {
  private table: (HashNode<K, V> | null)[];
  private size: number = 0;
  private capacity: number;

  constructor(initialCapacity: number = 16) {
    this.capacity = initialCapacity;
    this.table = new Array(initialCapacity).fill(null);
  }

  // Simple hash function (string or number keys)
  private hash(key: K): number {
    if (typeof key === "string") {
      let h = 0;
      for (let i = 0; i < key.length; i++) {
        h = (h * 31 + key.charCodeAt(i)) | 0;
      }
      return Math.abs(h) % this.capacity;
    }
    return Math.abs(Number(key)) % this.capacity;
  }

  // Insert or update
  put(key: K, value: V): void {
    const index = this.hash(key);
    let current = this.table[index];

    while (current) {
      if (current.key === key) {
        current.value = value;
        return;
      }
      current = current.next;
    }

    const newNode = new HashNode(key, value);
    newNode.next = this.table[index];
    this.table[index] = newNode;
    this.size++;

    if (this.size > this.capacity * 0.7) {
      this.resize(this.capacity * 2);
    }
  }

  // Search
  get(key: K): V | undefined {
    const index = this.hash(key);
    let current = this.table[index];

    while (current) {
      if (current.key === key) return current.value;
      current = current.next;
    }
    return undefined;
  }

  // Delete
  remove(key: K): boolean {
    const index = this.hash(key);
    let current = this.table[index];
    let prev: HashNode<K, V> | null = null;

    while (current) {
      if (current.key === key) {
        if (prev) prev.next = current.next;
        else this.table[index] = current.next;
        this.size--;
        return true;
      }
      prev = current;
      current = current.next;
    }
    return false;
  }

  // Resize and rehash
  private resize(newCapacity: number): void {
    const oldTable = this.table;
    this.capacity = newCapacity;
    this.table = new Array(newCapacity).fill(null);
    this.size = 0;

    for (const head of oldTable) {
      let current = head;
      while (current) {
        this.put(current.key, current.value);
        current = current.next;
      }
    }
  }

  print(): void {
    this.table.forEach((node, index) => {
      if (node) {
        const chain: string[] = [];
        let curr = node;
        while (curr) {
          chain.push(`${String(curr.key)}:${curr.value}`);
          curr = curr.next!;
        }
        console.log(`Bucket ${index}: ${chain.join(" â†’ ")}`);
      }
    });
  }
}
```

---

### Summary â€“ Direct-address vs Hash Tables

| Feature           | Direct-address table     | Hash table (chaining) |
| ----------------- | ------------------------ | --------------------- |
| Universe size     | Must be small (u â‰ˆ O(n)) | Can be huge           |
| Time (expected)   | O(1)                     | O(1 + Î±)              |
| Time (worst-case) | O(1)                     | O(n)                  |
| Space             | O(u)                     | O(n + m) â‰ˆ O(n)       |
| Arbitrary keys    | No                       | Yes                   |
| Collisions        | None                     | Handled via chaining  |

---

### Key Takeaway

> Direct-address tables are ideal when the key universe is small. Hash tables generalize this idea to **arbitrary key sets** by using a hash function â€” trading a small **Î± factor** in time for massive **space efficiency and flexibility**.

---

## 11.3 Hash Functions

A hash function is the core of any hash table: it maps any possible key from a (usually very large) universe **U** to a small integer in the range **[0, mâˆ’1]**, where **m** is the number of slots (buckets) in the hash table.

---

### Goals of a Good Hash Function

- **Deterministic** â€” same key â†’ always same hash value
- **Uniform distribution** â€” keys spread evenly across the **m** slots
- **Fast to compute** â€” ideally **O(1)** or very close
- **Minimal collisions** â€” avoid clustering
- **Avalanche effect** â€” small change in key â†’ large change in hash value

---

### Common Families of Hash Functions

#### 1. Division Method (simple & recommended)

[ h(k) = k \bmod m ]

**Rule of thumb:** choose **m** to be a prime not close to a power of 2.

**Example**

- m = 701 (prime)
- h(123456) = 123456 mod 701 = **80**

---

#### 2. Multiplication Method (good theoretical properties)

[ h(k) = \lfloor m (k \cdot A \bmod 1) \rfloor ]

- **A âˆˆ (0,1)**
- Knuth recommends:

[ A = (\sqrt{5} âˆ’ 1)/2 \approx 0.6180339887 ]

---

#### 3. Universal Hashing (strongest guarantee)

Choose the hash function randomly from a family **H** at runtime.

A family **H** is _universal_ if:

[ \Pr\_{h \in H}[h(k_1) = h(k_2)] \le 1/m \quad (k_1 \ne k_2) ]

**Simple universal family (integer keys):**

- Choose random:
  - a âˆˆ {1,â€¦,pâˆ’1}
  - b âˆˆ {0,â€¦,pâˆ’1}

- p is a large prime > m

[ h_{a,b}(k) = ((a \cdot k + b) \bmod p) \bmod m ]

This is **2-universal**.

---

### Practical Hash Functions for Real Keys

### Strings (polynomial rolling hash)

```ts
function simpleStringHash(key: string, m: number): number {
  let h = 0;
  const p = 31;

  for (let i = 0; i < key.length; i++) {
    h = (h * p + key.charCodeAt(i)) % m;
  }

  return Math.abs(h);
}
```

#### Common Real-world Hash Functions

- **MurmurHash, xxHash, FarmHash** â€” fast, good avalanche
- **SipHash** â€” cryptographic (DoS-resistant)
- **FNV-1a, djb2, Jenkins** â€” classic non-cryptographic

---

### TypeScript â€“ Simple Hash Table (Division Method)

```ts
class SimpleHashTable<T> {
  private table: (T | null)[];
  private m: number;

  constructor(size: number = 701) {
    this.m = size;
    this.table = new Array(size).fill(null);
  }

  private hash(key: number): number {
    return key % this.m;
  }

  put(key: number, value: T): void {
    this.table[this.hash(key)] = value;
  }

  get(key: number): T | null {
    return this.table[this.hash(key)];
  }

  delete(key: number): void {
    this.table[this.hash(key)] = null;
  }
}
```

---

### Summary â€“ Hash Function Properties

| Property      | Good hash function shouldâ€¦ | Why it matters  |
| ------------- | -------------------------- | --------------- |
| Deterministic | Same key â†’ same hash       | Correctness     |
| Uniform       | Even distribution          | Short chains    |
| Fast          | O(1) computation           | Performance     |
| Avalanche     | Large output change        | Security        |
| Universal     | Collision â‰¤ 1/m            | Provable bounds |

---

### Key Takeaway

> A good hash function is the **single most important factor** in hash table performance. Division method is simple for learning; real systems rely on fast, well-tested hashes and universal hashing when security matters.

---

## 11.4 Open Addressing

Open addressing is an alternative collision resolution strategy to **chaining (11.2)**.
Instead of storing multiple elements in linked lists, **all elements live directly in the hash table array**. Collisions are resolved by _probing_ for another slot.

---

### Core Idea

When inserting a key **k**:

1. Compute the initial slot: **h(k)**
2. If occupied â†’ probe other slots using a probe sequence
3. Insert into the first empty (or DELETED) slot

Search and delete follow the **same probe sequence**.

---

### Probing Methods

| Method            | Probe sequence                     | Properties                                                 |
| ----------------- | ---------------------------------- | ---------------------------------------------------------- |
| Linear probing    | h(k,i) = (h(k) + i) mod m          | Simple, causes **primary clustering**                      |
| Quadratic probing | h(k,i) = (h(k) + câ‚i + câ‚‚iÂ²) mod m | Reduces primary clustering, may cause secondary clustering |
| Double hashing    | h(k,i) = (hâ‚(k) + iÂ·hâ‚‚(k)) mod m   | Best distribution, closest to random                       |

**Load factor:** Î± = n / m

For open addressing:

- Î± **must be < 1**
- In practice, keep Î± â‰¤ **0.7**

---

### Linear Probing (CLRS focus)

#### Insert

```text
HASH-INSERT(T, k)
    i â† 0
    repeat
        j â† (h(k) + i) mod m
        if T[j] = NIL or DELETED
            T[j] â† k
            return j
        i â† i + 1
    until i = m
    error "hash table overflow"
```

#### Search

```text
HASH-SEARCH(T, k)
    i â† 0
    repeat
        j â† (h(k) + i) mod m
        if T[j] = k
            return j
        i â† i + 1
    until T[j] = NIL or i = m
    return NIL
```

---

### TypeScript â€“ Linear Probing Hash Table

```ts
class LinearProbingHashTable<T> {
  private table: (T | null | "DELETED")[];
  private m: number;
  private size = 0;

  constructor(capacity: number = 16) {
    this.m = capacity;
    this.table = new Array(capacity).fill(null);
  }

  private hash(key: number): number {
    return Math.abs(key) % this.m;
  }

  private probe(h: number, i: number): number {
    return (h + i) % this.m;
  }

  put(key: number, value: T): void {
    let i = 0;
    const h = this.hash(key);

    while (i < this.m) {
      const j = this.probe(h, i);
      if (this.table[j] === null || this.table[j] === "DELETED") {
        this.table[j] = value;
        this.size++;
        return;
      }
      i++;
    }
    throw new Error("Hash table overflow");
  }

  get(key: number): T | null {
    let i = 0;
    const h = this.hash(key);

    while (i < this.m) {
      const j = this.probe(h, i);
      if (this.table[j] === null) return null;
      i++;
    }
    return null;
  }
}
```

---

### Open Addressing vs Chaining

| Property       | Chaining       | Open addressing      |
| -------------- | -------------- | -------------------- |
| Memory         | Extra pointers | Single array         |
| Cache locality | Poor           | Excellent            |
| Average search | Î˜(1 + Î±)       | Î˜(1 / (1 âˆ’ Î±))       |
| Deletion       | Easy           | Needs DELETED marker |
| Load factor    | Can exceed 1   | Must be < 1          |

---

### Key Takeaways

- Open addressing is **space-efficient** and **cache-friendly**
- Performance collapses as Î± â†’ 1
- Linear probing is simple but suffers from **primary clustering**
- Double hashing gives the best practical behavior

---

## 11.5 Practical Considerations (CLRS)

This section summarizes the **engineering trade-offs** that dominate real-world hash table performance. The theory (chaining, open addressing, universal hashing) provides guarantees, but **practical choices** determine whether a hash table is fast or slow in production.

---

### 1. Load Factor (Î± = n / m)

- **Chaining**
  - Î± can be > 1 (even 5â€“10 acceptable)
  - Expected time: Î˜(1 + Î±)

- **Open Addressing**
  - Î± must stay **< 1** (practically â‰¤ 0.7â€“0.8)
  - As Î± â†’ 1, probe sequences explode

**Rule of thumb (2025)**

- Resize at Î± â‰ˆ 0.7â€“0.75 (chaining)
- Resize at Î± â‰ˆ 0.65â€“0.7 (open addressing)

---

### 2. Resizing / Rehashing

When the table becomes too full, allocate a larger table and **rehash all keys**.

### Pseudocode

```
RESIZE(T, new-size)
    let T' be a new hash table with new-size slots
    for each element x in T
        insert x into T'
    T â† T'
    m â† new-size
```

### Amortized Cost

- Each resize costs Î˜(n)
- Happens exponentially rarely
- **Amortized insertion cost: Î˜(1)**

### Important Note

During resize, **keys must be rehashed**. Real implementations store _(key, value)_ pairs, not values alone.

---

### 3. Choosing the Number of Buckets (m)

- **Division method** â†’ use **prime m**
  - Examples: 701, 1009, 2003, 4001

- **Modern approach**
  - Use **power-of-2 sizes**
  - Combine with strong multiplicative hashes
  - Modulo becomes fast bit masking

Avoid weak hashes with power-of-2 tables.

---

### 4. Deletion in Open Addressing

Direct deletion breaks probe chains.

**Solution: Tombstones (DELETED marker)**

- Search stops only on `null`
- Insert may reuse `DELETED`
- Delete sets slot to `DELETED`

---

### 5. Choosing Hash Functions in Practice

- **Strings**: MurmurHash3, xxHash, FarmHash
- **Security-sensitive**: SipHash
- **Integers**: multiply-shift, splitmix64

**Avoid** naive hashes (char sums, unrandomized mod primes).

**Modern recommendation (2025)**

> Fast 64-bit non-cryptographic hash + power-of-2 table + multiplicative mixing

---

### 6. Additional Practical Guidelines

- Initial capacity: 8, 16, 32, or next prime
- Resize factor: Ã—2 (simple) or Ã—1.5â€“1.7 (cache-friendly)
- Optional shrink: when Î± < 0.1â€“0.2
- Randomized hash seeds prevent hash flooding attacks

---

### Summary Table â€“ Practical Hash Table Tuning

| Decision             | Typical Choice (2025) | Reason                       |
| -------------------- | --------------------- | ---------------------------- |
| Collision resolution | Chaining              | Simple, stable as Î± grows    |
| Initial capacity     | 16 or prime           | Fewer early resizes          |
| Resize trigger       | Î± > 0.7â€“0.75          | Control chain/probe length   |
| Resize factor        | Ã—2                    | Amortized Î˜(1)               |
| Hash function        | xxHash / Murmur3      | Fast, good avalanche         |
| Table size           | Power of 2            | Fast indexing                |
| Deletion             | Tombstones            | Required for open addressing |

---

### Key Takeaway

> Hash tables achieve expected **Î˜(1)** time only if load factor is controlled, resizing is correct, and hash functions are high quality. Modern languages already implement these optimizationsâ€”reimplement only for custom behavior or performance tuning.
