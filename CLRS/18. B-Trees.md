# 18. B-Trees

## üìã Chapter Overview

| Section | Topic                        | Key Idea                                                                                     |
| ------- | ---------------------------- | -------------------------------------------------------------------------------------------- |
| 18.1    | Definition of B-trees        | Balanced trees with large branching factor for disk-based storage, minimizing I/O operations |
| 18.2    | Basic Operations on B-trees  | Search, create, and insert operations in O(log_t n) disk accesses                            |
| 18.3    | Deleting a Key from a B-tree | Handle deletion with underflow management via borrowing or merging                           |

---

## 18.1 Definition of B-trees

B-trees are a balanced tree data structure designed for disk-based storage systems (databases, file systems), where disk I/O is expensive compared to CPU operations.

### Key Features

- Very large branching factor (hundreds or thousands of children per node)
- All leaves at the same depth (perfectly balanced)
- Keys and children stored in nodes in sorted order

**Goal:** Minimize disk I/O ‚Äî each node sized to fill one disk page, so one read brings in many keys.

### Formal Definition (Order t ‚â• 2)

- Non-root nodes: t‚àí1 ‚â§ keys ‚â§ 2t‚àí1
- Non-root internal nodes: t ‚â§ children ‚â§ 2t
- Root: 1 ‚â§ keys ‚â§ 2t‚àí1 (if non-empty)
- All leaves at same depth
- Node with k keys has k+1 children
- Keys in node sorted: k‚ÇÅ < k‚ÇÇ < ‚Ä¶ < k‚Çñ
- Subtree i keys between key\_{i‚àí1} and key_i

### Visual Example (t=2)

```text
[10 | 20 | 30]
     /    |    |    \
 [5]   [15]  [25]   [35 | 40 | 45]
```

- Root: 3 keys ‚Üí 4 children
- Leaves: 1‚Äì3 keys each
- All leaves same level

### Why B-trees for Databases

- Disk page = 4 KB ‚Äì 64 KB ‚Üí node = page
- t large ‚Üí huge branching factor ‚Üí tree height small (3‚Äì4 levels even for billions of keys)
- One disk read brings hundreds of keys ‚Üí few I/Os per search/insert/delete

### TypeScript Node Structure

```typescript
class BTreeNode {
    keys: number[] = []
    children: BTreeNode[] = []
    isLeaf: boolean = true
    t: number

    constructor(t: number, isLeaf: boolean = true) {
        this.t = t;
        this.isLeaf = isLeaf;
    }

    insertNonFull(key: number): void { ... }
    splitChild(i: number, y: BTreeNode): void { ... }
}

const node = new BTreeNode(3);
node.keys = [10, 20, 30];
console.log("Keys:", node.keys);
```

### Important Notes

- B-trees ‚â† binary trees ‚Äî up to 2t‚àí1 keys, 2t children per node
- Perfectly balanced height
- t ‚âà one disk page (100‚Äì1000)
- Height very small ‚Üí few disk I/Os
- Search/insert/delete = O(log_t n) disk accesses
- Used in modern databases (MySQL B+tree, PostgreSQL, Oracle, etc.)

> **Key Takeaway:** B-trees generalize BSTs to high branching factor (2t children) and perfect balance, minimizing disk I/O for search/insert/delete.

---

## 18.2 Basic Operations on B-trees

### Core Operations

- Search for a key
- Create an empty B-tree
- Insert a new key (most involved)

All operations: O(log_t n) disk accesses

### 1. Searching a B-tree (B-TREE-SEARCH)

- Similar to BST search, but nodes have multiple keys & children
- Time per node: O(t)
- Total disk accesses: O(log_t n)

**Pseudocode:**

```text
B-TREE-SEARCH(x, k)
    i ‚Üê 1
    while i ‚â§ x.n and k > x.key_i
        i ‚Üê i + 1
    if i ‚â§ x.n and k = x.key_i
        return (x, i)
    else if x.isLeaf
        return NIL
    else
        return B-TREE-SEARCH(x.c_i, k)
```

### 2. Creating an empty B-tree (B-TREE-CREATE)

```text
B-TREE-CREATE(T)
    x ‚Üê allocate new disk page
    x.n ‚Üê 0
    x.isLeaf ‚Üê true
    DISK-WRITE(x)
    T.root ‚Üê x
```

### 3. Inserting a key (B-TREE-INSERT)

- Find leaf for key
- If leaf has space ‚Üí insert
- If full ‚Üí split, promote median, may propagate to root

**Pseudocode (Main Insert):**
B-TREE-INSERT(T, k)
r ‚Üê T.root
if r.n = 2t ‚àí 1
s ‚Üê allocate new node
T.root ‚Üê s
s.isLeaf ‚Üê false
s.n ‚Üê 0
s.c_1 ‚Üê r
r.p ‚Üê s
B-TREE-SPLIT-CHILD(s, 1)
B-TREE-INSERT-NONFULL(s, k)
else
B-TREE-INSERT-NONFULL(r, k)

````

**Splitting a Full Child:**

```text
B-TREE-SPLIT-CHILD(x, i)
    t ‚Üê x.t
    z ‚Üê allocate new node
    z.isLeaf ‚Üê x.c_i.isLeaf
    z.n ‚Üê t ‚àí 1
    move last t‚àí1 keys from x.c_i ‚Üí z
    if not z.isLeaf ‚Üí move last t children from x.c_i ‚Üí z
    x.c_i.n ‚Üê t ‚àí 1
    adjust children pointers
    promote middle key up to x
    DISK-WRITE(x.c_i), DISK-WRITE(z), DISK-WRITE(x)
````

**Insert into Non-Full Node:**

```text
B-TREE-INSERT-NONFULL(x, k)
    if x.isLeaf
        insert key in sorted position
        DISK-WRITE(x)
    else
        find child i
        DISK-READ(x.c_i)
        if x.c_i full ‚Üí split
        recursively insert into child
```

### TypeScript Example

```typescript
class BTreeNode {
    keys: number[] = []
    children: BTreeNode[] = []
    isLeaf: boolean
    t: number

    constructor(t: number, isLeaf: boolean = true) { ... }

    insertNonFull(key: number): void { ... }
    splitChild(i: number): void { ... }
}

// Demo
const node = new BTreeNode(3);
node.insertNonFull(10);
node.insertNonFull(20);
node.insertNonFull(5);
node.insertNonFull(30);
node.insertNonFull(15);
console.log("Keys in node:", node.keys); // [5,10,15,20,30]
```

### Important Notes

- Nodes often 100‚Äì1000 keys ‚Üí one disk read brings many keys
- Splits propagate to root only if necessary
- All operations: O(log_t n) disk accesses
- B+trees optimize range queries

> **Key Takeaway:** B-tree operations maximize disk efficiency: large nodes, splitting maintains balance, search/insert/delete = O(log_t n) disk accesses ‚Äî extremely fast for large datasets.

---

## 18.3 Deleting a Key from a B-tree

Deletion in B-trees is more complex than insertion due to underflow (< t‚àí1 keys).

### Deletion Cases

1. **Key in leaf:**
   - Remove key
   - If keys ‚â• t‚àí1 ‚Üí done
2. **Key in internal node:**
   - Replace with predecessor (largest key in left subtree) or successor (smallest key in right subtree)
   - Delete predecessor/successor from leaf
3. **Underflow (< t‚àí1 keys):**
   - Borrow from sibling if sibling has ‚â• t keys
   - Merge with sibling if both have t‚àí1 keys
   - May propagate fix to parent
   - If root becomes empty ‚Üí new root is merged child (height decreases)

### Fixing Underflow

**Case A: Borrow from sibling**

- Move separator from parent down to x
- Move key from sibling up to parent
- Adjust child pointers

**Case B: Merge with sibling**

- Move separator from parent down
- Merge nodes ‚Üí 2t‚àí1 keys
- Remove sibling pointer from parent
- Recurse if parent underflows

### Pseudocode

```text
B-TREE-DELETE(T, k)
    Find node x containing k
    if x is leaf
        remove x.key_i
        if x has < t‚àí1 keys ‚Üí B-TREE-FIX-UNDERFLOW(T, x)
    else
        y ‚Üê B-TREE-MINIMUM(x.c_{i+1})
        x.key_i ‚Üê y.key_1
        B-TREE-DELETE(T, y.key_1)

B-TREE-FIX-UNDERFLOW(T, x)
    if sibling has ‚â• t keys ‚Üí BORROW-FROM-SIBLING(x)
    else ‚Üí MERGE-SIBLINGS(x)
        if parent has < t‚àí1 keys ‚Üí recurse upward
```

### TypeScript Implementation

```typescript
class BTreeNode {
    keys: number[] = []
    children: BTreeNode[] = []
    isLeaf: boolean
    t: number

    constructor(t: number, isLeaf: boolean = true) { ... }

    deleteKey(key: number): boolean {
        const idx = this.keys.indexOf(key);
        if (idx === -1) return false;
        this.keys.splice(idx, 1);
        if (this.isLeaf && this.keys.length < this.t - 1) {
            console.warn("Underflow detected ‚Äì needs borrow/merge");
        }
        return true;
    }
}

class BTree {
    root: BTreeNode | null = null
    t: number

    constructor(t: number = 3) { this.t = t; this.root = new BTreeNode(t); }
    insert(key: number): void { ... }
    delete(key: number): void { this.root!.deleteKey(key); }
}

// Demo
const bt = new BTree(3);
bt.insert(10);
bt.insert(20);
bt.insert(5);
bt.insert(30);
bt.insert(15);
console.log("Keys:", bt.root!.keys); // [5,10,15,20,30]
bt.delete(15);
console.log("After delete 15:", bt.root!.keys); // [5,10,20,30]
```

### Important Notes

- Deletion more complex than insertion
- Underflow handled via borrow or merge
- Merges may propagate upward ‚Üí root may shrink
- All operations: O(log_t n) disk accesses
- B+trees optimize for range queries

> **Key Takeaway:** B-tree deletion uses BST deletion logic + underflow handling (borrow/merge) to maintain invariants and O(log_t n) disk efficiency ‚Äî essential for disk-based systems.
