# 7. Quicksort

## ðŸ“‹ Chapter Overview

| Section | Topic                 | Key Idea                                     |
| ------- | --------------------- | -------------------------------------------- |
| **7.1** | Quicksort description | Partition around a pivot                     |
| **7.2** | Performance           | Worst-case Î˜(nÂ²), average Î˜(n log n)         |
| **7.3** | Randomized quicksort  | Random pivot â†’ expected Î˜(n log n)           |
| **7.4** | Analysis              | Expected comparisons via indicator variables |

---

## 7.1 Description of Quicksort

Quicksort is a **widely used in-place sorting algorithm** with excellent average-case performance (**Î˜(n log n)**) and O(log n) extra space.

It is a **divide-and-conquer** algorithm that does most work during the **divide (partition) step**.

### Core Idea

1. Choose a **pivot** element from the array.
2. Partition the array around the pivot:
   - Elements â‰¤ pivot go left
   - Elements > pivot go right
   - Pivot ends in its **final sorted position**

3. Recursively sort left and right subarrays.

### Pseudocode (CLRS, 1-based indexing)

### QUICKSORT(A, p, r)

```
if p < r
    q â† PARTITION(A, p, r)      // pivot ends up at index q
    QUICKSORT(A, p, q-1)        // sort left part
    QUICKSORT(A, q+1, r)        // sort right part
```

### PARTITION(A, p, r)

```
x â† A[r]                        // pivot
 i â† p - 1                       // rightmost index of elements â‰¤ pivot
 for j â† p to r-1
     if A[j] â‰¤ x
         i â† i + 1
         swap A[i] with A[j]
 swap A[i+1] with A[r]           // place pivot in correct position
 return i + 1                     // pivot index
```

**Explanation:**

- `i` tracks the last element â‰¤ pivot.
- `j` scans the array.
- Swap elements â‰¤ pivot to the left.
- Place pivot between left and right partitions.

### TypeScript Implementation (0-based, Lomuto Partition)

```ts
function quickSort(
  arr: number[],
  low: number = 0,
  high: number = arr.length - 1,
): void {
  if (low < high) {
    const pivotIndex = partition(arr, low, high);
    quickSort(arr, low, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, high);
  }
}

function partition(arr: number[], low: number, high: number): number {
  const pivot = arr[high];
  let i = low - 1;

  for (let j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
  return i + 1;
}

// Example
const example = [64, 34, 25, 12, 22, 11, 90];
console.log("Before:", [...example]);
quickSort(example);
console.log("After: ", example);
```

### Important Characteristics

| Property          | Value / Behavior                   |
| ----------------- | ---------------------------------- |
| Worst-case time   | Î˜(nÂ²) â€“ unbalanced partitions      |
| Average-case time | Î˜(n log n) â€“ very efficient        |
| Best-case time    | Î˜(n log n) â€“ balanced partitions   |
| Space complexity  | O(log n) average (recursion stack) |
| In-place?         | Yes                                |
| Stable?           | No                                 |
| Adaptive?         | No                                 |

**Why fast in practice:**

- Excellent cache performance
- Small inner loop constants
- Randomized partitions reduce worst-case likelihood

> Next sections (7.2â€“7.4) cover performance analysis and randomized quicksort.

---

## 7.2 Performance of Quicksort

Quicksort has **excellent average-case performance (Î˜(n log n))**, but **worst-case is Î˜(nÂ²)**.

### 1. Worst-case Running Time â€“ Î˜(nÂ²)

Occurs when the partition is extremely unbalanced.

**Typical bad cases:**

- Array already sorted or reverse sorted
- All elements equal
- Pivot always smallest or largest

**Example â€“ sorted array, pivot = last element:**

```
Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Partition always produces:

- Left subarray size = nâˆ’1
- Right subarray size = 0

### Recurrence:

```
T(n) = T(n-1) + Î˜(n)
T(1) = Î˜(1)
â†’ T(n) = Î˜(nÂ²)
```

### TypeScript illustration

```ts
function badQuickSort(
  arr: number[],
  low: number = 0,
  high: number = arr.length - 1,
): void {
  if (low < high) {
    const pivotIndex = badPartition(arr, low, high);
    badQuickSort(arr, low, pivotIndex - 1);
    badQuickSort(arr, pivotIndex + 1, high);
  }
}

function badPartition(arr: number[], low: number, high: number): number {
  const pivot = arr[high];
  let i = low - 1;
  for (let j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
  return i + 1;
}

const sorted = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
badQuickSort(sorted);
```

> Still sorted, but **inefficient**.

### 2. Best-case Running Time â€“ Î˜(n log n)

Occurs when partition **perfectly balanced** each time (n/2 vs n/2).

**Recurrence:**

```
T(n) = 2T(n/2) + Î˜(n) â†’ Î˜(n log n)
```

Similar to merge sort.

### 3. Average-case Running Time â€“ Î˜(n log n)

Assumes all input permutations are equally likely.

- Pivot chosen at fixed position (last element, for example)
- Expected comparisons: Î˜(n log n)
- Intuition: any two distinct elements compared with probability 2/(jâˆ’i+1)
- Summing over all pairs â†’ Î˜(n log n)

**Full proof:** detailed in section 7.4 (randomized version).

### Summary Table â€“ Quicksort Performance

| Case             | Time Complexity | Partition Behavior              | When it Happens            |
| ---------------- | --------------- | ------------------------------- | -------------------------- |
| Worst-case       | Î˜(nÂ²)           | Extremely unbalanced (nâˆ’1 vs 0) | Sorted, reverse, all equal |
| Best-case        | Î˜(n log n)      | Perfectly balanced (n/2 vs n/2) | Lucky pivots each time     |
| Average-case     | Î˜(n log n)      | Reasonably balanced on average  | Random input, real-world   |
| Space complexity | O(log n) avg    | Recursion depth                 | O(n) worst case            |

**Practical note:**

- Deterministic pivot selection (first/last element) is vulnerable.
- Randomization or pivot heuristics (median-of-three) used in real implementations.

### Key Takeaway

> Quicksort is fast in practice due to excellent average-case performance and small constants. Deterministic versions can hit quadratic time without randomization.

---

## 7.3 A randomized version of quicksort

The deterministic quicksort (using the last element as pivot) has a very bad worst-case running time of Î˜(nÂ²) when the input is already sorted, reverse sorted, or has many equal elements.

The randomized quicksort fixes this problem elegantly by choosing the pivot at random at each recursive step.

### Why randomization helps

By picking a random pivot (uniformly from the current subarray),
no particular input ordering can consistently force bad (unbalanced) partitions.
â†’ The expected running time becomes Î˜(n log n) for any input,
even though the worst-case is still theoretically Î˜(nÂ²), it becomes extremely unlikely to occur.

### Core idea of randomized quicksort

- At each recursive call, randomly select one element from the current subarray as the pivot
- Partition around this random pivot
- Recursively sort the two resulting subarrays

### Pseudocode (CLRS style â€“ 1-based indexing)

```
RANDOMIZED-QUICKSORT(A, p, r)
    if p < r
        q â† RANDOMIZED-PARTITION(A, p, r)
        RANDOMIZED-QUICKSORT(A, p, qâˆ’1)
        RANDOMIZED-QUICKSORT(A, q+1, r)

RANDOMIZED-PARTITION(A, p, r)
    i â† RANDOM(p, r)                // choose random index uniformly
    exchange A[r] â†” A[i]            // move chosen element to end
    return PARTITION(A, p, r)       // now do ordinary partition around A[r]
```

> PARTITION is exactly the same as in the deterministic version.

### TypeScript implementation (0-based indexing)

```typescript
/**
 * Randomized Quicksort â€“ sorts array in-place in expected O(n log n) time
 */
function randomizedQuickSort(
  arr: number[],
  low: number = 0,
  high: number = arr.length - 1,
): void {
  if (low < high) {
    // Choose random pivot â†’ this is the key randomization step
    const pivotIndex = randomizedPartition(arr, low, high);

    // Recurse on left and right parts
    randomizedQuickSort(arr, low, pivotIndex - 1);
    randomizedQuickSort(arr, pivotIndex + 1, high);
  }
}

function randomizedPartition(arr: number[], low: number, high: number): number {
  // Pick random index between low and high (inclusive)
  const randomIndex = low + Math.floor(Math.random() * (high - low + 1));

  // Move the randomly chosen element to the end (pivot position)
  [arr[randomIndex], arr[high]] = [arr[high], arr[randomIndex]];

  // Now perform standard Lomuto partition around the new last element
  const pivot = arr[high];
  let i = low - 1;

  for (let j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Place pivot in its final correct position
  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];

  return i + 1; // return pivot's final index
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const arr = [64, 34, 25, 12, 22, 11, 90, 5];
console.log("Before:", [...arr]);

randomizedQuickSort(arr);
console.log("After: ", arr);
// Output example:
// Before: [64, 34, 25, 12, 22, 11, 90, 5]
// After:  [5, 11, 12, 22, 25, 34, 64, 90]
```

---

### Expected running time (high-level intuition)

The expected number of comparisons in randomized quicksort is O(n log n) â€” this is proven rigorously in section 7.4.

### Key insight:

For any two elements x and y (assume x < y),
the probability that they are compared during the algorithm is exactly 2 / (y âˆ’ x + 1)
(because the first time one of them is chosen as pivot, the other must be in the same subarray).

Summing over all pairs â†’ total expected comparisons â‰ˆ 2n ln n â†’ Î˜(n log n)

### Summary Table â€“ Deterministic vs Randomized Quicksort

| Property                   | Deterministic Quicksort            | Randomized Quicksort              |
| -------------------------- | ---------------------------------- | --------------------------------- |
| Pivot selection            | Fixed (usually last/first element) | Random element (uniform)          |
| Worst-case time            | Î˜(nÂ²)                              | Î˜(nÂ²) (very rare)                 |
| Average/Expected time      | Î˜(n log n)                         | Î˜(n log n) (for any input)        |
| Vulnerability to bad input | Very high (sorted, equal elements) | Extremely low                     |
| Practical recommendation   | Avoid                              | Standard choice in most libraries |

### Practical notes

- Almost every real-world quicksort implementation is randomized (JavaScriptâ€™s Array.sort(), Pythonâ€™s list.sort() with random pivot, etc.)
- The randomization cost is negligible (just one random number per recursive call)
- The probability of hitting a bad case is astronomically small for n â‰¥ 100

---

## 7.4 Analysis of Quicksort

This section gives the rigorous analysis of the expected running time of randomized quicksort, showing that it is Î˜(n log n) in expectation â€” no matter what the input is.
The analysis is one of the most elegant and famous in the book.
It uses indicator random variables + linearity of expectation + clever probability arguments.

### 1. Worst-case is still Î˜(nÂ²) â€” but very unlikely

Even in the randomized version, there is still a tiny probability (about 1/n!) of always choosing the worst possible pivot at every step â†’ Î˜(nÂ²) time.
But this probability is so small that in practice it almost never happens.

### 2. Goal of the analysis: Expected number of comparisons

The dominant cost in quicksort is element comparisons (during partitioning).
We want to compute the expected number of comparisons in the entire execution.

Let X\_{ij} be the indicator random variable defined as:

X*{ij} = 1 if elements with ranks i and j are compared at some point during the algorithm
X*{ij} = 0 otherwise

(Assume i < j without loss of generality â€” ranks in the final sorted order)

Total number of comparisons X = Î£*{1 â‰¤ i < j â‰¤ n} X*{ij}
By linearity of expectation (works even with dependence!):

E[X] = Î£*{1 â‰¤ i < j â‰¤ n} E[X*{ij}] = Î£\_{1 â‰¤ i < j â‰¤ n} Pr(elements i and j are compared)

### 3. Key insight: When are two elements compared?

Two distinct elements with ranks i and j (i < j) are compared exactly once â€” during the partition step in which one of them is chosen as pivot for the first time.

#### Important fact

Elements i and j are compared if and only if the first pivot chosen from the subarray containing both of them is either i or j.
Because once one of them becomes pivot, they go to different subarrays and are never compared again.

Since the pivot is chosen uniformly at random from the current subarray,
and the subarray containing both i and j initially has (j âˆ’ i + 1) elements,

Pr(elements i and j are compared) = 2 / (j âˆ’ i + 1)
(Probability that i is chosen first = 1/(jâˆ’i+1), same for j â†’ total 2/(jâˆ’i+1))

### 4. Total expected number of comparisons

E[X] = Î£\_{1 â‰¤ i < j â‰¤ n} 2 / (j âˆ’ i + 1)

This is a very famous sum â€” it can be rewritten as:

E[X] = 2 Î£*{k=2}^n Î£*{i=1}^{nâˆ’k+1} 1/k
= 2 Î£\_{k=2}^n (n âˆ’ k + 1) / k

This double sum is known to be â‰¤ 2n ln n (and asymptotically ~ 2n ln n)
More precisely:
E[X] â‰¤ 2n ln n âˆ’ 2n + O(log n)
â†’ E[X] = Î˜(n log n)

**Key result:**
The expected number of comparisons in randomized quicksort is Î˜(n log n) â€” for any input.

---

### Summary Table â€“ Randomized Quicksort Analysis

| Aspect                         | Result / Value                                    |
| ------------------------------ | ------------------------------------------------- |
| Worst-case time                | Still Î˜(nÂ²) â€” but probability ~ 1/n!              |
| Expected time (any input)      | Î˜(n log n)                                        |
| Expected number of comparisons | â‰ˆ 2n ln n â‰ˆ 1.386 n logâ‚‚ n                        |
| Probability of bad partition   | Extremely small                                   |
| Practical implication          | One of the fastest sorting algorithms in practice |

### Key lessons from 7.4

- Randomization turns a bad-worst-case algorithm into one with excellent expected performance
- Indicator variables + linearity of expectation make the analysis surprisingly clean
- The sum Î£ 2/(jâˆ’i+1) over all pairs is the classic way to prove quicksort's expected O(n log n)
- This is why randomized quicksort is used everywhere: libraries, programming contests, operating systems, etc.
