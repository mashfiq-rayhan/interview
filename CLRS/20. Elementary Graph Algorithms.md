# 20. Elementary Graph Algorithms

## üìã Chapter Overview

| Section | Topic                         | Key Idea                                                                                  |
| ------- | ----------------------------- | ----------------------------------------------------------------------------------------- |
| 20.1    | Representations of Graphs     | Adjacency lists (sparse graphs) vs adjacency matrices (dense graphs) for graph storage    |
| 20.2    | Breadth-First Search          | Level-by-level traversal using queue, finds shortest paths in unweighted graphs in O(V+E) |
| 20.3    | Depth-First Search            | Deep exploration using recursion/stack, computes discovery/finishing times in O(V+E)      |
| 20.4    | Topological Sort              | Linear ordering of DAG vertices using DFS reverse post-order in O(V+E)                    |
| 20.5    | Strongly Connected Components | Find maximal mutually reachable vertex sets using Kosaraju's algorithm in O(V+E)          |

---

## 20.1 Representations of Graphs

Graphs are one of the most versatile structures in computer science, used to model networks, roads, social connections, dependencies, and more.

### Graph Definition

A graph G = (V, E) consists of:

- **V** ‚Äî a finite set of vertices (nodes)
- **E** ‚Äî a set of edges (pairs of vertices)

### Two Main Categories

- **Directed graph (digraph):** edges have direction (u ‚Üí v ‚â† v ‚Üí u)
- **Undirected graph:** edges have no direction ({u, v} is same as {v, u})

Edges may have weights (e.g., distances, costs).

### Two Standard Representations

CLRS presents two common ways to represent a graph in memory:

- **Adjacency list** (most common in practice)
- **Adjacency matrix** (useful in some dense-graph algorithms)

### Adjacency List Representation

- Each vertex `u` maintains a list `Adj[u]` of all vertices `v` such that (u, v) ‚àà E
- **Undirected graph:** if (u, v) is an edge, then v appears in Adj[u] and u appears in Adj[v]
- **Directed graph:** v appears in Adj[u] only if there is a directed edge u ‚Üí v

**Pseudocode Structure:**

- `Adj` = array of lists, indexed by vertices
- `Adj[u]` = list of neighbors of u

**Properties:**

- Space: Œò(V + E) ‚Äî very efficient for sparse graphs
- Time to check if (u, v) is an edge: O(degree(u)) in worst case
- Very cache-friendly when iterating over neighbors
- Used in BFS, DFS, Dijkstra, Kruskal, etc.

### Adjacency Matrix Representation

- Use a |V| √ó |V| matrix `A` where:
  - `A[u][v] = 1` if (u, v) ‚àà E, 0 otherwise
  - (For weighted graphs: `A[u][v] = weight` if edge exists, ‚àû or 0 otherwise)

**Properties:**

- Space: Œò(V¬≤) ‚Äî wasteful for sparse graphs
- Time to check if (u, v) is an edge: O(1)
- Good for dense graphs or when we need fast edge lookup
- Used in Floyd-Warshall, matrix exponentiation for paths

### TypeScript Implementation

```typescript
// Adjacency List Representation

class GraphAdjList {
  private adj: Map<number, number[]> = new Map();

  addVertex(v: number): void {
    if (!this.adj.has(v)) this.adj.set(v, []);
  }

  addEdge(u: number, v: number, directed: boolean = false): void {
    this.addVertex(u);
    this.addVertex(v);
    this.adj.get(u)!.push(v);
    if (!directed) this.adj.get(v)!.push(u);
  }

  neighbors(v: number): number[] {
    return this.adj.get(v) || [];
  }

  print(): void {
    for (const [v, adjList] of this.adj) {
      console.log(`${v} ‚Üí ${adjList.join(", ")}`);
    }
  }
}

// Adjacency Matrix Representation

class GraphAdjMatrix {
  private matrix: number[][] = [];
  private vertices: number[] = [];

  addVertex(v: number): void {
    if (this.vertices.includes(v)) return;
    this.vertices.push(v);
    const size = this.vertices.length;
    this.matrix = this.matrix.map((row) => [...row, 0]);
    this.matrix.push(new Array(size).fill(0));
  }

  addEdge(
    u: number,
    v: number,
    directed: boolean = false,
    weight: number = 1,
  ): void {
    const ui = this.vertices.indexOf(u);
    const vi = this.vertices.indexOf(v);
    if (ui === -1 || vi === -1) return;
    this.matrix[ui][vi] = weight;
    if (!directed) this.matrix[vi][ui] = weight;
  }

  hasEdge(u: number, v: number): boolean {
    const ui = this.vertices.indexOf(u);
    const vi = this.vertices.indexOf(v);
    return ui !== -1 && vi !== -1 && this.matrix[ui][vi] !== 0;
  }

  print(): void {
    console.log("  ", this.vertices.join(" "));
    for (let i = 0; i < this.vertices.length; i++) {
      console.log(this.vertices[i], this.matrix[i].join(" "));
    }
  }
}

// Demo
console.log("=== Adjacency List ===");
const adjList = new GraphAdjList();
adjList.addEdge(1, 2);
adjList.addEdge(1, 3);
adjList.addEdge(2, 4);
adjList.addEdge(3, 4, true);
adjList.print();

console.log("\n=== Adjacency Matrix ===");
const adjMatrix = new GraphAdjMatrix();
adjMatrix.addVertex(1);
adjMatrix.addVertex(2);
adjMatrix.addVertex(3);
adjMatrix.addVertex(4);
adjMatrix.addEdge(1, 2);
adjMatrix.addEdge(1, 3);
adjMatrix.addEdge(2, 4);
adjMatrix.addEdge(3, 4, true);
adjMatrix.print();
```

### Important Notes

- Adjacency list ‚Äî preferred for sparse graphs (E << V¬≤) ‚Üí BFS, DFS, Dijkstra, Kruskal, Prim, etc.
- Adjacency matrix ‚Äî good for dense graphs or when you need O(1) edge lookup ‚Üí Floyd-Warshall, matrix exponentiation for paths
- Weighted graphs: adjacency list stores {neighbor, weight} pairs; matrix stores weights directly (or ‚àû if no edge)

> **Key Takeaway:** Graphs are represented using either adjacency lists (space-efficient, good for sparse graphs) or adjacency matrices (fast edge checks, good for dense graphs). Adjacency lists are the most common in practice because most real-world graphs are sparse.

---

## 20.2 Breadth-First Search

Breadth-first search (BFS) is a fundamental graph traversal algorithm that explores all vertices level by level, starting from a given source vertex `s`.
It builds a shortest-path tree from `s` in an unweighted graph (or graph with unit edge weights), meaning it finds the path with the fewest edges from `s` to every reachable vertex.

**BFS is also used to:**

- Compute shortest paths in unweighted graphs
- Find connected components
- Test bipartiteness
- Solve puzzles (sliding tiles, Rubik‚Äôs cube, etc.)

---

### Core Idea

- Use a queue to explore vertices in order of increasing distance from `s`
- Track distance `d[v]` = shortest path length from `s` to `v`
- Track parent `œÄ[v]` = parent of `v` in the shortest-path tree
- Color vertices: `WHITE` (undiscovered), `GRAY` (discovered but not finished), `BLACK` (finished)

---

### Pseudocode (BFS)

```
BFS(G, s)
    for each vertex u in G.V
        u.color ‚Üê WHITE
        u.d ‚Üê ‚àû
        u.œÄ ‚Üê NIL
    s.color ‚Üê GRAY
    s.d ‚Üê 0
    s.œÄ ‚Üê NIL
    Q ‚Üê empty queue
    ENQUEUE(Q, s)
    while Q ‚â† empty
        u ‚Üê DEQUEUE(Q)
        for each vertex v in G.Adj[u]
            if v.color = WHITE
                v.color ‚Üê GRAY
                v.d ‚Üê u.d + 1
                v.œÄ ‚Üê u
                ENQUEUE(Q, v)
        u.color ‚Üê BLACK
```

### TypeScript Implementation

```typescript
interface Graph {
  vertices: number[];
  adj: Map<number, number[]>;
}

function breadthFirstSearch(graph: Graph, start: number) {
  const distance = new Map<number, number>();
  const parent = new Map<number, number | null>();
  const color = new Map<number, "WHITE" | "GRAY" | "BLACK">();

  // Initialize
  for (const v of graph.vertices) {
    color.set(v, "WHITE");
    distance.set(v, Infinity);
    parent.set(v, null);
  }

  color.set(start, "GRAY");
  distance.set(start, 0);
  parent.set(start, null);

  const queue: number[] = [start];

  while (queue.length > 0) {
    const u = queue.shift()!;
    const neighbors = graph.adj.get(u) || [];
    for (const v of neighbors) {
      if (color.get(v) === "WHITE") {
        color.set(v, "GRAY");
        distance.set(v, distance.get(u)! + 1);
        parent.set(v, u);
        queue.push(v);
      }
    }
    color.set(u, "BLACK");
  }

  return { distance, parent };
}

// Demo
const graph: Graph = {
  vertices: [0, 1, 2, 3, 4, 5],
  adj: new Map([
    [0, [1, 4]],
    [1, [0, 2, 4]],
    [2, [1, 3]],
    [3, [2, 4, 5]],
    [4, [0, 1, 3]],
    [5, [3]],
  ]),
};

const result = breadthFirstSearch(graph, 0);

console.log("Distances from 0:");
for (const [v, d] of result.distance) console.log(`Vertex ${v}: ${d}`);
console.log("\nParents:");
for (const [v, p] of result.parent) console.log(`Vertex ${v} parent: ${p}`);
```

### Important Notes

- Time complexity: O(V + E) ‚Äî each vertex and each edge is processed once
- Space: O(V) for queue, color, distance, and parent arrays
- BFS finds shortest paths in terms of number of edges (unweighted graphs)
- The parent array `œÄ` reconstructs the shortest-path tree
- BFS explores level by level ‚Äî useful for shortest path in unweighted graphs, connected components, etc.

> **Key Takeaway:** Breadth-first search explores a graph level by level from a source vertex using a queue. It computes shortest-path distances (in number of edges) and a shortest-path tree in O(V + E) time ‚Äî one of the most fundamental graph algorithms.

---

## 20.3 Depth-First Search

Depth-first search (DFS) is a fundamental graph traversal algorithm that explores as far as possible along each branch before backtracking ‚Äî like exploring a maze by always going deeper until you hit a dead end, then back up and try the next path.

**DFS is used for:**

- Topological sorting of directed acyclic graphs (DAGs)
- Finding strongly connected components
- Detecting cycles
- Solving mazes and puzzles
- Computing discovery/finishing times (timestamps)

DFS builds a forest of trees (DFS forest), where each tree represents a connected component (in undirected graphs) or reachable set (in directed graphs).

---

### Core Idea

- Use a stack (implicit via recursion) to explore as deep as possible
- Track discovery time `d[u]` and finishing time `f[u]` for each vertex `u`
- Track parent `œÄ[u]` in the DFS tree
- Color vertices: `WHITE` (undiscovered), `GRAY` (being explored), `BLACK` (finished)

---

### Pseudocode (DFS ‚Äì Recursive)

```
DFS(G)
    for each vertex u in G.V
        u.color ‚Üê WHITE
        u.œÄ ‚Üê NIL
    time ‚Üê 0
    for each vertex u in G.V
        if u.color = WHITE
            DFS-VISIT(G, u)

DFS-VISIT(G, u)
    time ‚Üê time + 1
    u.d ‚Üê time
    u.color ‚Üê GRAY
    for each vertex v in G.Adj[u]
        if v.color = WHITE
            v.œÄ ‚Üê u
            DFS-VISIT(G, v)
    time ‚Üê time + 1
    u.f ‚Üê time
    u.color ‚Üê BLACK
```

### TypeScript Implementation

```typescript
interface Graph {
  vertices: number[];
  adj: Map<number, number[]>;
}

function depthFirstSearch(graph: Graph) {
  const discovery = new Map<number, number>();
  const finish = new Map<number, number>();
  const parent = new Map<number, number | null>();
  const color = new Map<number, "WHITE" | "GRAY" | "BLACK">();

  // Initialize
  for (const v of graph.vertices) {
    color.set(v, "WHITE");
    discovery.set(v, 0);
    finish.set(v, 0);
    parent.set(v, null);
  }

  let time = 0;

  function dfsVisit(u: number): void {
    time++;
    discovery.set(u, time);
    color.set(u, "GRAY");

    const neighbors = graph.adj.get(u) || [];
    for (const v of neighbors) {
      if (color.get(v) === "WHITE") {
        parent.set(v, u);
        dfsVisit(v);
      }
    }

    time++;
    finish.set(u, time);
    color.set(u, "BLACK");
  }

  for (const u of graph.vertices) {
    if (color.get(u) === "WHITE") dfsVisit(u);
  }

  return { discovery, finish, parent };
}

// Demo
const graph: Graph = {
  vertices: [0, 1, 2, 3, 4, 5],
  adj: new Map([
    [0, [1, 4]],
    [1, [0, 2, 4]],
    [2, [1, 3]],
    [3, [2, 4, 5]],
    [4, [0, 1, 3]],
    [5, [3]],
  ]),
};

const result = depthFirstSearch(graph);

console.log("Discovery times:");
for (const [v, d] of result.discovery) console.log(`Vertex ${v}: ${d}`);

console.log("\nFinishing times:");
for (const [v, f] of result.finish) console.log(`Vertex ${v}: ${f}`);

console.log("\nParents:");
for (const [v, p] of result.parent) console.log(`Vertex ${v} parent: ${p}`);
```

### Important Notes

- Time complexity: O(V + E) ‚Äî each vertex and each edge is processed once
- Space: O(V) for recursion stack (worst case O(V) depth), color, discovery, finish, parent
- DFS can be implemented iteratively with an explicit stack if recursion depth is a concern
- Discovery and finishing times are useful for topological sort, strongly connected components, cycle detection
- DFS explores deep first ‚Üí good for finding long paths, cycles, connected components

> **Key Takeaway:** Depth-first search explores a graph as deeply as possible along each branch before backtracking, using recursion (or a stack). It runs in O(V + E) time and produces discovery/finishing times and a forest of trees ‚Äî fundamental for many graph algorithms (topological sort, SCC, cycle detection).

---

## 20.4 Topological Sort

Topological sort (topological ordering) is a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge uv, vertex u comes before v in the ordering.
If the graph has a cycle ‚Üí no topological order exists.

**Topological sort is used in:**

- Course scheduling (prerequisites)
- Build systems (makefiles, dependencies)
- Data serialization (task dependencies)
- Detecting cycles in directed graphs

There are two standard ways to compute a topological sort using graph traversal:

- Using DFS (depth-first search) ‚Äî most common in CLRS
- Using Kahn‚Äôs algorithm (BFS-based with indegrees) ‚Äî also very intuitive

Both run in O(V + E) time.

---

### 1. Topological Sort Using DFS

**Idea:**

- Perform DFS on the graph
- When a vertex finishes (all its descendants are visited), add it to the front of a list
- The resulting list (in reverse finishing order) is a valid topological sort

**Pseudocode:**

```text
TOPOLOGICAL-SORT(G)
    let list ‚Üê empty list
    for each vertex u in G.V
        u.color ‚Üê WHITE
    for each vertex u in G.V
        if u.color = WHITE
            DFS-TOPO(G, u, list)
    return list

DFS-TOPO(G, u, list)
    u.color ‚Üê GRAY
    for each vertex v in G.Adj[u]
        if v.color = WHITE
            DFS-TOPO(G, v, list)
    u.color ‚Üê BLACK
    list.insert-front(u)
```

### TypeScript Implementation

```typescript
interface Graph {
  vertices: number[];
  adj: Map<number, number[]>;
}

function topologicalSortDFS(graph: Graph): number[] | null {
  const color = new Map<number, "WHITE" | "GRAY" | "BLACK">();
  const topoOrder: number[] = [];

  // Initialize colors
  for (const v of graph.vertices) color.set(v, "WHITE");

  function dfsVisit(u: number): boolean {
    color.set(u, "GRAY");
    const neighbors = graph.adj.get(u) || [];
    for (const v of neighbors) {
      if (color.get(v) === "GRAY") return false; // Cycle detected
      if (color.get(v) === "WHITE") {
        if (!dfsVisit(v)) return false;
      }
    }
    color.set(u, "BLACK");
    topoOrder.unshift(u); // reverse post-order
    return true;
  }

  for (const u of graph.vertices) {
    if (color.get(u) === "WHITE") {
      if (!dfsVisit(u)) return null; // cycle detected
    }
  }

  return topoOrder;
}

// Demo (DAG: 0 ‚Üí 1, 0 ‚Üí 2, 1 ‚Üí 3, 2 ‚Üí 3, 3 ‚Üí 4, 2 ‚Üí 5)
const graph: Graph = {
  vertices: [0, 1, 2, 3, 4, 5],
  adj: new Map([
    [0, [1, 2]],
    [1, [3]],
    [2, [3, 5]],
    [3, [4]],
    [4, []],
    [5, []],
  ]),
};

const topo = topologicalSortDFS(graph);

if (topo) {
  console.log("Topological order:", topo);
} else {
  console.log("Graph contains a cycle ‚Äî no topological sort possible");
}
```

### Important Notes

- DFS-based topological sort produces the reverse post-order (finishing times descending)
- Time complexity: O(V + E) ‚Äî same as DFS
- If the graph has a cycle ‚Üí DFS will detect it (back edge to gray node) ‚Üí no topological sort exists
- Kahn's algorithm (BFS-based) is an alternative: use indegrees + queue ‚Üí also O(V + E)
- Topological sort is unique only if the graph is a linear chain
- Real-world use: build systems, task scheduling, course prerequisites, dependency resolution

> **Key Takeaway:** Topological sort orders vertices so that for every directed edge uv, u appears before v. It can be computed efficiently using DFS (reverse post-order) or BFS (Kahn's algorithm with indegrees). Both run in O(V + E) time and detect cycles if no valid order exists.

---

## 20.5 Strongly Connected Components

A strongly connected component (SCC) of a directed graph is a maximal subset of vertices such that every vertex is reachable from every other vertex in the subset (via directed paths).
In other words: in an SCC, you can get from any node to any other node following the edge directions.
The graph of SCCs (contracting each SCC to a single node) forms a DAG (directed acyclic graph).

**Finding SCCs is useful in:**

- Graph analysis (dependency graphs, social networks, program flow)
- Kosaraju‚Äôs algorithm, Tarjan‚Äôs algorithm, etc.
- Applications: identifying cycles in build systems, compiler optimization, etc.

---

### Kosaraju‚Äôs Algorithm

Kosaraju‚Äôs algorithm finds SCCs in two DFS passes:

1. **First DFS on the original graph G**
   - Compute finishing times `f[u]` for each vertex `u`
   - Record vertices in decreasing order of finishing times (reverse post-order)

2. **Second DFS on the transpose graph G·µÄ (reverse all edge directions)**
   - Process vertices in the order computed in step 1
   - Each DFS tree found in this pass is one SCC

Transpose graph `G·µÄ` has the same vertices as `G`, and edge `(u,v)` in `G` becomes `(v,u)` in `G·µÄ`.

**Pseudocode:**

```text
STRONGLY-CONNECTED-COMPONENTS(G)
    call DFS(G) to compute finishing times f[u] for each u
    compute the transpose graph G·µÄ
    call DFS(G·µÄ), but in the main loop of DFS,
        consider vertices in order of decreasing f[u]
    each tree in the forest produced in step 3 is an SCC
```

**Why it works (high-level intuition):**

- In the first DFS pass, finishing times order vertices such that if there is a path from `u` to `v`, then `f[u] ‚â• f[v]` (in most cases)
- In the transpose graph `G·µÄ`, paths reverse direction
- Processing in decreasing finishing time order ensures that each DFS tree in the second pass corresponds exactly to one SCC

### TypeScript Implementation

```typescript
interface Graph {
  vertices: number[];
  adj: Map<number, number[]>;
}

function stronglyConnectedComponents(graph: Graph): number[][] {
  const visited = new Set<number>();
  const finishOrder: number[] = [];

  // Step 1: DFS on original graph to get finishing times
  function dfs1(u: number) {
    visited.add(u);
    for (const v of graph.adj.get(u) || []) {
      if (!visited.has(v)) dfs1(v);
    }
    finishOrder.push(u);
  }

  for (const u of graph.vertices) if (!visited.has(u)) dfs1(u);

  // Step 2: Build transpose graph G·µÄ
  const transpose: Map<number, number[]> = new Map();
  for (const u of graph.vertices) transpose.set(u, []);
  for (const u of graph.vertices) {
    for (const v of graph.adj.get(u) || []) {
      transpose.get(v)!.push(u);
    }
  }

  // Step 3: DFS on transpose graph in reverse finishing order
  visited.clear();
  const sccs: number[][] = [];

  function dfs2(u: number, component: number[]) {
    visited.add(u);
    component.push(u);
    for (const v of transpose.get(u) || []) {
      if (!visited.has(v)) dfs2(v, component);
    }
  }

  for (let i = finishOrder.length - 1; i >= 0; i--) {
    const u = finishOrder[i];
    if (!visited.has(u)) {
      const component: number[] = [];
      dfs2(u, component);
      sccs.push(component);
    }
  }

  return sccs;
}

// Demo
const graph: Graph = {
  vertices: [0, 1, 2, 3, 4, 5],
  adj: new Map([
    [0, [1]],
    [1, [2]],
    [2, [0, 3]],
    [3, [4]],
    [4, [5]],
    [5, [3]],
  ]),
};

const sccs = stronglyConnectedComponents(graph);
console.log("Strongly Connected Components:");
sccs.forEach((comp, idx) => console.log(`SCC ${idx + 1}:`, comp));
```

### Important Notes

- Time complexity: O(V + E) ‚Äî two full DFS traversals
- Space: O(V) for visited, recursion stack, transpose graph
- Kosaraju's algorithm is simple and easy to implement
- Alternative: Tarjan's algorithm (single DFS pass, more efficient but harder to code)
- Real-world use: finding connected groups in social networks, compiler optimization, dependency analysis

> **Key Takeaway:** Kosaraju's algorithm finds strongly connected components in a directed graph in O(V + E) time using two DFS passes: one on the original graph to compute finishing times, and one on the transpose graph in reverse finishing order. Each tree found in the second pass is one SCC.
