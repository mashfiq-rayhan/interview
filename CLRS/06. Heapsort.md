# 6. Heapsort

## üìã Chapter Overview

| Section | Topic           | Key Idea                             |
| ------- | --------------- | ------------------------------------ |
| **6.1** | Heaps           | Complete binary tree + heap property |
| **6.2** | Heapify         | Restore heap property in O(log n)    |
| **6.3** | Build heap      | Linear-time heap construction        |
| **6.4** | Heapsort        | In-place Œò(n log n) sorting          |
| **6.5** | Priority queues | Efficient max/min operations         |

---

## 6.1 Heaps

A heap is a very useful data structure that efficiently supports two key operations:

‚Ä¢ Finding and removing the minimum (or maximum) element
‚Ä¢ Inserting new elements

It serves as the foundation for **Heapsort** (in-place sorting in Œò(n log n)) and **priority queues**.

### Two main types of heaps

‚Ä¢ **Max-heap**: parent ‚â• children (root is the largest element)

‚Ä¢ **Min-heap**: parent ‚â§ children (root is the smallest element)

Most of the book (including Heapsort) uses **max-heap**.
We'll follow that convention here.

### Heap as a complete binary tree

A heap is a **complete binary tree** ‚Äî all levels are fully filled except possibly the last one, which is filled from left to right.

Because it's complete, we can represent it very efficiently using an array (**no pointers needed**).

### Array representation of a heap

For a max-heap stored in array **A[1..n]** (1-based indexing):

‚Ä¢ Root is at index 1
‚Ä¢ For node at index _i_:

- Left child = 2i
- Right child = 2i + 1
- Parent = ‚åäi/2‚åã

### Important note

In most programming languages (including **TypeScript / JavaScript**), arrays are **0-based**.

We'll show both conventions.

### Heap property (max-heap)

For every node _i_ (except root):

**A[PARENT(i)] ‚â• A[i]**

That is, every parent is larger than (or equal to) its children.

### Visual example ‚Äì Max-heap

```
        16
       /    \
     14      10
    /  \    /  \
   8    7  9    3
  / \  /
 2   4 1
```

**Array (1-based):**

```
[‚Äî, 16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
```

### Pseudocode ‚Äì Basic heap operations (max-heap, 1-based)

```
PARENT(i)      return floor(i / 2)
LEFT(i)        return 2 * i
RIGHT(i)       return 2 * i + 1

// Check if index i has left/right child
HAS-LEFT(i, heap-size)   return 2*i ‚â§ heap-size
HAS-RIGHT(i, heap-size)  return 2*i+1 ‚â§ heap-size
```

### TypeScript ‚Äì Heap class (0-based indexing ‚Äì practical version)

```ts
class MaxHeap {
  private heap: number[] = []; // 0-based

  // Helper methods
  private parent(i: number): number {
    return Math.floor((i - 1) / 2);
  }

  private left(i: number): number {
    return 2 * i + 1;
  }

  private right(i: number): number {
    return 2 * i + 2;
  }

  private swap(i: number, j: number): void {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  // Insert a new value
  insert(value: number): void {
    this.heap.push(value);
    this.heapifyUp(this.heap.length - 1);
  }

  // Fix heap property upward (after insert)
  private heapifyUp(index: number): void {
    let current = index;

    while (current > 0) {
      const p = this.parent(current);

      if (this.heap[p] < this.heap[current]) {
        this.swap(p, current);
        current = p;
      } else {
        break;
      }
    }
  }

  // Get maximum (root)
  getMax(): number | null {
    return this.heap.length > 0 ? this.heap[0] : null;
  }

  // Remove and return maximum
  extractMax(): number | null {
    if (this.heap.length === 0) return null;

    const max = this.heap[0];
    const last = this.heap.pop()!;

    if (this.heap.length > 0) {
      this.heap[0] = last;
      this.heapifyDown(0);
    }

    return max;
  }

  // Fix heap property downward
  private heapifyDown(index: number): void {
    const size = this.heap.length;
    let largest = index;

    const l = this.left(index);
    const r = this.right(index);

    if (l < size && this.heap[l] > this.heap[largest]) {
      largest = l;
    }
    if (r < size && this.heap[r] > this.heap[largest]) {
      largest = r;
    }

    if (largest !== index) {
      this.swap(index, largest);
      this.heapifyDown(largest);
    }
  }

  // Build heap from array (will be explained in 6.3)
  buildHeap(arr: number[]): void {
    this.heap = [...arr];
    // Start from last non-leaf node
    for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {
      this.heapifyDown(i);
    }
  }

  // For debugging
  print(): void {
    console.log(this.heap);
  }
}

// Example usage
const h = new MaxHeap();
h.insert(4);
h.insert(10);
h.insert(3);
h.insert(5);
h.insert(1);

console.log("Heap array:", h.heap); // e.g. [10, 5, 3, 4, 1]
console.log("Max:", h.getMax()); // 10
console.log("Extracted max:", h.extractMax()); // 10
console.log("New max:", h.getMax()); // 5
```

### Important properties of heaps

- Height of a heap with _n_ elements is Œò(log n)
- All operations (insert, extract-max, heapify) are O(log n)
- Building a heap from _n_ elements can be done in **O(n)** (not O(n log n)!) ‚Üí explained in 6.3

### Summary Table ‚Äì Heap Basics

| Property             | Value / Meaning              |
| -------------------- | ---------------------------- |
| Shape                | Complete binary tree         |
| Order                | Max-heap: parent ‚â• children  |
| Array representation | Very efficient (no pointers) |
| Root access          | O(1)                         |
| Insert / Extract-max | O(log n)                     |
| Build heap           | O(n)                         |
| Best use cases       | Priority queues, Heapsort    |

---

---

## 6.2 Maintaining the heap property

The most important operation for maintaining a heap is **HEAPIFY** (also called **MAX-HEAPIFY** for max-heap).

This procedure ensures that the heap property is restored when it is violated at a particular node (and only that node), assuming the subtrees are already valid heaps.

### The MAX-HEAPIFY procedure

#### Goal

Given a node at index _i_ whose subtrees are already max-heaps, but the value at _i_ might be smaller than one or both of its children,

**MAX-HEAPIFY** fixes the heap property at _i_ by moving the small value downward (sinking it) until the heap property holds again.

### Time complexity

**O(log n)** ‚Äî because the height of the heap is Œò(log n), and in the worst case we travel from root to leaf.

### Pseudocode (CLRS style ‚Äì 1-based indexing)

```
MAX-HEAPIFY(A, i, heap-size)
    l ‚Üê LEFT(i)          // 2i
    r ‚Üê RIGHT(i)         // 2i + 1

    // Find the largest among current node and its children
    largest ‚Üê i

    if l ‚â§ heap-size and A[l] > A[largest]
        largest ‚Üê l

    if r ‚â§ heap-size and A[r] > A[largest]
        largest ‚Üê r

    // If the current node is not the largest, swap and continue downward
    if largest ‚â† i
        swap A[i] with A[largest]
        MAX-HEAPIFY(A, largest, heap-size)   // recursive call
```

### TypeScript implementation (0-based indexing ‚Äì practical version)

```ts
class MaxHeap {
  private heap: number[] = [];

  // ... other methods from 6.1 ...

  /**
   * Restores the max-heap property starting from index i
   * Assumes subtrees rooted at left and right children are already max-heaps
   */
  private maxHeapify(i: number): void {
    const size = this.heap.length;
    let largest = i;

    const left = 2 * i + 1;
    const right = 2 * i + 2;

    // Compare with left child
    if (left < size && this.heap[left] > this.heap[largest]) {
      largest = left;
    }

    // Compare with right child
    if (right < size && this.heap[right] > this.heap[largest]) {
      largest = right;
    }

    // If largest is not the current node, swap and recurse
    if (largest !== i) {
      this.swap(i, largest);
      this.maxHeapify(largest);
    }
  }

  private swap(i: number, j: number): void {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  // For testing
  print(): void {
    console.log(this.heap);
  }
}

// Example usage
const heap = new MaxHeap();
heap.heap = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]; // violates at index 1 (4 is too small)

console.log("Before heapify:");
heap.print(); // [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]

heap.maxHeapify(1); // fix from index 1 (0-based)

console.log("After heapify:");
heap.print(); // [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
```

### Step-by-step example (from the book)

**Initial array (1-based):**

```
A = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]
```

Heap size = 10
Call **MAX-HEAPIFY(A, 2)** ‚Üê node with value 4 (index 2 in 1-based)

**Step 1**

left = 4 (value 7), right = 5 (value 9)
largest = 5 (9 is biggest among 4, 7, 9)

**Step 2**

Swap **4 ‚Üî 9**

```
A = [16, 14, 10, 7, 9, 4, 3, 2, 8, 1]
```

**Step 3**

Recurse on index 5 (now value 4)
Continue sinking until the heap property is satisfied

**Final (after full sinking):**

```
[16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
```

‚Äî valid max-heap

### Important properties

‚Ä¢ **MAX-HEAPIFY** runs in O(h) time where _h_ is the height of the subtree rooted at _i_
‚Üí h = Œò(log n) in a heap of size _n_

‚Ä¢ It is recursive in the book, but can be implemented iteratively for better performance in practice

‚Ä¢ This is the core subroutine used in:

- Building a heap (6.3)
- Heapsort (6.4)
- Priority queue operations (6.5)

### Summary Table ‚Äì MAX-HEAPIFY at a glance

| Aspect                    | Description                                 |
| ------------------------- | ------------------------------------------- |
| Input                     | array A, index i, heap-size                 |
| Assumption                | subtrees at 2i and 2i+1 are valid max-heaps |
| Output                    | heap property restored at i and below       |
| Running time              | O(log n)                                    |
| Space                     | O(1) extra (besides recursion stack)        |
| Common name in literature | heapify, sink, sift-down                    |

---

## 6.3 Building a heap

### Goal

Convert an arbitrary array into a valid max-heap as efficiently as possible.

### Naive way (not efficient)

Insert elements one by one using **insert** ‚Üí **O(n log n)** time.

### Smart way (CLRS method)

Use **BUILD-MAX-HEAP** ‚Üí runs in **O(n)** time (**linear!**)

### Why is it O(n) and not O(n log n)?

Because most nodes are near the bottom of the tree (leaves), and leaves already satisfy the heap property (no children).

We only need to call **MAX-HEAPIFY** on **non-leaf nodes**, starting from the bottom up.

The last non-leaf node is at index **‚åän/2‚åã**.

### Pseudocode (1-based indexing ‚Äì CLRS style)

```
BUILD-MAX-HEAP(A, n)
    heap-size[A] ‚Üê n
    // Start from the last non-leaf node and go upward
    for i ‚Üê ‚åän/2‚åã downto 1
        MAX-HEAPIFY(A, i, n)
```

### TypeScript code (0-based indexing ‚Äì practical version)

```ts
class MaxHeap {
  private heap: number[] = [];

  // ... (previous methods: maxHeapify, swap, etc.)

  /**
   * Builds a max-heap from an arbitrary array in O(n) time
   * @param arr the input array (will be modified in-place)
   */
  buildHeap(arr: number[]): void {
    // Copy the array (or work in-place if you prefer)
    this.heap = [...arr];

    const n = this.heap.length;

    // Start from the last non-leaf node
    // In 0-based indexing: last non-leaf = floor((n-1)/2)
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
      this.maxHeapify(i);
    }
  }

  // For debugging
  print(): void {
    console.log(this.heap);
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example usage
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const unsorted = [4, 10, 3, 5, 1, 9, 2, 8, 6, 7];

console.log("Before building heap:");
console.log(unsorted);
// [4, 10, 3, 5, 1, 9, 2, 8, 6, 7]

const heap = new MaxHeap();
heap.buildHeap(unsorted);

console.log("\nAfter BUILD-MAX-HEAP:");
heap.print();
// Example possible output: [10, 9, 8, 6, 7, 3, 2, 4, 5, 1]
```

### Why O(n) time? (Intuitive explanation)

Consider a heap of height **h = ‚åälog‚ÇÇ n‚åã**.

Number of nodes at height _k_ ‚âà **n / 2·µè**
Each call to **MAX-HEAPIFY** from height _k_ takes **O(k)** time in worst case

**Total time ‚âà**

```
Œ£ (number of nodes at height k) √ó O(k)
‚âà Œ£_{k=0}^{h} (n / 2^k) √ó k
= n √ó Œ£_{k=0}^{h} k / 2^k
```

The infinite series **Œ£ k / 2·µè** converges to **2**

‚Üí **Total time ‚â§ n √ó 2 = O(n)**

This is the famous **O(n) proof** ‚Äî very tight and elegant.

### Summary Table ‚Äì BUILD-MAX-HEAP

| Property         | Value / Note                              |
| ---------------- | ----------------------------------------- |
| Input            | Unsorted array of n elements              |
| Output           | Same array rearranged into valid max-heap |
| Time complexity  | O(n) ‚Äî surprisingly linear!               |
| Space complexity | O(1) extra (in-place)                     |
| Starting point   | Last non-leaf node ‚åän/2‚åã (1-based)        |
| Main subroutine  | MAX-HEAPIFY                               |
| Best use         | Foundation for heapsort & priority queues |

### Key Takeaway

> **BUILD-MAX-HEAP is linear time** ‚Äî one of the most beautiful and surprising results in basic algorithm courses.

---

## 6.4 The heapsort algorithm

Heapsort is an elegant in-place comparison-based sorting algorithm that combines the **BUILD-MAX-HEAP** procedure with the idea of repeatedly extracting the maximum element.

### Main idea of Heapsort

**First**, build a max-heap from the unsorted array ‚Üí **O(n)** time

**Repeatedly**:

‚Ä¢ Swap the root (maximum element) with the last element of the heap
‚Ä¢ Decrease the heap size by 1
‚Ä¢ Restore the max-heap property on the reduced heap ‚Üí **O(log n)** per extraction

After **n ‚àí 1** extractions, the array is sorted in increasing order.

### Why it works

‚Ä¢ The largest element ends up at the end after first extraction
‚Ä¢ The next largest ends up in the second-to-last position after second extraction
‚Ä¢ And so on‚Ä¶ ‚Üí the array gets sorted from right to left

### Pseudocode (CLRS style ‚Äì 1-based indexing)

```
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)

    for i = n downto 2
        swap A[1] with A[i]           // put maximum at the end
        heap-size ‚Üê heap-size - 1     // reduce heap size
        MAX-HEAPIFY(A, 1, heap-size)  // fix heap property
```

### TypeScript implementation (0-based indexing ‚Äì practical version)

```ts
/**
 * Sorts array in ascending order using Heapsort (in-place)
 * @param arr - array to sort (modified in-place)
 */
function heapSort(arr: number[]): number[] {
  const n = arr.length;

  // Step 1: Build max-heap (O(n))
  buildMaxHeap(arr);

  // Step 2: Extract elements from heap one by one (O(n log n))
  for (let i = n - 1; i > 0; i--) {
    // Move current root (maximum) to the end
    [arr[0], arr[i]] = [arr[i], arr[0]];

    // Heapify the reduced heap (size = i)
    maxHeapify(arr, 0, i);
  }

  return arr;
}

// Build max-heap from array
function buildMaxHeap(arr: number[]): void {
  const n = arr.length;

  // Start from the last non-leaf node
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    maxHeapify(arr, i, n);
  }
}

// Restore max-heap property for subtree rooted at index i
// with current heap size = heapSize
function maxHeapify(arr: number[], i: number, heapSize: number): void {
  let largest = i;
  const left = 2 * i + 1;
  const right = 2 * i + 2;

  // Compare with left child
  if (left < heapSize && arr[left] > arr[largest]) {
    largest = left;
  }

  // Compare with right child
  if (right < heapSize && arr[right] > arr[largest]) {
    largest = right;
  }

  // If largest is not current node, swap and continue heapifying
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    maxHeapify(arr, largest, heapSize);
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Example usage
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const example = [12, 11, 13, 5, 6, 7];
console.log("Before:", example);
heapSort(example);
console.log("After: ", example);
// Output:
// Before: [12, 11, 13, 5, 6, 7]
// After:  [5, 6, 7, 11, 12, 13]
```

### Time Complexity Summary

| Phase                         | Time Complexity | Explanation                            |
| ----------------------------- | --------------- | -------------------------------------- |
| BUILD-MAX-HEAP                | O(n)            | Linear time ‚Äì magical part             |
| n ‚àí 1 extractions + heapifies | O(n log n)      | Each extract-max takes O(log n)        |
| Total                         | Œò(n log n)      | Worst-case, average-case, best-case    |
| Space                         | O(1)            | In-place sorting (besides input array) |

### Comparison with other sorting algorithms

| Algorithm      | Worst-case | Average-case | Best-case  | In-place? | Stable? | Practical use case                    |
| -------------- | ---------- | ------------ | ---------- | --------- | ------- | ------------------------------------- |
| Heapsort       | Œò(n log n) | Œò(n log n)   | Œò(n log n) | Yes       | No      | Guaranteed O(n log n), in-place       |
| Merge Sort     | Œò(n log n) | Œò(n log n)   | Œò(n log n) | No        | Yes     | Stable, external sorting              |
| Quicksort      | Œò(n¬≤)      | Œò(n log n)   | Œò(n log n) | Yes       | No      | Fast in practice (randomized version) |
| Insertion Sort | Œò(n¬≤)      | Œò(n¬≤)        | Œò(n)       | Yes       | Yes     | Small / nearly sorted data            |

### Key properties of Heapsort

‚Ä¢ Always **Œò(n log n)** ‚Äì no bad cases like Quicksort
‚Ä¢ **In-place** ‚Äì only constant extra space
‚Ä¢ **Not stable** ‚Äì equal elements may change relative order
‚Ä¢ **Not adaptive** ‚Äì same time even if array is already sorted

Heapsort is often used when you need a guaranteed **O(n log n)** time and want to avoid extra space (unlike merge sort).

---

## 6.5 Priority Queues

A **priority queue** is an abstract data type that maintains a set of elements, each with an associated **priority**, and supports fast access to the element with the highest (or lowest) priority.

Heaps are the classic and most widely used implementation.

### Max-Priority Queue Operations

| Operation              | Description                               | Time (Binary Heap) |
| ---------------------- | ----------------------------------------- | ------------------ |
| `INSERT(key)`          | Insert a new element with priority `key`  | **O(log n)**       |
| `MAXIMUM()`            | Return highest-priority element (peek)    | **O(1)**           |
| `EXTRACT-MAX()`        | Remove & return highest-priority element  | **O(log n)**       |
| `INCREASE-KEY(i, key)` | Increase priority of element at index `i` | **O(log n)**       |

> A **min-priority queue** is implemented identically using a **min-heap**.

### Heap-Based Implementation Idea

- Store elements in a **max-heap**
- Heap order is based **only on priority**
- Elements can be:
  - Just priorities (numbers)
  - Or pairs: `(priority, value)`

### CLRS Pseudocode (1-Based Indexing)

### HEAP-MAXIMUM

```
return A[1]
```

### HEAP-EXTRACT-MAX

```
max ‚Üê A[1]
A[1] ‚Üê A[heap-size]
heap-size ‚Üê heap-size - 1
MAX-HEAPIFY(A, 1)
return max
```

### HEAP-INCREASE-KEY

```
if key < A[i]
    error
A[i] ‚Üê key
while i > 1 and A[PARENT(i)] < A[i]
    swap A[i] with A[PARENT(i)]
    i ‚Üê PARENT(i)
```

### MAX-HEAP-INSERT

```
heap-size ‚Üê heap-size + 1
A[heap-size] ‚Üê -‚àû
HEAP-INCREASE-KEY(A, heap-size, key)
```

### TypeScript: Max Priority Queue (Binary Heap, 0-Based)

```ts
class MaxPriorityQueue {
  private heap: number[] = [];

  private parent(i: number) {
    return Math.floor((i - 1) / 2);
  }
  private left(i: number) {
    return 2 * i + 1;
  }
  private right(i: number) {
    return 2 * i + 2;
  }

  private swap(i: number, j: number) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  private maxHeapify(i: number) {
    const n = this.heap.length;
    let largest = i;

    const l = this.left(i);
    const r = this.right(i);

    if (l < n && this.heap[l] > this.heap[largest]) largest = l;
    if (r < n && this.heap[r] > this.heap[largest]) largest = r;

    if (largest !== i) {
      this.swap(i, largest);
      this.maxHeapify(largest);
    }
  }

  insert(key: number) {
    this.heap.push(key);
    this.heapifyUp(this.heap.length - 1);
  }

  private heapifyUp(i: number) {
    while (i > 0 && this.heap[this.parent(i)] < this.heap[i]) {
      this.swap(i, this.parent(i));
      i = this.parent(i);
    }
  }

  maximum(): number | null {
    return this.heap.length ? this.heap[0] : null;
  }

  extractMax(): number | null {
    if (!this.heap.length) return null;

    const max = this.heap[0];
    const last = this.heap.pop()!;

    if (this.heap.length) {
      this.heap[0] = last;
      this.maxHeapify(0);
    }

    return max;
  }

  increaseKey(i: number, key: number) {
    if (key < this.heap[i]) throw new Error("Invalid key");
    this.heap[i] = key;
    this.heapifyUp(i);
  }
}
```

### Complexity Summary

| Operation     | Time     |
| ------------- | -------- |
| `insert`      | O(log n) |
| `maximum`     | O(1)     |
| `extractMax`  | O(log n) |
| `increaseKey` | O(log n) |
| `buildHeap`   | **O(n)** |
| Space         | O(n)     |

### Practical Notes

- Priority queues are everywhere:
  - Task schedulers
  - Dijkstra / Prim
  - Event simulation
  - OS process management

- `decreaseKey` / `increaseKey` requires knowing the index ‚Üí often solved with a **hash map**

- Binary heaps are simple and fast in practice

### Key Takeaway

> A priority queue is one of the most powerful abstractions in algorithms, and **heaps are its most elegant and practical implementation**.
