<img src="https://camo.githubusercontent.com/73d4fd0449641b47a8f3bef110b841ff985ac387c62da34a0b52f3b6197887f2/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4a6176615363726970742d4637444631453f7374796c653d666c6174266c6f676f3d6a617661736372697074266c6f676f436f6c6f723d626c61636b" alt="TS Logo" width="200">

### ðŸ”¹ **Basic**

#### 1. What are the different data types in JavaScript?  
JavaScript has **primitive** and **non-primitive** types.  

- **Primitive:** `string`, `number`, `boolean`, `null`, `undefined`, `bigint`, `symbol`  
- **Non-primitive:** `object` (arrays, functions, objects)

```js
let str = "Hello"; // string
let num = 42; // number
let isTrue = true; // boolean
let empty = null; // null
let notDefined; // undefined
let big = 123n; // bigint
let sym = Symbol(); // symbol
let obj = { name: "Boss" }; // object
let arr = [1, 2, 3]; // array
```

---

#### 2. Explain the difference between `var`, `let`, and `const`.  
| Feature | var | let | const |
|---------|-----|-----|-------|
| Scope | Function | Block | Block |
| Hoisting | Yes (undefined) | Yes (TDZ) | Yes (TDZ) |
| Reassignable | Yes | Yes | No |
| Redeclarable | Yes | No | No |

```js
var a = 10;
let b = 20;
const c = 30;
```

---

#### 3. What is hoisting in JavaScript?  
Hoisting moves **declarations** to the top of their scope before execution.  
- `var` â†’ hoisted with `undefined`  
- `let` & `const` â†’ hoisted but in **Temporal Dead Zone (TDZ)**  

```js
console.log(a); // undefined
var a = 5;

console.log(b); // ReferenceError
let b = 10;
```

---

#### 4. Difference between `==` and `===`.  
- `==` â†’ loose equality, type coercion  
- `===` â†’ strict equality, no coercion  

```js
5 == "5"; // true
5 === "5"; // false
```

---

#### 5. What is a closure? Can you give an example?  
A closure is when a function **remembers the variables** from its lexical scope, even after the outer function has finished execution.

```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  };
}
const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
```

---

#### 6. Explain the difference between `null`, `undefined`, and `NaN`.  
- `null` â†’ intentional absence of value  
- `undefined` â†’ variable declared but not assigned  
- `NaN` â†’ Not-a-Number (invalid number operation)  

```js
let a; // undefined
let b = null; // null
let c = "abc" / 2; // NaN
```

---

#### 7. How does the event loop work in JavaScript?  
- JS is **single-threaded**  
- Synchronous code â†’ call stack  
- Async code â†’ callback/microtask queue  
- Event loop checks if call stack is empty, pushes tasks from queue  

---

#### 8. Difference between synchronous and asynchronous code  
- **Synchronous:** blocking, executes line by line  
- **Asynchronous:** non-blocking, executes when ready (Promises, setTimeout, fetch)

```js
console.log("Start");
setTimeout(() => console.log("Async"), 1000);
console.log("End");
// Output: Start, End, Async
```

---

#### 9. What are template literals, and how are they useful?  
Strings with backticks (`), allow **interpolation** and **multiline strings**

```js
let name = "Boss";
console.log(`Hello, ${name}!`);
```

---

#### 10. Arrow functions vs regular functions  
- Shorter syntax  
- No own `this` (lexical `this`)  
- Cannot be constructors  

```js
const add = (a, b) => a + b;
```

---

### ðŸ”¹ **Intermediate**

#### 1. Explain prototypal inheritance  
Objects inherit from other objects via `__proto__` or `Object.create()`

```js
const parent = { greet() { console.log("Hello"); } };
const child = Object.create(parent);
child.greet(); // Hello
```

---

#### 2. Function declaration vs function expression  
- **Declaration:** hoisted, can call before definition  
- **Expression:** not hoisted, stored in variable

```js
// Declaration
function foo() {}
// Expression
const bar = function() {};
```

---

#### 3. How does `this` work?  
- Refers to the **execution context**  
- Regular function â†’ dynamic  
- Arrow function â†’ lexical `this`

```js
const obj = {
  x: 10,
  show: function() { console.log(this.x); }
};
obj.show(); // 10
```

---

#### 4. Promises  
Handle async code  

```js
const p = new Promise((res, rej) => setTimeout(() => res(42), 1000));
p.then(val => console.log(val)); // 42
```

---

#### 5. call(), apply(), bind()  
- `call(this, args...)` â†’ invoke immediately  
- `apply(this, [args])` â†’ invoke immediately with array  
- `bind(this)` â†’ returns new function

```js
function greet(age){ console.log(this.name, age); }
const person = { name: "Boss" };
greet.call(person, 30); // Boss 30
greet.apply(person, [30]); // Boss 30
const fn = greet.bind(person, 30); fn(); // Boss 30
```

---

#### 6. Event delegation  
Attach **single event listener** on parent, handle children  

```js
document.getElementById("parent").addEventListener("click", e => {
  if(e.target.tagName === "BUTTON") console.log("Button clicked");
});
```

---

#### 7. Higher-order functions  
Functions **taking/returning** other functions  

```js
const nums = [1,2,3];
const doubled = nums.map(x => x*2); // map is HOF
```

---

#### 8. Shallow vs deep copy  
- **Shallow:** references copied, nested objects still shared  
- **Deep:** fully independent copy

```js
const obj1 = { a: 1, b: { c: 2 } };
const shallow = {...obj1};
const deep = JSON.parse(JSON.stringify(obj1));
```

---

#### 9. Memory management  
JS uses **garbage collection**, automatically frees memory when object is unreachable

---

#### 10. ES6 features  
- `let/const`, arrow functions, template literals, destructuring, modules, promises, classes

---

### ðŸ”¹ **Advanced**

#### 1. Execution context & lexical environment  
- **Execution context:** environment where JS runs (global, function, eval)  
- **Lexical environment:** variables and their scope at code creation  

---

#### 2. Async programming  
Callbacks â†’ Promises â†’ async/await  

```js
async function fetchData() {
  const res = await fetch("url");
  const data = await res.json();
  return data;
}
```

---

#### 3. Microtasks vs Macrotasks  
- Microtasks â†’ `.then`, `queueMicrotask` â†’ executed before next event loop  
- Macrotasks â†’ `setTimeout`, `setInterval` â†’ executed after microtasks  

---

#### 4. Currying  
Convert multi-arg function to sequence of single-arg functions  

```js
const add = a => b => a + b;
console.log(add(2)(3)); // 5
```

---

#### 5. Debounce vs Throttle  

```js
// Debounce: wait until user stops
function debounce(fn, delay) {
  let timer;
  return (...args) => {
    clearTimeout(timer);

    timer = setTimeout(() => fn(...args), delay);
  };
}

const search = debounce((text) => {
  console.log('Searching for: ', text);
}, 1000);

document.getElementById('search').addEventListener('input', (e) => {
  search(e.target.value);
});

// Throttle: run at most once per interval
function throttle(fn, delay) {
  let last = 0;

  return (...args) => {
    const now = Date.now();
    console.log(now);
    if (now - last > delay) {
      fn(...args);
      last = now;
    }
  };
}

const logScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY);
}, 200);

window.addEventListener('scroll', logScroll);

```

---

#### 6. Generators  

```js
function* gen(){
  yield 1;
  yield 2;
}
const g = gen();
console.log(g.next()); // {value:1, done:false}
```

---

#### 7. Modules (import/export)  
- Export values, import in other files.  
- Behind the scenes, module system keeps **scope isolated**, supports **tree-shaking**

```js
// math.js
export const add = (a,b)=>a+b;
// index.js
import { add } from './math.js';
```

---

#### 8. Object.freeze, seal, preventExtensions  
| Method | What it does |
|--------|--------------|
| freeze | Cannot modify/add/delete properties |
| seal   | Cannot add/delete, can modify existing |
| preventExtensions | Cannot add new properties |

---

#### 9. V8 optimization  
- Inline caching, hidden classes, JIT compilation â†’ improves execution speed

---

#### 10. Implement map()/reduce()  

```js
Array.prototype.myMap = function(cb){
  const result = [];
  for(let i=0;i<this.length;i++) result.push(cb(this[i], i, this));
  return result;
}
```

---

### ðŸ”¹ **Scenario-Based**

#### 1. Debounce search input  
```js
const search = debounce((query)=>fetchResults(query), 300);
input.addEventListener("input", e=>search(e.target.value));
```

#### 2. Callback â†’ Promise  
```js
function asyncFunc(cb){
  setTimeout(()=>cb(null, 42), 1000);
}

function promisify(fn){
  return function(){
    return new Promise((res, rej)=>{
      fn((err, data)=> err?rej(err):res(data));
    });
  }
}
const asyncPromise = promisify(asyncFunc);
```

#### 3. Async error propagation  
```js
async function run(){
  try{
    const data = await fetchData();
  }catch(err){
    console.error(err);
  }
}
```

#### 4. Flatten array  
```js
const arr = [1,[2,[3,4]]];
const flat = arr.flat(2); // ES2019
```

#### 5. Run function once  
```js
function once(fn){
  let called=false;
  return function(...args){
    if(!called){ called=true; return fn(...args); }
  }
}
```

#### 6. Polyfill Promise.all  
```js
Promise.myAll = function(promises){
  return new Promise((res, rej)=>{
    let count=0, result=[];
    promises.forEach((p, i)=>{
      Promise.resolve(p).then(val=>{
        result[i]=val;
        count++;
        if(count===promises.length) res(result);
      }).catch(rej);
    });
  });
}
```

#### 7. localStorage vs sessionStorage vs cookies  
| Storage | Lifetime | Size | HTTP access |
|---------|---------|------|-------------|
| localStorage | Permanent | ~5MB | No |
| sessionStorage | Tab session | ~5MB | No |
| cookies | Expire manually | ~4KB | Yes |

---

#### 8. Optimize independent async functions  
```js
const [res1, res2] = await Promise.all([fetch1(), fetch2()]);
```

---

#### 9. Infinite scrolling  
```js
window.addEventListener("scroll", ()=>{
  if(window.innerHeight + window.scrollY >= document.body.offsetHeight){
    loadMoreData();
  }
});
```

---

#### 10. Prevent memory leaks  
- Remove event listeners  
- Avoid global variables  
- Nullify unused references  
- WeakMap/WeakSet for objects  

---
