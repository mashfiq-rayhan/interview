<img src="https://img.shields.io/badge/TypeScript-3178C6?logo=TypeScript&logoColor=FFF&style=for-the-badge" alt="TypeScript Badge" width="300" height="80"/>

---

### ðŸ”¹ 1. Basics

- **Types**: string, number, boolean, null, undefined, any, unknown
- **Arrays**: `number[]`, `Array<string>`
- **Tuples**: `[string, number]`
- **Enums**: numeric & string enums
- **Type Aliases**: `type ID = string | number`
- **Interfaces**: contracts for objects
- **Functions**:

  - Return types
  - Optional params
  - Default params
  - Arrow functions

---

### ðŸ”¹ 2. Advanced Types

- **Union Types**: `string | number`
- **Intersection Types**: `A & B`
- **Literal Types**: "up" | "down"
- **Type Narrowing**: `typeof`, `instanceof`, custom type guards
- **Type Assertions**: `value as string`
- **Nullable**: `string | null`
- **Non-null Assertion**: `value!`

---

### ðŸ”¹ 3. OOP (Classes)

- **Class Members**: public, private, protected, readonly
- **Constructors**
- **Inheritance**: `extends`
- **Abstract Classes**
- **Interfaces as Contracts**

---

### ðŸ”¹ 4. Generics

- **Functions**: `function identity<T>(arg: T): T`
- **Generic Constraints**: `<T extends Lengthwise>`
- **Interfaces with Generics**
- **Utility with Generics**

---

### ðŸ”¹ 5. Utility Types

- **Partial<T>**
- **Readonly<T>**
- **Pick\<T, K>**
- **Omit\<T, K>**
- **Record\<K, T>**
- **Exclude\<T, U>**
- **Extract\<T, U>**

---

### ðŸ”¹ 6. Modules

- **Export / Import**
- Default vs Named exports

---

### ðŸ”¹ 7. Type Guards

- `typeof`
- `instanceof`
- Custom guards: `value is string`

---

### ðŸ”¹ 8. Advanced Features

- **keyof**: keys of a type
- **typeof**: type of a variable
- **Mapped Types**: `[K in keyof T]`
- **Conditional Types**: `T extends U ? X : Y`
- **Infer**: extracting types from functions

---

### ðŸ”¹ 9. Decorators (Experimental)

- **Class Decorators**
- **Method Decorators**
- **Property Decorators**

---

### ðŸ”¹ 10. Best Practices

- Enable **strict mode** in `tsconfig.json`
- Prefer `unknown` over `any`
- Use `readonly` where possible
- Prefer `interface` for contracts, `type` for unions
- Avoid `!` non-null assertions unless necessary

<h1 align="center">
  <img src="https://img.shields.io/badge/TypeScript-3178C6?logo=TypeScript&logoColor=FFF&style=for-the-badge" 
       alt="TypeScript Badge" width="300" height="80"/>
</h1>

---

### ðŸ”¹ Basics

#### Types

```ts
let isDone: boolean = true;
let age: number = 25;
let userName: string = 'Rev';
let notSure: any = 4; // Avoid 'any' if possible
let u: undefined = undefined;
let n: null = null;
```

#### Arrays & Tuples

```ts
let list: number[] = [1, 2, 3];
let list2: Array<string> = ['a', 'b', 'c'];

let tuple: [string, number];
tuple = ['hello', 10];
```

#### Enums

```ts
enum Direction {
  Up = 1,
  Down,
  Left,
  Right
}
let move: Direction = Direction.Up;
```

#### Type Aliases & Interfaces

```ts
type ID = string | number;

interface User {
  id: ID;
  name: string;
  age?: number; // optional
}

let user: User = { id: 1, name: 'Rev' };
```

#### Functions

```ts
function add(x: number, y: number): number {
  return x + y;
}

const multiply = (x: number, y: number): number => x * y;

function log(message: string): void {
  console.log(message);
}

function identity<T>(arg: T): T {
  return arg;
}
```

---

### ðŸ”¹ Advanced Types

#### Union & Intersection

```ts
let value: string | number;

interface A {
  a: string;
}
interface B {
  b: number;
}
type C = A & B;
```

#### Type Narrowing

```ts
function printId(id: string | number) {
  if (typeof id === 'string') {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```

#### Literal Types

```ts
let direction: 'up' | 'down';
direction = 'up';
```

#### Type Assertions

```ts
let someValue: unknown = 'hello';
let strLength: number = (someValue as string).length;
```

#### Nullable & Non-Null Assertion

```ts
let x: string | null = null;
let y: string = x!; // non-null assertion
```

---

### ðŸ”¹ Classes & OOP

```ts
class Person {
  private id: number;
  public name: string;
  protected age: number;

  constructor(id: number, name: string, age: number) {
    this.id = id;
    this.name = name;
    this.age = age;
  }

  greet(): string {
    return `Hello, my name is ${this.name}`;
  }
}

class Student extends Person {
  grade: number;

  constructor(id: number, name: string, age: number, grade: number) {
    super(id, name, age);
    this.grade = grade;
  }
}
```

#### Abstract Classes & Interfaces

```ts
abstract class Animal {
  abstract makeSound(): void;
  move(): void {
    console.log('Moving...');
  }
}

interface Flyable {
  fly(): void;
}
```

---

### ðŸ”¹ Generics

```ts
function identity<T>(arg: T): T {
  return arg;
}

function loggingIdentity<T>(arg: T[]): T[] {
  console.log(arg.length);
  return arg;
}

interface GenericIdentityFn<T> {
  (arg: T): T;
}
```

---

### ðŸ”¹ Utility Types

```ts
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

let todo: Partial<Todo>;
let readonlyTodo: Readonly<Todo>;
let picked: Pick<Todo, 'title' | 'completed'>;
let omitted: Omit<Todo, 'description'>;
```

---

### ðŸ”¹ Modules

```ts
// math.ts
export function add(a: number, b: number): number {
  return a + b;
}

// main.ts
import { add } from './math';
```

---

### ðŸ”¹ Type Guards

```ts
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function example(value: string | number) {
  if (isString(value)) {
    console.log(value.toUpperCase());
  }
}
```

---

### ðŸ”¹ Advanced Features

#### keyof & typeof

```ts
interface Person {
  name: string;
  age: number;
}

type PersonKeys = keyof Person; // "name" | "age"

const person = { name: 'Rev', age: 25 };
type PersonType = typeof person;
```

#### Mapped Types

```ts
type OptionsFlags<T> = {
  [Property in keyof T]: boolean;
};

interface Features {
  darkMode: () => void;
  newUserProfile: () => void;
}

type FeatureOptions = OptionsFlags<Features>;
```

#### Conditional Types

```ts
type IsString<T> = T extends string ? true : false;
type A = IsString<string>; // true
type B = IsString<number>; // false
```

#### Infer

```ts
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

function foo(x: number): string {
  return x.toString();
}

type FooReturn = ReturnType<typeof foo>; // string
```

---

### ðŸ”¹ Decorators (Experimental)

```ts
function Logger(constructor: Function) {
  console.log('Logging...');
  console.log(constructor);
}

@Logger
class Car {
  constructor() {
    console.log('Car created');
  }
}
```

---

### Best Practices

- Prefer `unknown` over `any`.
- Use `readonly` for immutability.
- Avoid non-null assertions (`!`) unless necessary.
- Use `interface` for object contracts, `type` for unions and aliases.
- Enable `strict` mode in `tsconfig.json`.

---
