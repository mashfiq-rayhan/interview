## ðŸ”¹ Basic

**1. What is Node.js, and how is it different from JavaScript in the browser?**  
- **Node.js** is a runtime environment for executing JavaScript **server-side** using the V8 engine.  
- **Differences:**  
  | Feature | Browser JS | Node.js |
  |---------|------------|---------|
  | Environment | Client-side | Server-side |
  | I/O | Limited | File system, network, databases |
  | Modules | `<script>` or ES6 import | CommonJS (`require`) / ES6 modules |
  | Event Loop | Hidden | Exposed and non-blocking |

---

**2. What is the event loop in Node.js?**  
- The **event loop** allows Node.js to perform non-blocking I/O operations. It handles asynchronous callbacks by putting them into **queues** to be executed when the call stack is empty.

```js
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
console.log("End");
// Output: Start, End, Timeout
```

---

**3. Difference between synchronous and asynchronous functions:**  
- **Synchronous:** Blocks execution until finished.  
- **Asynchronous:** Runs in the background; execution continues without waiting.  

```js
// Sync
const data = fs.readFileSync('file.txt'); 

// Async
fs.readFile('file.txt', (err, data) => console.log(data));
```

---

**4. What are callbacks in Node.js?**  
- A **callback** is a function passed as an argument to another function to run **after an operation completes**.  

```js
fs.readFile('file.txt', (err, data) => {
  if (err) throw err;
  console.log(data.toString());
});
```

---

**5. What is npm, and how is it used in Node.js?**  
- **npm** = Node Package Manager, used for installing, updating, and managing packages.  
```bash
npm install express
```

---

**6. How do you handle exceptions in Node.js?**  
- Using `try-catch` for synchronous code.  
- Using `.catch()` for promises or `try-catch` with `async/await`.  
```js
try {
  const result = await someAsyncFunction();
} catch(err) {
  console.error(err);
}
```

---

**7. What are streams in Node.js?**  
- Streams are objects for reading/writing **data piece by piece** instead of loading it all at once.  
- Types: `Readable`, `Writable`, `Duplex`, `Transform`.  
```js
const fs = require('fs');
const readStream = fs.createReadStream('file.txt');
readStream.pipe(process.stdout);
```

---

**8. Difference between `require` and `import`:**  
- `require` â†’ CommonJS (Node.js default)  
- `import` â†’ ES6 module syntax  
- Syntax difference:  
```js
const fs = require('fs'); // CJS
import fs from 'fs';       // ES6
```

---

**9. How does Node.js handle child processes?**  
- Node.js can spawn child processes using `child_process` module (`exec`, `spawn`, `fork`) to run external commands without blocking the event loop.  

```js
const { exec } = require('child_process');
exec('ls', (err, stdout) => console.log(stdout));
```

---

**10. Difference between `process.nextTick()` and `setImmediate()`:**  
| Feature | `process.nextTick()` | `setImmediate()` |
|---------|-------------------|----------------|
| Queue | NextTick queue | Check phase of event loop |
| Timing | Before I/O events | After I/O events |
| Use | High priority callbacks | Lower priority tasks |

---

## ðŸ”¹ Intermediate

**1. Explain the concept of middleware in Node.js.**  
- Middleware is a function that executes during **request-response cycle** in frameworks like Express.js.  
```js
app.use((req, res, next) => {
  console.log(req.url);
  next();
});
```

---

**2. Difference between `fs.readFile` and `fs.createReadStream`:**  
- `fs.readFile` â†’ reads entire file into memory (blocking for large files).  
- `fs.createReadStream` â†’ reads file **in chunks**, better for large files.

---

**3. How to prevent callback hell:**  
- Use **Promises**, `async/await`, or modular functions.  

```js
async function getData() {
  const user = await getUser();
  const posts = await getPosts(user.id);
}
```

---

**4. Use of Promises and `async/await`:**  
- Promises handle async operations cleanly: `.then().catch()`.  
- `async/await` â†’ syntactic sugar over Promises, easier to read.  

---

**5. What is clustering in Node.js?**  
- Node.js is single-threaded; clustering allows creating **multiple processes** to utilize multiple CPU cores.  
```js
const cluster = require('cluster');
const http = require('http');
if (cluster.isMaster) {
  cluster.fork();
} else {
  http.createServer((req, res) => res.end('Hello')).listen(3000);
}
```

---

**6. Node.js concurrency handling:**  
- Event loop + **non-blocking I/O** allows Node.js to handle multiple requests **concurrently** without multithreading.

---

**7. `process.env` vs configuration files:**  
- `process.env` â†’ environment variables, usually for secrets or deployment configs.  
- Config files â†’ static configuration, often in JSON or JS.  

---

**8. Error handling with async/await:**  
```js
try {
  const data = await asyncFunction();
} catch(err) {
  console.error('Error:', err);
}
```

---

**9. What is EventEmitter:**  
- Allows objects to emit events and listen to them.  
```js
const EventEmitter = require('events');
const emitter = new EventEmitter();
emitter.on('greet', name => console.log(`Hello ${name}`));
emitter.emit('greet', 'Boss');
```

---

**10. How to secure a Node.js application:**  
- Sanitize inputs, use HTTPS, helmet, rate limiting, environment variables, JWT, etc.

---

## ðŸ”¹ Advanced

**1. Microservices vs Monolithic:**  
- Monolithic â†’ single app, tightly coupled  
- Microservices â†’ multiple services, independently deployable  

---

**2. Memory management & garbage collection:**  
- Node.js uses **V8â€™s GC** to manage memory, removing unreferenced objects automatically.  

---

**3. Difference between `fork()` and `spawn()`:**  
- `spawn()` â†’ new process, lightweight, for shell commands  
- `fork()` â†’ spawn new Node.js process with IPC (message passing)

---

**4. V8 engine optimization:**  
- Just-In-Time compilation, hidden classes, inline caching, garbage collection  

---

**5. Backpressure in streams:**  
- Occurs when writable stream is slower than readable stream.  
- Handle with `pipe()` or pause/resume mechanism.  

```js
readStream.pipe(writeStream);
```

---

**6. Implement caching:**  
- In-memory (`NodeCache`), Redis, or file system.  
```js
const NodeCache = require('node-cache');
const cache = new NodeCache();
cache.set('key', 'value', 100); // 100s
```

---

**7. Blocking vs non-blocking I/O:**  
- Blocking â†’ halts execution until operation completes  
- Non-blocking â†’ continues execution; callback runs when ready  

---

**8. Detecting & preventing memory leaks:**  
- Use `--inspect` and Chrome DevTools, monitor heap, remove unused references, avoid global variables.

---

**9. Load balancing strategies:**  
- Nginx, PM2 cluster mode, multiple Node instances with round-robin or sticky sessions  

---

**10. Scaling Node.js for millions:**  
- Cluster processes, microservices, caching, horizontal scaling, CDN for static assets

---

## ðŸ”¹ Scenario-Based

**1. Slow API under high load:**  
- Check CPU/memory, profiling, DB query optimization, caching, clustering  

**2. Unhandled promise rejection:**  
- Always attach `.catch()`, use `process.on('unhandledRejection')`  

**3. Upload large files efficiently:**  
- Use streams (`multer` or `busboy`) instead of loading full file in memory  

**4. Real-time chat app:**  
- Use WebSocket (Socket.io), event-driven architecture, Redis for pub/sub  

**5. Memory leaks:**  
- Profile heap, monitor process memory, remove global references, fix listeners  

**6. Rate limiting API:**  
- Use `express-rate-limit` or custom token bucket algorithm  

**7. Authentication:**  
- **JWT** for stateless APIs, sessions for stateful web apps, OAuth2 for third-party auth  

**8. Deploy/manage Node.js:**  
- Use PM2 or Docker, load balancer (Nginx), monitoring (Prometheus, NewRelic)  

**9. CPU-intensive function blocking event loop:**  
- Move it to **worker threads** or external microservice  

```js
const { Worker } = require('worker_threads');
```

**10. API consuming rate-limited third-party APIs:**  
- Implement throttling, batching requests, or queue system
